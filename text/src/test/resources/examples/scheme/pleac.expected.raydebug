comment(;;; -*- scheme -*-)

comment(;;; @@PLEAC@@_NAME)
comment(;;; @@SKIP@@ Guile 1.8)

comment(;;; @@PLEAC@@_WEB)
comment(;;; @@SKIP@@ http://www.gnu.org/software/guile/)

comment(;;; @@PLEAC@@_INTRO)
comment(;;; @@SKIP@@ Sections 1 - 3, and 7 - 9, largely completed using Guile 1.5; subsequent additions use Guile 1.8.)

comment(;;; @@PLEAC@@_APPENDIX)
comment(;;; @@SKIP@@ General-purpose, custom functions that might be used in several sections, appear here )

comment(;; Helper which aims to reduce code clutter by:)
comment(;; * Replacing the oft-used, '(display item\) (newline\)' combination)
comment(;; * Avoiding overuse of '(string-append\)' for simple output tasks)
operator(()keyword(define) operator(()ident(print) ident(item) operator(.) ident(rest)operator(\))
  operator(()keyword(let) operator(()operator(()ident(all-item) operator(()keyword(cons) ident(item) ident(rest)operator(\))operator(\))operator(\))
    operator(()ident(for-each)
      operator(()keyword(lambda) operator(()ident(item)operator(\)) operator(()ident(display) ident(item)operator(\)) operator(()ident(display) string<delimiter(")content( )delimiter(")>operator(\))operator(\))      
      ident(all-item)operator(\))operator(\))
  operator(()ident(newline)operator(\))operator(\))

comment(;; ------------)

comment(;; Slightly modified version of '(qx\)' from Chapter 4)
operator(()ident(use-modules) operator(()ident(ice-9) ident(popen)operator(\)) operator(()ident(srfi) ident(srfi-1)operator(\)) operator(()ident(srfi) ident(srfi-13)operator(\))operator(\))

operator(()keyword(define) operator(()ident(drain-output) ident(port)operator(\))
  operator(()keyword(let) ident(loop) operator(()operator(()ident(chars) operator(')operator(()operator(\))operator(\))
             operator(()ident(next) operator(()ident(read-char) ident(port)operator(\))operator(\))operator(\))
    operator(()keyword(if) operator(()ident(eof-object?) ident(next)operator(\))
        comment(; Modified to not return last 'line' with newline)
        operator(()ident(list->string) operator(()ident(reverse!) operator(()ident(cdr) ident(chars)operator(\))operator(\))operator(\))
        operator(()ident(loop) operator(()keyword(cons) ident(next) ident(chars)operator(\))
              operator(()ident(read-char) ident(port)operator(\))operator(\))operator(\))operator(\))operator(\))

operator(()keyword(define) operator(()ident(qx) ident(pipeline)operator(\))
  operator(()keyword(let*) operator(()operator(()ident(pipe) operator(()ident(open-input-pipe) ident(pipeline)operator(\))operator(\))
         operator(()ident(output) operator(()ident(drain-output) ident(pipe)operator(\))operator(\))operator(\))
    operator(()ident(close-pipe) ident(pipe)operator(\))
    ident(output)operator(\))operator(\))

comment(;; ------------)

comment(;; @@PLEAC@@_1.0)
operator(()keyword(define) ident(string) string<delimiter(")content(\\\\)content(n)delimiter(")>operator(\))                    comment(; two characters, \\ and an n)
operator(()keyword(define) ident(string) string<delimiter(")content(\\n)delimiter(")>operator(\))                     comment(; a "newline" character)
operator(()keyword(define) ident(string) string<delimiter(")content(Jon )content(\\")content(Maddog)content(\\")content( Orwant)delimiter(")>operator(\))  comment(; literal double quotes)
operator(()keyword(define) ident(string) string<delimiter(")content(Jon 'Maddog' Orwant)delimiter(")>operator(\))    comment(; literal single quotes)

operator(()keyword(define) ident(a) string<delimiter(")content(This is a multiline here document
terminated by a closing double quote)delimiter(")>operator(\))

comment(;; @@PLEAC@@_1.1)
comment(;; Use substring)

operator(()ident(substring) ident(str) ident(start) ident(end)operator(\))
operator(()ident(substring) ident(str) ident(start)operator(\))

comment(;; You can fill portions of a string with another string)

operator(()ident(substring-move-right!) ident(str) ident(start) ident(end) ident(newstring) ident(newstart)operator(\))
operator(()ident(substring-move-left!) ident(str) ident(start) ident(end) ident(newstring) ident(newstart)operator(\))

comment(;; Guile has a separate character type, and you can treat strings as a)
comment(;; character array.)

operator(()ident(string-ref) ident(str) ident(pos)operator(\))
operator(()ident(string-set!) ident(str) ident(pos) ident(char)operator(\))
operator(()ident(string-fill!) ident(str) ident(char)operator(\))
operator(()ident(substring-fill!) ident(str) ident(start) ident(end) ident(char)operator(\))

operator(()keyword(define) ident(s) string<delimiter(")content(This is what you have)delimiter(")>operator(\))
operator(()keyword(define) ident(first) operator(()ident(substring) ident(s) integer(0) integer(1)operator(\))operator(\))                     comment(; "T")
operator(()keyword(define) ident(start) operator(()ident(substring) ident(s) integer(5) integer(7)operator(\))operator(\))                     comment(; "is")
operator(()keyword(define) ident(rest)  operator(()ident(substring) ident(s) integer(13)operator(\))operator(\))                      comment(; "you have")
operator(()keyword(define) ident(last)  operator(()ident(substring) ident(s) operator(()integer(1)ident(-) operator(()ident(string-length) ident(s)operator(\))operator(\))operator(\))operator(\))  comment(; "e")
operator(()keyword(define) ident(end)   operator(()ident(substring) ident(s) operator(()ident(-) operator(()ident(string-length) ident(s)operator(\)) integer(4)operator(\))operator(\))operator(\)) comment(; "have")
operator(()keyword(define) ident(piece) operator(()keyword(let) operator(()operator(()ident(len) operator(()ident(string-length) ident(s)operator(\))operator(\))operator(\))
                operator(()ident(substring) ident(s) operator(()ident(-) ident(len) integer(8)operator(\)) operator(()ident(-) ident(len) integer(5)operator(\))operator(\))operator(\))operator(\))  comment(; "you")


comment(;;; Or use the string library SRFI-13)
operator(()ident(use-modules) operator(()ident(srfi) ident(srfi-13)operator(\))operator(\))

operator(()keyword(define) ident(s) string<delimiter(")content(This is what you have)delimiter(")>operator(\))
operator(()keyword(define) ident(first) operator(()ident(string-take) ident(s) integer(1)operator(\))operator(\))                     comment(; "T")
operator(()keyword(define) ident(start) operator(()ident(xsubstring) ident(s) integer(5) integer(7)operator(\))operator(\))                    comment(; "is")
operator(()keyword(define) ident(rest)  operator(()ident(xsubstring) ident(s) integer(13) ident(-)integer(1)operator(\))operator(\))                  comment(; "you have")
operator(()keyword(define) ident(last)  operator(()ident(string-take-right) ident(s) integer(1)operator(\))operator(\))               comment(; "e")
operator(()keyword(define) ident(end)   operator(()ident(string-take-right) ident(s) integer(4)operator(\))operator(\))               comment(; "have")
operator(()keyword(define) ident(piece) operator(()ident(xsubstring) ident(s) ident(-)integer(8) ident(-)integer(5)operator(\))operator(\))                  comment(; "you")

comment(;; Mutation of different sized strings is not allowed.  You have to)
comment(;; use set! to change the variable.)

operator(()keyword(set!) ident(s) operator(()ident(string-replace) ident(s) string<delimiter(")content(wasn't)delimiter(")> integer(5) integer(7)operator(\))operator(\))
comment(;; This wasn't what you have)
operator(()keyword(set!) ident(s) operator(()ident(string-replace) ident(s) string<delimiter(")content(ondrous)delimiter(")> integer(13) integer(25)operator(\))operator(\))
comment(;; This wasn't wondrous)
operator(()keyword(set!) ident(s) operator(()ident(string-take-right) ident(s) operator(()integer(1)ident(-) operator(()ident(string-length) ident(s)operator(\))operator(\))operator(\))operator(\))
comment(;; his wasn't wondrous)
operator(()keyword(set!) ident(s) operator(()ident(string-take) ident(s) integer(9)operator(\))operator(\))

comment(;; @@PLEAC@@_1.2)
operator(()keyword(define) ident(a) operator(()keyword(or) ident(b) ident(c)operator(\))operator(\))
operator(()keyword(define) ident(a) operator(()keyword(if) operator(()ident(defined?) ident(b)operator(\)) ident(b) ident(c)operator(\))operator(\))
operator(()keyword(define) ident(a) operator(()keyword(or) operator(()keyword(and) operator(()ident(defined?) ident(b)operator(\)) ident(b)operator(\)) ident(c)operator(\))operator(\))

comment(;; @@PLEAC@@_1.3)
comment(;; This doesn't really make sense in Scheme... temporary variables are)
comment(;; a natural construct and cheap.  If you want to swap variables in a)
comment(;; block without introducing any new variable names, you can use let:)

operator(()keyword(let) operator(()operator(()ident(a) ident(b)operator(\)) operator(()ident(b) ident(a)operator(\))operator(\))
  comment(;; ...)
  operator(\))

operator(()keyword(let) operator(()operator(()ident(alpha) ident(beta)operator(\)) operator(()ident(beta) ident(production)operator(\)) operator(()ident(production) ident(alpha)operator(\))operator(\))
  comment(;; ...)
  operator(\))

comment(;; @@PLEAC@@_1.4)
operator(()keyword(define) ident(num) operator(()ident(char->integer) ident(char)operator(\))operator(\))
operator(()keyword(define) ident(char) operator(()ident(integer->char) ident(num)operator(\))operator(\))

operator(()ident(use-modules) operator(()ident(srfi) ident(srfi-13)operator(\))operator(\))
operator(()keyword(let) operator(()operator(()ident(str) string<delimiter(")content(sample)delimiter(")>operator(\))operator(\))
  operator(()ident(display) operator(()ident(string-join)
            operator(()ident(map) ident(number->string)
                 operator(()ident(map) ident(char->integer) operator(()ident(string->list) ident(str)operator(\))operator(\))operator(\)) string<delimiter(")content( )delimiter(")>operator(\))operator(\))
  operator(()ident(newline)operator(\))operator(\))

operator(()keyword(let) operator(()operator(()ident(lst) operator(')operator(()integer(115) integer(97) integer(109) integer(112) integer(108) integer(101)operator(\))operator(\))operator(\))
  operator(()ident(display) operator(()ident(list->string) operator(()ident(map) ident(integer->char) ident(lst)operator(\))operator(\))operator(\))
  operator(()ident(newline)operator(\))operator(\))

operator(()keyword(letrec) operator(()operator(()ident(next) operator(()keyword(lambda) operator(()ident(c)operator(\)) operator(()ident(integer->char) operator(()integer(1)ident(+) operator(()ident(char->integer) ident(c)operator(\))operator(\))operator(\))operator(\))operator(\))operator(\))
  operator(()keyword(let*) operator(()operator(()ident(hal) string<delimiter(")content(HAL)delimiter(")>operator(\))
         operator(()ident(ibm) operator(()ident(list->string) operator(()ident(map) ident(next) operator(()ident(string->list) ident(hal)operator(\))operator(\))operator(\))operator(\))operator(\))
    operator(()ident(display) ident(ibm)operator(\))
    operator(()ident(newline)operator(\))operator(\))operator(\))

comment(;; @@PLEAC@@_1.5)
comment(;; Convert the string to a list of characters)
operator(()ident(map) ident(proc)
     operator(()ident(string->list) ident(str)operator(\))operator(\))

operator(()ident(use-modules) operator(()ident(srfi) ident(srfi-1)operator(\))operator(\))
operator(()ident(format) predefined_constant(#t) string<delimiter(")content(unique chars are: ~A)content(\\n)delimiter(")>
        operator(()ident(apply) ident(string) operator(()ident(sort) operator(()ident(delete-duplicates)
                             operator(()ident(string->list) string<delimiter(")content(an apple a day)delimiter(")>operator(\))operator(\)) ident(char<?)operator(\))operator(\))operator(\))

operator(()keyword(let*) operator(()operator(()ident(str) string<delimiter(")content(an apple a day)delimiter(")>operator(\))
       operator(()ident(sum) operator(()ident(apply) ident(+) operator(()ident(map) ident(char->integer) operator(()ident(string->list) ident(str)operator(\))operator(\))operator(\))operator(\))operator(\))
  operator(()ident(format) predefined_constant(#t) string<delimiter(")content(sum is ~A)content(\\n)delimiter(")> ident(sum)operator(\))operator(\))

comment(;;; or use string-fold/string-map/string-for-each from SRFI-13)
operator(()ident(use-modules) operator(()ident(srfi) ident(srfi-13)operator(\))operator(\))

operator(()keyword(let*) operator(()operator(()ident(str) string<delimiter(")content(an apple a day)delimiter(")>operator(\))
       operator(()ident(sum) operator(()ident(string-fold) operator(()keyword(lambda) operator(()ident(c) ident(acc)operator(\)) operator(()ident(+) ident(acc) operator(()ident(char->integer) ident(c)operator(\))operator(\))operator(\))
                         integer(0) ident(str)operator(\))operator(\))operator(\))
  operator(()ident(format) predefined_constant(#t) string<delimiter(")content(sum is ~A)content(\\n)delimiter(")> ident(sum)operator(\))operator(\))

error(#)ident(!/usr/local/bin/guile) ident(-)ident(s)
ident(!)error(#)
comment(;; sum - compute 16-bit checksum of all input files)
operator(()ident(use-modules) operator(()ident(srfi) ident(srfi-13)operator(\))operator(\))
operator(()keyword(define) operator(()ident(checksum) ident(p)operator(\))
  operator(()keyword(let) ident(loop) operator(()operator(()ident(line) operator(()ident(read-line) ident(p) operator(')ident(concat)operator(\))operator(\)) operator(()ident(sum) integer(0)operator(\))operator(\))
    operator(()keyword(if) operator(()ident(eof-object?) ident(line)operator(\))
      operator(()ident(format) predefined_constant(#t) string<delimiter(")content(~A ~A)content(\\n)delimiter(")> ident(sum) operator(()ident(port-filename) ident(p)operator(\))operator(\))
      operator(()keyword(let) operator(()operator(()ident(line-sum) operator(()ident(string-fold) operator(()keyword(lambda) operator(()ident(c) ident(acc)operator(\))
                                     operator(()ident(+) ident(acc) operator(()ident(char->integer) ident(c)operator(\))operator(\))operator(\))
                                   integer(0) ident(line)operator(\))operator(\))operator(\))
        operator(()ident(loop) operator(()ident(read-line) ident(p) operator(')ident(concat)operator(\)) operator(()ident(modulo) operator(()ident(+) ident(sum) ident(line-sum)operator(\))
                                            operator(()integer(1)ident(-) operator(()ident(expt) integer(2) integer(16)operator(\))operator(\))operator(\))operator(\))operator(\))operator(\))operator(\))operator(\))
operator(()keyword(let) operator(()operator(()ident(args) operator(()ident(cdr) operator(()ident(command-line)operator(\))operator(\))operator(\))operator(\))
  operator(()keyword(if) operator(()ident(null?) ident(args)operator(\))
    operator(()ident(checksum) operator(()ident(current-input-port)operator(\))operator(\))
    operator(()ident(for-each) operator(()keyword(lambda) operator(()ident(f)operator(\)) operator(()ident(call-with-input-file) ident(f) ident(checksum)operator(\))operator(\)) ident(args)operator(\))operator(\))operator(\))

error(#)ident(!/usr/local/bin/guile) ident(-)ident(s)
ident(!)error(#)
comment(;; slowcat - emulate a  s l o w  line printer)
operator(()ident(use-modules) operator(()ident(ice-9) ident(regex)operator(\)) operator(()ident(srfi) ident(srfi-2)operator(\)) operator(()ident(srfi) ident(srfi-13)operator(\))operator(\))
operator(()keyword(define) ident(args) operator(()ident(cdr) operator(()ident(command-line)operator(\))operator(\))operator(\))
operator(()keyword(define) keyword(delay) integer(1)operator(\))
operator(()ident(and-let*) operator(()operator(()ident(p) operator(()ident(pair?) ident(args)operator(\))operator(\))
           operator(()ident(m) operator(()ident(string-match) string<delimiter(")content(^-([0-9]+\)$)delimiter(")> operator(()ident(car) ident(args)operator(\))operator(\))operator(\))operator(\))
  operator(()keyword(set!) keyword(delay) operator(()ident(string->number) operator(()ident(match:substring) ident(m) integer(1)operator(\))operator(\))operator(\))
  operator(()keyword(set!) ident(args) operator(()ident(cdr) ident(args)operator(\))operator(\))operator(\))
operator(()keyword(define) operator(()ident(slowcat) ident(p)operator(\))
  operator(()keyword(let) ident(loop) operator(()operator(()ident(line) operator(()ident(read-line) ident(p) operator(')ident(concat)operator(\))operator(\))operator(\))
    operator(()keyword(cond) operator(()operator(()ident(not) operator(()ident(eof-object?) ident(line)operator(\))operator(\))
           operator(()ident(string-for-each)
            operator(()keyword(lambda) operator(()ident(c)operator(\)) operator(()ident(display) ident(c)operator(\)) operator(()ident(usleep) operator(()ident(*) integer(5) keyword(delay)operator(\))operator(\))operator(\)) ident(line)operator(\))
           operator(()ident(loop) operator(()ident(read-line) ident(p) operator(')ident(concat)operator(\))operator(\))operator(\))operator(\))operator(\))operator(\))
operator(()keyword(if) operator(()ident(null?) ident(args)operator(\))
  operator(()ident(slowcat) operator(()ident(current-input-port)operator(\))operator(\))
  operator(()ident(for-each) operator(()keyword(lambda) operator(()ident(f)operator(\)) operator(()ident(call-with-input-file) ident(f) ident(slowcat)operator(\))operator(\)) ident(args)operator(\))operator(\))

comment(;; @@PLEAC@@_1.6)
operator(()keyword(define) ident(revbytes) operator(()ident(list->string) operator(()ident(reverse) operator(()ident(string->list) ident(str)operator(\))operator(\))operator(\))operator(\))

comment(;;; Or from SRFI-13)
operator(()ident(use-modules) operator(()ident(srfi) ident(srfi-13)operator(\))operator(\))
operator(()keyword(define) ident(revbytes) operator(()ident(string-reverse) ident(str)operator(\))operator(\))
operator(()ident(string-reverse!) ident(str)operator(\)) comment(; modifies in place)

operator(()keyword(define) ident(revwords) operator(()ident(string-join) operator(()ident(reverse) operator(()ident(string-tokenize) ident(str)operator(\))operator(\)) string<delimiter(")content( )delimiter(")>operator(\))operator(\))

operator(()ident(with-input-from-file) string<delimiter(")content(/usr/share/dict/words)delimiter(")>
  operator(()keyword(lambda) operator(()operator(\))
    operator(()keyword(do) operator(()operator(()ident(word) operator(()ident(read-line)operator(\)) operator(()ident(read-line)operator(\))operator(\))operator(\))
        operator(()operator(()ident(eof-object?) ident(word)operator(\))operator(\))
      operator(()keyword(if) operator(()keyword(and) operator(()ident(>) operator(()ident(string-length) ident(word)operator(\)) integer(5)operator(\))
               operator(()ident(string=?) ident(word) operator(()ident(string-reverse) ident(word)operator(\))operator(\))operator(\))
        operator(()ident(write-line) ident(word)operator(\))operator(\))operator(\))operator(\))operator(\))

comment(;; A little too verbose on the command line)
comment(;; guile --use-srfi=13 -c '(with-input-from-file "/usr/share/dict/words" (lambda (\) (do ((word (read-line\) (read-line\)\)\) ((eof-object? word\)\) (if (and (> (string-length word\) 5\) (string=? word (string-reverse word\)\)\) (write-line word\)\)\)\)\)')

comment(;; @@PLEAC@@_1.7)
comment(;; Use regexp-substitute/global)
operator(()ident(regexp-substitute/global)
 predefined_constant(#f) string<delimiter(")content(([^)content(\\t)content(]*\)()content(\\t)content(+\))delimiter(")> ident(str)
 operator(()keyword(lambda) operator(()ident(m)operator(\))
   operator(()keyword(let*) operator(()operator(()ident(pre-string) operator(()ident(match:substring) ident(m) integer(1)operator(\))operator(\))
          operator(()ident(pre-len) operator(()ident(string-length) ident(pre-string)operator(\))operator(\))
          operator(()ident(match-len) operator(()ident(-) operator(()ident(match:end) ident(m) integer(2)operator(\)) operator(()ident(match:start) ident(m) integer(2)operator(\))operator(\))operator(\))operator(\))
     operator(()ident(string-append)
      ident(pre-string)
      operator(()ident(make-string)
       operator(()ident(-) operator(()ident(*) ident(match-len) integer(8)operator(\))
          operator(()ident(modulo) ident(pre-len) integer(8)operator(\))operator(\))
       char(#\\space)operator(\))operator(\))operator(\))operator(\))
 operator(')ident(post)operator(\))

comment(;; @@PLEAC@@_1.8)
comment(;; just interpolate $abc in strings:)
operator(()keyword(define) operator(()ident(varsubst) ident(str)operator(\))
  operator(()ident(regexp-substitute/global) predefined_constant(#f) string<delimiter(")content(\\\\)content($()content(\\\\)content(w+\))delimiter(")> ident(str)
   operator(')ident(pre) operator(()keyword(lambda) operator(()ident(m)operator(\)) operator(()ident(eval) operator(()ident(string->symbol) operator(()ident(match:substring) ident(m) integer(1)operator(\))operator(\))
                          operator(()ident(current-module)operator(\))operator(\))operator(\))
   operator(')ident(post)operator(\))operator(\))

comment(;; interpolate $abc with error messages:)
operator(()keyword(define) operator(()ident(safe-varsubst) ident(str)operator(\))
  operator(()ident(regexp-substitute/global) predefined_constant(#f) string<delimiter(")content(\\\\)content($()content(\\\\)content(w+\))delimiter(")> ident(str)
   operator(')ident(pre) operator(()keyword(lambda) operator(()ident(m)operator(\))
          operator(()ident(catch) predefined_constant(#t)
            operator(()keyword(lambda) operator(()operator(\)) operator(()ident(eval) operator(()ident(string->symbol) operator(()ident(match:substring) ident(m) integer(1)operator(\))operator(\))
                             operator(()ident(current-module)operator(\))operator(\))operator(\))
            operator(()keyword(lambda) ident(args)
              operator(()ident(format) predefined_constant(#f) string<delimiter(")content([NO VARIABLE: ~A])delimiter(")> operator(()ident(match:substring) ident(m) integer(1)operator(\))operator(\))operator(\))operator(\))operator(\))
   operator(')ident(post)operator(\))operator(\))

comment(;; interpolate ${(any (scheme expression\)\)} in strings:)
operator(()keyword(define) operator(()ident(interpolate) ident(str)operator(\))
  operator(()ident(regexp-substitute/global) predefined_constant(#f) string<delimiter(")content(\\\\)content(${([^{}]+\)})delimiter(")> ident(str)
   operator(')ident(pre) operator(()keyword(lambda) operator(()ident(m)operator(\)) operator(()ident(eval-string) operator(()ident(match:substring) ident(m) integer(1)operator(\))operator(\))operator(\)) operator(')ident(post)operator(\))operator(\))

comment(;; @@PLEAC@@_1.9)
operator(()ident(use-modules) operator(()ident(srfi) ident(srfi-13)operator(\))operator(\))

operator(()ident(string-upcase) string<delimiter(")content(bo beep)delimiter(")>operator(\))     comment(; BO PEEP)
operator(()ident(string-downcase) string<delimiter(")content(JOHN)delimiter(")>operator(\))      comment(; john)
operator(()ident(string-titlecase) string<delimiter(")content(bo)delimiter(")>operator(\))       comment(; Bo)
operator(()ident(string-titlecase) string<delimiter(")content(JOHN)delimiter(")>operator(\))     comment(; John)

operator(()ident(string-titlecase) string<delimiter(")content(thIS is a loNG liNE)delimiter(")>operator(\))  comment(; This Is A Long Line)

error(#)ident(!/usr/local/bin/guile) ident(-)ident(s)
ident(!)error(#)
comment(;; randcap: filter to randomly capitalize 20% of the time)
operator(()ident(use-modules) operator(()ident(srfi) ident(srfi-13)operator(\))operator(\))
operator(()ident(seed->random-state) operator(()ident(current-time)operator(\))operator(\))
operator(()keyword(define) operator(()ident(randcap) ident(p)operator(\))
  operator(()keyword(let) ident(loop) operator(()operator(()ident(line) operator(()ident(read-line) ident(p) operator(')ident(concat)operator(\))operator(\))operator(\))
    operator(()keyword(cond) operator(()operator(()ident(not) operator(()ident(eof-object?) ident(line)operator(\))operator(\))
           operator(()ident(display) operator(()ident(string-map) operator(()keyword(lambda) operator(()ident(c)operator(\))
                                  operator(()keyword(if) operator(()ident(=) operator(()ident(random) integer(5)operator(\)) integer(0)operator(\))
                                    operator(()ident(char-upcase) ident(c)operator(\))
                                    operator(()ident(char-downcase) ident(c)operator(\))operator(\))operator(\))
                                ident(line)operator(\))operator(\))
           operator(()ident(loop) operator(()ident(read-line) ident(p) operator(')ident(concat)operator(\))operator(\))operator(\))operator(\))operator(\))operator(\))
operator(()keyword(let) operator(()operator(()ident(args) operator(()ident(cdr) operator(()ident(command-line)operator(\))operator(\))operator(\))operator(\))
  operator(()keyword(if) operator(()ident(null?) ident(args)operator(\))
    operator(()ident(randcap) operator(()ident(current-input-port)operator(\))operator(\))
    operator(()ident(for-each) operator(()keyword(lambda) operator(()ident(f)operator(\)) operator(()ident(call-with-input-file) ident(f) ident(randcap)operator(\))operator(\)) ident(args)operator(\))operator(\))operator(\))

comment(;; @@PLEAC@@_1.10)
comment(;; You can do this with format.  Lisp/Scheme format is a little)
comment(;; different from what you may be used to with C/Perl style printf)
comment(;; (actually far more powerful\) , but if you keep in mind that we use)
comment(;; ~ instead of %, and , instead of . for the prefix characters, you)
comment(;; won't have trouble getting used to Guile's format.)

operator(()ident(format) predefined_constant(#f) string<delimiter(")content(I have ~A guanacos.)delimiter(")> ident(n)operator(\))

comment(;; @@PLEAC@@_1.11)
operator(()keyword(define) ident(var) string<delimiter(")content(
        your text
        goes here)delimiter(")>operator(\))

operator(()ident(use-modules) operator(()ident(ice-9) ident(regexp)operator(\))operator(\))
operator(()keyword(set!) ident(var) operator(()ident(regexp-substitute/global) predefined_constant(#f) string<delimiter(")content(\\n)content( +)delimiter(")> ident(var) operator(')ident(pre) string<delimiter(")content(\\n)delimiter(")> operator(')ident(post)operator(\))operator(\))

operator(()ident(use-modules) operator(()ident(srfi) ident(srfi-13)operator(\))operator(\))
operator(()keyword(set!) ident(var) operator(()ident(string-join) operator(()ident(map) ident(string-trim) operator(()ident(string-tokenize) ident(var) char(#\\newline)operator(\))operator(\)) string<delimiter(")content(\\n)delimiter(")>operator(\))operator(\))

operator(()ident(use-modules) operator(()ident(ice-9) ident(regexp)operator(\)) operator(()ident(srfi) ident(srfi-13)operator(\)) operator(()ident(srfi) ident(srfi-14)operator(\))operator(\))
operator(()keyword(define) operator(()ident(dequote) ident(str)operator(\))
  operator(()keyword(let*) operator(()operator(()ident(str) operator(()keyword(if) operator(()ident(char=?) operator(()ident(string-ref) ident(str) integer(0)operator(\)) char(#\\newline)operator(\))
                operator(()ident(substring) ident(str) integer(1)operator(\)) ident(str)operator(\))operator(\))
         operator(()ident(lines) operator(()ident(string-tokenize) ident(str) char(#\\newline)operator(\))operator(\))
         operator(()ident(rx) operator(()keyword(let) ident(loop) operator(()operator(()ident(leader) operator(()ident(car) ident(lines)operator(\))operator(\)) operator(()ident(lst) operator(()ident(cdr) ident(lines)operator(\))operator(\))operator(\))
               operator(()keyword(cond) operator(()operator(()ident(string=) ident(leader) string<delimiter(")delimiter(")>operator(\))
                      operator(()keyword(let) operator(()operator(()ident(pos) operator(()keyword(or) operator(()ident(string-skip) operator(()ident(car) ident(lines)operator(\))
                                                  ident(char-set:whitespace)operator(\)) integer(0)operator(\))operator(\))operator(\))
                        operator(()ident(make-regexp) operator(()ident(format) predefined_constant(#f) string<delimiter(")content(^[ )content(\\\\)content(t]{1,~A})delimiter(")> ident(pos)operator(\))
                                     ident(regexp/newline)operator(\))operator(\))operator(\))
                     operator(()operator(()ident(null?) ident(lst)operator(\))
                      operator(()ident(make-regexp) operator(()ident(string-append) string<delimiter(")content(^[ )content(\\\\)content(t]*)delimiter(")>
                                                  operator(()ident(regexp-quote) ident(leader)operator(\))operator(\))
                                   ident(regexp/newline)operator(\))operator(\))
                     operator(()ident(else)
                      operator(()keyword(let) operator(()operator(()ident(pos) operator(()keyword(or) operator(()ident(string-prefix-length) ident(leader) operator(()ident(car) ident(lst)operator(\))operator(\)) integer(0)operator(\))operator(\))operator(\))
                        operator(()ident(loop) operator(()ident(substring) ident(leader) integer(0) ident(pos)operator(\)) operator(()ident(cdr) ident(lst)operator(\))operator(\))operator(\))operator(\))operator(\))operator(\))operator(\))operator(\))
    operator(()ident(regexp-substitute/global) predefined_constant(#f) ident(rx) ident(str) operator(')ident(pre) operator(')ident(post)operator(\))operator(\))operator(\))

comment(;; @@PLEAC@@_1.12)
operator(()ident(use-modules) operator(()ident(srfi) ident(srfi-13)operator(\))operator(\))

operator(()keyword(define) ident(text) string<delimiter(")content(Folding and splicing is the work of an editor,
not a mere collection of silicon
and
mobile electrons!)delimiter(")>operator(\))

operator(()keyword(define) operator(()ident(wrap) ident(str) ident(max-col)operator(\))
  operator(()keyword(let*) operator(()operator(()ident(words) operator(()ident(string-tokenize) ident(str)operator(\))operator(\))
         operator(()ident(all) operator(')operator(()operator(\))operator(\))
         operator(()ident(first) operator(()ident(car) ident(words)operator(\))operator(\))
         operator(()ident(col) operator(()ident(string-length) ident(first)operator(\))operator(\))
         operator(()ident(line) operator(()ident(list) ident(first)operator(\))operator(\))operator(\))
    operator(()ident(for-each)
     operator(()keyword(lambda) operator(()ident(x)operator(\))
       operator(()keyword(let*) operator(()operator(()ident(len) operator(()ident(string-length) ident(x)operator(\))operator(\))
              operator(()ident(new-col) operator(()ident(+) ident(col) ident(len) integer(1)operator(\))operator(\))operator(\))
         operator(()keyword(cond) operator(()operator(()ident(>) ident(new-col) ident(max-col)operator(\))
                operator(()keyword(set!) ident(all) operator(()keyword(cons) operator(()ident(string-join) operator(()ident(reverse!) ident(line)operator(\)) string<delimiter(")content( )delimiter(")>operator(\)) ident(all)operator(\))operator(\))
                operator(()keyword(set!) ident(line) operator(()ident(list) ident(x)operator(\))operator(\))
                operator(()keyword(set!) ident(col) ident(len)operator(\))operator(\))
               operator(()ident(else)
                operator(()keyword(set!) ident(line) operator(()keyword(cons) ident(x) ident(line)operator(\))operator(\))
                operator(()keyword(set!) ident(col) ident(new-col)operator(\))operator(\))operator(\))operator(\))operator(\))
     operator(()ident(cdr) ident(words)operator(\))operator(\))
    operator(()keyword(set!) ident(all) operator(()keyword(cons) operator(()ident(string-join) operator(()ident(reverse!) ident(line)operator(\)) string<delimiter(")content( )delimiter(")>operator(\)) ident(all)operator(\))operator(\))
    operator(()ident(string-join) operator(()ident(reverse!) ident(all)operator(\)) string<delimiter(")content(\\n)delimiter(")>operator(\))operator(\))operator(\))

operator(()ident(display) operator(()ident(wrap) ident(text) integer(20)operator(\))operator(\))

comment(;; @@PLEAC@@_1.13)
operator(()keyword(define) ident(str) string<delimiter(")content(Mom said, )content(\\")content(Don't do that.)content(\\")delimiter(")>operator(\))
operator(()keyword(set!) ident(str) operator(()ident(regexp-substitute/global) predefined_constant(#f) string<delimiter(")content([')content(\\")content(])delimiter(")> ident(str) operator(')ident(pre) string<delimiter(")content(\\\\)delimiter(")>
                                    ident(match:substring) operator(')ident(post)operator(\))operator(\))
operator(()keyword(set!) ident(str) operator(()ident(regexp-substitute/global) predefined_constant(#f) string<delimiter(")content([^A-Z])delimiter(")> ident(str) operator(')ident(pre) string<delimiter(")content(\\\\)delimiter(")>
                                    ident(match:substring) operator(')ident(post)operator(\))operator(\))
operator(()keyword(set!) ident(str) operator(()ident(string-append) string<delimiter(")content(this )delimiter(")> operator(()ident(regexp-substitute/global)
                                  predefined_constant(#f) string<delimiter(")content(\\W)delimiter(")> string<delimiter(")content(is a test!)delimiter(")> operator(')ident(pre) string<delimiter(")content(\\\\)delimiter(")>
                                  ident(match:substring) operator(')ident(post)operator(\))operator(\))operator(\))

comment(;; @@PLEAC@@_1.14)
operator(()ident(use-modules) operator(()ident(srfi) ident(srfi-13)operator(\))operator(\))

operator(()keyword(define) ident(str) string<delimiter(")content(  space  )delimiter(")>operator(\))
operator(()ident(string-trim) ident(str)operator(\))          comment(; "space  ")
operator(()ident(string-trim-right) ident(str)operator(\))    comment(; "  space")
operator(()ident(string-trim-both) ident(str)operator(\))     comment(; "space")

comment(;; @@PLEAC@@_1.15)
operator(()ident(use-modules) operator(()ident(srfi) ident(srfi-2)operator(\)) operator(()ident(srfi) ident(srfi-13)operator(\)) operator(()ident(ice-9) ident(format)operator(\))operator(\))

operator(()keyword(define) ident(parse-csv)
  operator(()keyword(let*) operator(()operator(()ident(csv-match) operator(()ident(string-join) operator(')operator(()string<delimiter(")content(\\")content(([^)content(\\")content(\\\\)content(\\\\)content(]*()content(\\\\)content(\\\\)content(.[^)content(\\")content(\\\\)content(\\\\)content(]*\)*\))content(\\")content(,?)delimiter(")>
                                   string<delimiter(")content(([^,]+\),?)delimiter(")>
                                   string<delimiter(")content(,)delimiter(")>operator(\))
                                 string<delimiter(")content(|)delimiter(")>operator(\))operator(\))
         operator(()ident(csv-rx) operator(()ident(make-regexp) ident(csv-match)operator(\))operator(\))operator(\))
    operator(()keyword(lambda) operator(()ident(text)operator(\))
      operator(()keyword(let) operator(()operator(()ident(start) integer(0)operator(\))
            operator(()ident(result) operator(')operator(()operator(\))operator(\))operator(\))
        operator(()keyword(let) ident(loop) operator(()operator(()ident(start) integer(0)operator(\))operator(\))
          operator(()ident(and-let*) operator(()operator(()ident(m) operator(()ident(regexp-exec) ident(csv-rx) ident(text) ident(start)operator(\))operator(\))operator(\))
            operator(()keyword(set!) ident(result) operator(()keyword(cons) operator(()keyword(or) operator(()ident(match:substring) ident(m) integer(1)operator(\))
                                   operator(()ident(match:substring) ident(m) integer(3)operator(\))operator(\))
                               ident(result)operator(\))operator(\))
            operator(()ident(loop) operator(()ident(match:end) ident(m)operator(\))operator(\))operator(\))operator(\))
        operator(()ident(reverse) ident(result)operator(\))operator(\))operator(\))operator(\))operator(\))

operator(()keyword(define) ident(line) string<delimiter(")content(XYZZY,)content(\\")content(\\")content(,)content(\\")content(O'Reilly, Inc)content(\\")content(,)content(\\")content(Wall, Larry)content(\\")content(,)content(\\")content(a )content(\\\\)content(\\")content(glug)content(\\\\)content(\\")content( bit,)content(\\")content(,5,)content(\\")content(Error, Core Dumped)content(\\")delimiter(")>operator(\))

operator(()keyword(do) operator(()operator(()ident(i) integer(0) operator(()integer(1)ident(+) ident(i)operator(\))operator(\))
     operator(()ident(fields) operator(()ident(parse-csv) ident(line)operator(\)) operator(()ident(cdr) ident(fields)operator(\))operator(\))operator(\))
    operator(()operator(()ident(null?) ident(fields)operator(\))operator(\))
  operator(()ident(format) predefined_constant(#t) string<delimiter(")content(~D : ~A)content(\\n)delimiter(")> ident(i) operator(()ident(car) ident(fields)operator(\))operator(\))operator(\))

comment(;; @@PLEAC@@_1.16)
operator(()ident(use-modules) operator(()ident(srfi) ident(srfi-13)operator(\)) operator(()ident(srfi) ident(srfi-14)operator(\))operator(\))

comment(;; Knuth's soundex algorithm from The Art of Computer Programming, Vol 3)
operator(()keyword(define) ident(soundex)
  operator(()keyword(letrec) operator(()operator(()ident(chars) string<delimiter(")content(AEIOUYBFPVCGJKQSXZDTLMNR)delimiter(")>operator(\))
           operator(()ident(nums) string<delimiter(")content(000000111122222222334556)delimiter(")>operator(\))
           operator(()ident(skipchars) operator(()ident(string->char-set) string<delimiter(")content(HW)delimiter(")>operator(\))operator(\))
           operator(()ident(trans) operator(()keyword(lambda) operator(()ident(c)operator(\))
                    operator(()keyword(let) operator(()operator(()ident(i) operator(()ident(string-index) ident(chars) ident(c)operator(\))operator(\))operator(\))
                      operator(()keyword(if) ident(i) operator(()ident(string-ref) ident(nums) ident(i)operator(\)) ident(c)operator(\))operator(\))operator(\))operator(\))operator(\))
    operator(()keyword(lambda) operator(()ident(str)operator(\))
      operator(()keyword(let*) operator(()operator(()ident(ustr) operator(()ident(string-upcase) ident(str)operator(\))operator(\))
             operator(()ident(f) operator(()ident(string-ref) ident(ustr) integer(0)operator(\))operator(\))
             operator(()ident(skip) operator(()ident(trans) ident(f)operator(\))operator(\))operator(\))
        operator(()keyword(let*) operator(()operator(()ident(mstr) operator(()ident(string-map) ident(trans) operator(()ident(string-delete) ident(ustr) ident(skipchars) integer(1)operator(\))operator(\))operator(\))
               operator(()ident(dstr) operator(()ident(string-map) operator(()keyword(lambda) operator(()ident(c)operator(\))
                                   operator(()keyword(cond) operator(()operator(()ident(eq?) ident(c) ident(skip)operator(\)) char(#\\0)operator(\))
                                         operator(()ident(else) operator(()keyword(set!) ident(skip) ident(c)operator(\)) ident(c)operator(\))operator(\))operator(\))
                                 ident(mstr)operator(\))operator(\))
               operator(()ident(zstr) operator(()ident(string-delete) ident(dstr) char(#\\0)operator(\))operator(\))operator(\))
          operator(()ident(substring) operator(()ident(string-append) operator(()ident(make-string) integer(1) ident(f)operator(\)) ident(zstr) string<delimiter(")content(000)delimiter(")>operator(\)) integer(0) integer(4)operator(\))operator(\))operator(\))operator(\))operator(\))operator(\))

operator(()ident(soundex) string<delimiter(")content(Knuth)delimiter(")>operator(\))  comment(; K530)
operator(()ident(soundex) string<delimiter(")content(Kant)delimiter(")>operator(\))   comment(; K530)
operator(()ident(soundex) string<delimiter(")content(Lloyd)delimiter(")>operator(\))  comment(; L300)
operator(()ident(soundex) string<delimiter(")content(Ladd)delimiter(")>operator(\))   comment(; L300)

comment(;; @@PLEAC@@_1.17)
error(#)ident(!/usr/local/bin/guile) ident(-)ident(s)
ident(!)error(#)

operator(()ident(use-modules) operator(()ident(srfi) ident(srfi-13)operator(\))
             operator(()ident(srfi) ident(srfi-14)operator(\))
             operator(()ident(ice-9) ident(rw)operator(\))
             operator(()ident(ice-9) ident(regex)operator(\))operator(\))

operator(()keyword(define) ident(data) string<delimiter(")content(analysed        => analyzed
built-in        => builtin
chastized       => chastised
commandline     => command-line
de-allocate     => deallocate
dropin          => drop-in
hardcode        => hard-code
meta-data       => metadata
multicharacter  => multi-character
multiway        => multi-way
non-empty       => nonempty
non-profit      => nonprofit
non-trappable   => nontrappable
pre-define      => predefine
preextend       => pre-extend
re-compiling    => recompiling
reenter         => re-enter
turnkey         => turn-key)delimiter(")>operator(\))

operator(()keyword(define) ident(input) operator(()keyword(if) operator(()ident(null?) operator(()ident(cdr) operator(()ident(command-line)operator(\))operator(\))operator(\))
                operator(()ident(current-input-port)operator(\))
                operator(()ident(open-input-file) operator(()ident(cadr) operator(()ident(command-line)operator(\))operator(\))operator(\))operator(\))operator(\))

operator(()keyword(let*) operator(()operator(()ident(newline-char-set) operator(()ident(string->char-set) string<delimiter(")content(\\n)delimiter(")>operator(\))operator(\))
       operator(()ident(assoc-char-set) operator(()ident(string->char-set) string<delimiter(")content( =>)delimiter(")>operator(\))operator(\))
       operator(()ident(dict) operator(()ident(map)
              operator(()keyword(lambda) operator(()ident(line)operator(\))
                operator(()ident(string-tokenize) ident(line) ident(assoc-char-set)operator(\))operator(\))
              operator(()ident(string-tokenize) ident(data) ident(newline-char-set)operator(\))operator(\))operator(\))
       operator(()ident(dict-match) operator(()ident(string-join) operator(()ident(map) ident(car) ident(dict)operator(\)) string<delimiter(")content(|)delimiter(")>operator(\))operator(\))operator(\))
  operator(()keyword(let) ident(loop) operator(()operator(()ident(line) operator(()ident(read-line) ident(input)operator(\))operator(\))operator(\))
    operator(()keyword(cond) operator(()operator(()ident(not) operator(()ident(eof-object?) ident(line)operator(\))operator(\))
           operator(()ident(regexp-substitute/global)
            operator(()ident(current-output-port)operator(\)) ident(dict-match) ident(line)
            operator(')ident(pre)
            operator(()keyword(lambda) operator(()ident(x)operator(\))
              operator(()ident(cadr) operator(()ident(assoc) operator(()ident(match:substring) ident(x) integer(0)operator(\)) ident(dict)operator(\))operator(\))operator(\))
            operator(')ident(post)operator(\))
           operator(()ident(loop) operator(()ident(read-line) ident(input) operator(')ident(concat)operator(\))operator(\))operator(\))operator(\))operator(\))operator(\))

operator(()ident(close-port) ident(input)operator(\))

comment(;; @@PLEAC@@_2.1)
comment(;; Strings and numbers are separate data types in Scheme, so this)
comment(;; isn't as important as it is in Perl.  More often you would use the)
comment(;; type predicates, string? and number?.)

operator(()keyword(if) operator(()ident(string-match) string<delimiter(")content([^)content(\\\\)content(d])delimiter(")> ident(str)operator(\)) operator(()ident(display) string<delimiter(")content(has nondigits)delimiter(")>operator(\))operator(\))
operator(()keyword(or) operator(()ident(string-match) string<delimiter(")content(^)content(\\\\)content(d+$)delimiter(")> ident(str)operator(\)) operator(()ident(display) string<delimiter(")content(not a natural number)delimiter(")>operator(\))operator(\))
operator(()keyword(or) operator(()ident(string-match) string<delimiter(")content(^-?)content(\\\\)content(d+$)delimiter(")> ident(str)operator(\)) operator(()ident(display) string<delimiter(")content(not an integer)delimiter(")>operator(\))operator(\))
operator(()keyword(or) operator(()ident(string-match) string<delimiter(")content(^[)content(\\\\)content(-+]?)content(\\\\)content(d+$)delimiter(")> ident(str)operator(\)) operator(()ident(display) string<delimiter(")content(not an integer)delimiter(")>operator(\))operator(\))
operator(()keyword(or) operator(()ident(string-match) string<delimiter(")content(^-?)content(\\\\)content(d+)content(\\.)content(?)content(\\d)content(*$)delimiter(")> ident(str)operator(\)) operator(()ident(display) string<delimiter(")content(not a decimal number)delimiter(")>operator(\))operator(\))
operator(()keyword(or) operator(()ident(string-match) string<delimiter(")content(^-?()content(\\d)content(+()content(\\.)content(\\d)content(*\)?|)content(\\.)content(\\d)content(+\)$)delimiter(")> ident(str)operator(\))
    operator(()ident(display) string<delimiter(")content(not a decimal number)delimiter(")>operator(\))operator(\))
operator(()keyword(or) operator(()ident(string-match) string<delimiter(")content(^([+-]?\)()content(\\d)content(|)content(\\.)content(\\d)content(\))content(\\d)content(*()content(\\.)content(\\d)content(*\)?([Ee]([+-]?)content(\\d)content(+\)\)?$)delimiter(")> ident(str)operator(\))
    operator(()ident(display) string<delimiter(")content(not a C float)delimiter(")>operator(\))operator(\))

operator(()keyword(define) ident(num1) operator(()ident(string->number) ident(str)operator(\))operator(\))

operator(()keyword(define) ident(num2) operator(()ident(read)operator(\))operator(\))

comment(;; @@PLEAC@@_2.2)
comment(;; (approx-equal? num1 num2 accuracy\) : returns #t if num1 and num2 are)
comment(;;   equal to accuracy number of decimal places)
operator(()keyword(define) operator(()ident(approx-equal?) ident(num1) ident(num2) ident(accuracy)operator(\))
  operator(()ident(<) operator(()ident(abs) operator(()ident(-) ident(num1) ident(num2)operator(\))operator(\)) operator(()ident(expt) integer(10.0) operator(()ident(-) ident(accuracy)operator(\))operator(\))operator(\))operator(\))

operator(()keyword(define) ident(wage) integer(536)operator(\))                     comment(;; $5.36/hour)
operator(()keyword(define) ident(week) operator(()ident(*) integer(40) ident(wage)operator(\))operator(\))             comment(;; $214.40)
operator(()ident(format) predefined_constant(#t) string<delimiter(")content(One week's wage is: $~$)content(\\n)delimiter(")> operator(()ident(/) ident(week) integer(100.0)operator(\))operator(\))

comment(;; @@PLEAC@@_2.3)
operator(()ident(round) ident(num)operator(\))                           comment(;; rounds to inexact whole number)
operator(()ident(inexact->exact) ident(num)operator(\))                  comment(;; rounds to exact integer)

comment(;; You can also use format to convert numbers to more precisely)
comment(;; formatted strings.  Note Guile has a builtin format which is a more)
comment(;; limited version of that found in the (ice-9 format\) module, to save)
comment(;; load time.  Basically, if you are doing anything you couldn't do)
comment(;; with a series of (display\), (write\) and (newline\), then you'll need)
comment(;; to use the module.)
operator(()ident(use-modules) operator(()ident(ice-9) ident(format)operator(\))operator(\))

operator(()keyword(define) ident(a) integer(0.255)operator(\))
operator(()keyword(define) ident(b) operator(()ident(/) operator(()ident(round) operator(()ident(*) integer(100.0) ident(a)operator(\))operator(\)) integer(100.0)operator(\))operator(\))
operator(()ident(format) predefined_constant(#t) string<delimiter(")content(Unrounded: ~F)content(\\n)content(Rounded: ~F)content(\\n)delimiter(")> ident(a) ident(b)operator(\))
operator(()ident(format) predefined_constant(#t) string<delimiter(")content(Unrounded: ~F)content(\\n)content(Rounded: ~,2F)content(\\n)delimiter(")> ident(a) ident(a)operator(\))

operator(()keyword(define) ident(a) operator(')operator(()integer(3.3) integer(3.5) integer(3.7) ident(-)integer(3.3)operator(\))operator(\))
operator(()ident(display) string<delimiter(")content(number)content(\\t)content(int)content(\\t)content(floor)content(\\t)content(ceil)content(\\n)delimiter(")>operator(\))
operator(()ident(for-each)
 operator(()keyword(lambda) operator(()ident(n)operator(\))
   operator(()ident(format) predefined_constant(#t) string<delimiter(")content(~,1F)content(\\t)content(~,1F)content(\\t)content(~,1F)content(\\t)content(~,1F)content(\\n)delimiter(")>
           ident(n) operator(()ident(round) ident(n)operator(\)) operator(()ident(floor) ident(n)operator(\)) operator(()ident(ceiling) ident(n)operator(\))operator(\))operator(\))
 ident(a)operator(\))

comment(;; @@PLEAC@@_2.4)
comment(;; numbers are radix independent internally, so you usually only)
comment(;; convert on output, however to convert strings:)
operator(()keyword(define) operator(()ident(dec->bin) ident(num)operator(\))
  operator(()ident(number->string) operator(()ident(string->number) ident(num) integer(10)operator(\)) integer(2)operator(\))operator(\))

operator(()keyword(define) operator(()ident(bin->dec) ident(num)operator(\))
  operator(()ident(number->string) operator(()ident(string->number) ident(num) integer(2)operator(\)) integer(10)operator(\))operator(\))

operator(()keyword(define) ident(num) operator(()ident(bin->dec) string<delimiter(")content(0110110)delimiter(")>operator(\))operator(\))  comment(; 54)
operator(()keyword(define) ident(binstr) operator(()ident(dec->bin) string<delimiter(")content(54)delimiter(")>operator(\))operator(\))    comment(; 110110)

comment(;; @@PLEAC@@_2.5)
comment(;; do is the most general loop iterator)
operator(()keyword(do) operator(()operator(()ident(i) ident(x) operator(()integer(1)ident(+) ident(i)operator(\))operator(\))operator(\))   comment(; var  init-value  step-value)
    operator(()operator(()ident(>) ident(i) ident(y)operator(\))operator(\))        comment(; end when true)
  comment(;; i is set to every integer from x to y, inclusive)
  comment(;; ...)
  operator(\))

comment(;; Guile also offers a while loop)
operator(()keyword(let) operator(()operator(()ident(i) ident(x)operator(\))operator(\))
  operator(()ident(while) operator(()ident(<=) ident(i) ident(y)operator(\))
         comment(;; i is set to every integer from x to y, inclusive)
         comment(; ...)
         operator(()keyword(set!) ident(i) operator(()integer(1)ident(+) ident(i)operator(\))operator(\))operator(\))operator(\))

comment(;; named let is another common loop)
operator(()keyword(let) ident(loop) operator(()operator(()ident(i) ident(x)operator(\))operator(\))
  operator(()keyword(cond) operator(()operator(()ident(<=) ident(i) ident(y)operator(\))
         comment(;; i is set to every integer from x to y, step-size 7)
         comment(;; ...)
         operator(()ident(loop) operator(()ident(+) ident(i) integer(7)operator(\))operator(\))operator(\))operator(\))operator(\))  comment(; tail-recursive call)

operator(()ident(display) string<delimiter(")content(Infancy is: )delimiter(")>operator(\))
operator(()keyword(do) operator(()operator(()ident(i) integer(0) operator(()integer(1)ident(+) ident(i)operator(\))operator(\))operator(\))
    operator(()operator(()ident(>) ident(i) integer(2)operator(\))operator(\))
  operator(()ident(format) predefined_constant(#t) string<delimiter(")content(~A )delimiter(")> ident(i)operator(\))operator(\))
operator(()ident(newline)operator(\))

operator(()ident(display) string<delimiter(")content(Toddling is: )delimiter(")>operator(\))
operator(()keyword(let) operator(()operator(()ident(i) integer(3)operator(\))operator(\))
  operator(()ident(while) operator(()ident(<=) ident(i) integer(4)operator(\))
         operator(()ident(format) predefined_constant(#t) string<delimiter(")content(~A )delimiter(")> ident(i)operator(\))
         operator(()keyword(set!) ident(i) operator(()integer(1)ident(+) ident(i)operator(\))operator(\))operator(\))operator(\))
operator(()ident(newline)operator(\))

operator(()ident(display) string<delimiter(")content(Childhood is: )delimiter(")>operator(\))
operator(()keyword(let) ident(loop) operator(()operator(()ident(i) integer(5)operator(\))operator(\))
  operator(()keyword(cond) operator(()operator(()ident(<=) ident(i) integer(12)operator(\))
         operator(()ident(format) predefined_constant(#t) string<delimiter(")content(~A )delimiter(")> ident(i)operator(\))
         operator(()ident(loop) operator(()integer(1)ident(+) ident(i)operator(\))operator(\))operator(\))operator(\))operator(\))
operator(()ident(newline)operator(\))

comment(;; @@PLEAC@@_2.6)
comment(;; format can output roman numerals - use ~:@R)

operator(()ident(use-modules) operator(()ident(ice-9) ident(format)operator(\))operator(\))

operator(()ident(format) predefined_constant(#t) string<delimiter(")content(Roman for ~R is ~:@R)content(\\n)delimiter(")> integer(15) integer(15)operator(\))

comment(;; @@PLEAC@@_2.7)
operator(()ident(random) integer(5)operator(\))        comment(; an integer from 0 to 4)
operator(()ident(random) integer(5.0)operator(\))      comment(; an inexact real in the range [0,5\))

comment(;; char sets from SRFI-14 and string-unfold from SRFI-13 make a quick)
comment(;; way to generate passwords)

operator(()ident(use-modules) operator(()ident(srfi) ident(srfi-13)operator(\)) operator(()ident(srfi) ident(srfi-14)operator(\))operator(\))

operator(()keyword(define) ident(chars) operator(()ident(char-set->string) ident(char-set:graphic)operator(\))operator(\))
operator(()keyword(define) ident(size) operator(()ident(char-set-size) ident(char-set:graphic)operator(\))operator(\))
operator(()keyword(define) ident(password)
  operator(()ident(string-unfold) operator(()keyword(lambda) operator(()ident(x)operator(\)) operator(()ident(=) ident(x) integer(8)operator(\))operator(\))
                 operator(()keyword(lambda) operator(()ident(x)operator(\)) operator(()ident(string-ref) ident(chars) operator(()ident(random) ident(size)operator(\))operator(\))operator(\))
                 integer(1)ident(+) integer(0)operator(\))operator(\))

comment(;; @@PLEAC@@_2.8)
comment(;; if you're working with random numbers you'll probably want to set)
comment(;; the random seed)

operator(()ident(seed->random-state) operator(()ident(current-time)operator(\))operator(\))

comment(;; you can also save random states and pass them to any of the above)
comment(;; random functions)

operator(()keyword(define) ident(state) operator(()ident(copy-random-state)operator(\))operator(\))
operator(()ident(random:uniform)operator(\))
comment(;; 0.939377327721761)
operator(()ident(random:uniform) ident(state)operator(\))
comment(;; 0.939377327721761)

comment(;; @@PLEAC@@_2.9)
comment(;; @@INCOMPLETE@@)
comment(;; very inefficient)
operator(()ident(use-modules) operator(()ident(ice-9) ident(rw)operator(\))operator(\))
operator(()keyword(define) ident(make-true-random)
  operator(()keyword(letrec) operator(()operator(()ident(bufsize) integer(8)operator(\))
           operator(()ident(accum) operator(()keyword(lambda) operator(()ident(c) ident(acc)operator(\)) operator(()ident(+) operator(()ident(*) integer(256) ident(acc)operator(\))
                                     operator(()ident(char->integer) ident(c)operator(\))operator(\))operator(\))operator(\))
           operator(()ident(getbuf) operator(()keyword(lambda) operator(()operator(\))
                     operator(()ident(call-with-input-file) string<delimiter(")content(/dev/urandom)delimiter(")>
                       operator(()keyword(lambda) operator(()ident(p)operator(\))
                         operator(()keyword(let) operator(()operator(()ident(buf) operator(()ident(make-string) ident(bufsize)operator(\))operator(\))operator(\))
                           operator(()ident(read-string!/partial) ident(buf) ident(p)operator(\))
                           ident(buf)operator(\))operator(\))operator(\))operator(\))operator(\))operator(\))
    operator(()keyword(lambda) operator(()ident(rand-proc)operator(\))
      operator(()keyword(lambda) ident(args)
        operator(()keyword(let) operator(()operator(()ident(state) operator(()ident(seed->random-state) operator(()ident(string-fold) ident(accum) integer(0) operator(()ident(getbuf)operator(\))operator(\))operator(\))operator(\))operator(\))
          operator(()ident(apply) ident(rand-proc) operator(()ident(append) ident(args) operator(()ident(list) ident(state)operator(\))operator(\))operator(\))operator(\))operator(\))operator(\))operator(\))operator(\))

operator(()keyword(define) ident(urandom) operator(()ident(make-true-random) ident(random)operator(\))operator(\))
operator(()keyword(define) ident(urandom:exp) operator(()ident(make-true-random) ident(random:exp)operator(\))operator(\))
operator(()keyword(define) ident(urandom:normal) operator(()ident(make-true-random) ident(random:normal)operator(\))operator(\))
operator(()keyword(define) ident(urandom:uniform) operator(()ident(make-true-random) ident(random:uniform)operator(\))operator(\))

comment(;; @@PLEAC@@_2.10)
comment(;; Guile offers a number of random distributions)

operator(()ident(random:exp)operator(\))      comment(; an inexact real in an exponential dist with mean 1)
operator(()ident(random:normal)operator(\))   comment(; an inexact real in a standard normal distribution)
operator(()ident(random:uniform)operator(\))  comment(; a uniformly distributed inexact real in [0,1\))

comment(;; There are also functions to fill vectors with random distributions)

comment(;; Fills vector v with inexact real random numbers the sum of whose)
comment(;; squares is equal to 1.0.)
operator(()ident(random:hollow-sphere!) ident(v)operator(\))

comment(;; Fills vector v with inexact real random numbers that are)
comment(;; independent and standard normally distributed (i.e., with mean 0)
comment(;; and variance 1\).)
operator(()ident(random:normal-vector!) ident(v)operator(\))

comment(;; Fills vector v with inexact real random numbers the sum of whose)
comment(;; squares is less than 1.0.)
operator(()ident(random:solid-sphere!) ident(v)operator(\))

comment(;; @@PLEAC@@_2.11)
comment(;; Guile's trigonometric functions use radians.)

operator(()keyword(define) ident(pi) integer(3.14159265358979)operator(\))

operator(()keyword(define) operator(()ident(degrees->radians) ident(deg)operator(\))
  operator(()ident(*) ident(pi) operator(()ident(/) ident(deg) integer(180.0)operator(\))operator(\))operator(\))

operator(()keyword(define) operator(()ident(radians->degrees) ident(rad)operator(\))
  operator(()ident(*) integer(180.0) operator(()ident(/) ident(rad) ident(pi)operator(\))operator(\))operator(\))

operator(()keyword(define) operator(()ident(degree-sine) ident(deg)operator(\))
  operator(()ident(sin) operator(()ident(degrees->radians) ident(deg)operator(\))operator(\))operator(\))

comment(;; @@PLEAC@@_2.12)

comment(;; Guile provides the following standard trigonometric functions (and)
comment(;; their hyperbolic equivalents\), defined for all real and complex)
comment(;; numbers:)

operator(()ident(sin) ident(z)operator(\))
operator(()ident(cos) ident(z)operator(\))
operator(()ident(tan) ident(z)operator(\))
operator(()ident(asin) ident(z)operator(\))
operator(()ident(acos) ident(z)operator(\))
operator(()ident(atan) ident(z)operator(\))

operator(()ident(acos) integer(3.7)operator(\))  comment(; 0.0+1.9826969446812i)

comment(;; @@PLEAC@@_2.13)
comment(;; Guile provides log in base e and 10 natively, defined for any real)
comment(;; or complex numbers:)

operator(()ident(log) ident(z)operator(\))    comment(; natural logarithm)
operator(()ident(log10) ident(z)operator(\))  comment(; base-10 logarithm)

comment(;; For other bases, divide by the log of the base:)

operator(()keyword(define) operator(()ident(log-base) ident(n) ident(z)operator(\))
  operator(()ident(/) operator(()ident(log) ident(z)operator(\)) operator(()ident(log) ident(n)operator(\))operator(\))operator(\))

comment(;; To avoid re-computing (log n\) for a base you want to use)
comment(;; frequently, you can create a custom log function:)

operator(()keyword(define) operator(()ident(make-log-base) ident(n)operator(\))
  operator(()keyword(let) operator(()operator(()ident(divisor) operator(()ident(log) ident(n)operator(\))operator(\))operator(\))
    operator(()keyword(lambda) operator(()ident(z)operator(\)) operator(()ident(/) operator(()ident(log) ident(z)operator(\)) ident(divisor)operator(\))operator(\))operator(\))operator(\))

operator(()keyword(define) ident(log2) operator(()ident(make-log-base) integer(2)operator(\))operator(\))

operator(()ident(log2) integer(1024)operator(\))

comment(;; @@PLEAC@@_2.14)
comment(;; In addition to simple vectors, Guile has builtin support for)
comment(;; uniform arrays of an arbitrary dimension.)

comment(;; a rows x cols integer matrix)
operator(()keyword(define) ident(a) operator(()ident(make-array) integer(0) ident(rows) ident(cols)operator(\))operator(\))
operator(()ident(array-set!) ident(a) integer(3) ident(row) ident(col)operator(\))
operator(()ident(array-ref) ident(a) ident(row) ident(col)operator(\))

comment(;; a 3D matrix of reals)
operator(()keyword(define) ident(b) operator(()ident(make-array) integer(0.0) ident(x) ident(y) ident(z)operator(\))operator(\))

comment(;; a literal boolean truth table for logical and)
operator(')error(#)integer(2)operator(()operator(()predefined_constant(#f) predefined_constant(#f)operator(\)) operator(()predefined_constant(#f) predefined_constant(#t)operator(\))operator(\))

comment(;; simple matrix multiplication)

operator(()keyword(define) operator(()ident(matrix-mult) ident(m1) ident(m2)operator(\))
  operator(()keyword(let*) operator(()operator(()ident(d1) operator(()ident(array-dimensions) ident(m1)operator(\))operator(\))
         operator(()ident(d2) operator(()ident(array-dimensions) ident(m2)operator(\))operator(\))
         operator(()ident(m1rows) operator(()ident(car) ident(d1)operator(\))operator(\))
         operator(()ident(m1cols) operator(()ident(cadr) ident(d1)operator(\))operator(\))
         operator(()ident(m2rows) operator(()ident(car) ident(d2)operator(\))operator(\))
         operator(()ident(m2cols) operator(()ident(cadr) ident(d2)operator(\))operator(\))operator(\))
    operator(()keyword(if) operator(()ident(not) operator(()ident(=) ident(m1cols) ident(m2rows)operator(\))operator(\))
      operator(()ident(error) operator(')ident(index-error) string<delimiter(")content(matrices don't match)delimiter(")>operator(\))operator(\))
    operator(()keyword(let) operator(()operator(()ident(result) operator(()ident(make-array) integer(0) ident(m1rows) ident(m2cols)operator(\))operator(\))operator(\))
      operator(()keyword(do) operator(()operator(()ident(i) integer(0) operator(()integer(1)ident(+) ident(i)operator(\))operator(\))operator(\))
          operator(()operator(()ident(=) ident(i) ident(m1rows)operator(\))operator(\))
        operator(()keyword(do) operator(()operator(()ident(j) integer(0) operator(()integer(1)ident(+) ident(j)operator(\))operator(\))operator(\))
            operator(()operator(()ident(=) ident(j) ident(m2cols)operator(\))operator(\))
          operator(()keyword(do) operator(()operator(()ident(k) integer(0) operator(()integer(1)ident(+) ident(k)operator(\))operator(\))operator(\))
              operator(()operator(()ident(=) ident(k) ident(m1cols)operator(\))operator(\))
            operator(()ident(array-set!) ident(result) operator(()ident(+) operator(()ident(array-ref) ident(result) ident(i) ident(j)operator(\))
                                  operator(()ident(*) operator(()ident(array-ref) ident(m1) ident(i) ident(k)operator(\))
                                     operator(()ident(array-ref) ident(m2) ident(k) ident(j)operator(\))operator(\))operator(\))
                        ident(i) ident(j)operator(\))operator(\))operator(\))operator(\))
      ident(result)operator(\))operator(\))operator(\))

operator(()ident(matrix-mult) operator(')error(#)integer(2)operator(()operator(()integer(3) integer(2) integer(3)operator(\)) operator(()integer(5) integer(9) integer(8)operator(\))operator(\)) operator(')error(#)integer(2)operator(()operator(()integer(4) integer(7)operator(\)) operator(()integer(9) integer(3)operator(\)) operator(()integer(8) integer(1)operator(\))operator(\))operator(\))

comment(;; @@PLEAC@@_2.15)
comment(;; Guile has builtin support for complex numbers:)

operator(()keyword(define) ident(i) integer(0+1i)operator(\))       comment(; 0.0+1.0i)
operator(()keyword(define) ident(i) operator(()ident(sqrt) ident(-)integer(1)operator(\))operator(\))  comment(; 0.0+1.0i)

operator(()ident(complex?) ident(i)operator(\))          comment(; #t)
operator(()ident(real-part) ident(i)operator(\))         comment(; 0.0)
operator(()ident(imag-part) ident(i)operator(\))         comment(; 1.0)

operator(()ident(*) integer(3+5i) integer(2-2i)operator(\))         comment(; 16+4i)
operator(()ident(sqrt) integer(3+4i)operator(\))           comment(; 2+i)

comment(;; Classic identity:  -e^(pi*i\) => 1)
operator(()ident(inexact->exact) operator(()ident(real-part) operator(()ident(-) operator(()ident(exp) operator(()ident(*) ident(pi) integer(0+1i)operator(\))operator(\))operator(\))operator(\))operator(\)) comment(; 1)

comment(;; @@PLEAC@@_2.16)
comment(;; You can type in literal numbers in alternate radixes:)

integer(#b01101101)     comment(; 109 in binary)
integer(#o155)          comment(; 109 in octal)
integer(#d109)          comment(; 109 in decimal)
integer(#x6d)           comment(; 109 in hexadecimal)

comment(;; number->string and string->number also take an optional radix:)

operator(()keyword(define) ident(number) operator(()ident(string->number) ident(hexadecimal) integer(16)operator(\))operator(\))
operator(()keyword(define) ident(number) operator(()ident(string->number) ident(octal) integer(8)operator(\))operator(\))

comment(;; format will also output in different radixes:)

operator(()ident(format) predefined_constant(#t) string<delimiter(")content(~B ~O ~D ~X)content(\\n)delimiter(")> ident(num) ident(num) ident(num) ident(num)operator(\))

comment(;; converting Unix file permissions read from stdin:)

operator(()keyword(let) ident(loop) operator(()operator(()ident(perm) operator(()ident(read-line)operator(\))operator(\))operator(\))
  operator(()keyword(cond) operator(()operator(()ident(not) operator(()ident(eof-object?) ident(perm)operator(\))operator(\))
         operator(()ident(format) predefined_constant(#t) string<delimiter(")content(The decimal value is ~D)content(\\n)delimiter(")> operator(()ident(string->number) ident(perm) integer(8)operator(\))operator(\))
         operator(()ident(loop) operator(()ident(read-line)operator(\))operator(\))operator(\))operator(\))operator(\))

comment(;; @@PLEAC@@_2.17)
comment(;; once again, format is our friend :\))
operator(()ident(use-modules) operator(()ident(ice-9) ident(format)operator(\))operator(\))

comment(;; the : prefix to the D directive causes commas to be output every)
comment(;; three digits.)
operator(()ident(format) predefined_constant(#t) string<delimiter(")content(~:D)content(\\n)delimiter(")> operator(()ident(random) integer(10000000000000000)operator(\))operator(\))
comment(; => 2,301,267,079,619,540)

comment(;; the third prefix arg to the D directive is the separator character)
comment(;; to use instead of a comma, useful for European style numbers:)
operator(()ident(format) predefined_constant(#t) string<delimiter(")content(~,,'.:D)content(\\n)delimiter(")> operator(()ident(random) integer(10000000000000000)operator(\))operator(\))
comment(; => 6.486.470.447.356.534)

comment(;; the F directive, however, does not support grouping by commas.  to)
comment(;; achieve this, we can format the integer and fractional parts)
comment(;; separately:)
operator(()keyword(define) operator(()ident(commify) ident(num)operator(\))
  operator(()keyword(let) operator(()operator(()ident(int) operator(()ident(inexact->exact) operator(()ident(truncate) ident(num)operator(\))operator(\))operator(\))operator(\))
    operator(()keyword(if) operator(()ident(=) ident(num) ident(int)operator(\))
      operator(()ident(format) predefined_constant(#f) string<delimiter(")content(~:D)delimiter(")> ident(int)operator(\))
      operator(()ident(string-append) operator(()ident(format) predefined_constant(#f) string<delimiter(")content(~:D)delimiter(")> ident(int)operator(\))
                     operator(()keyword(let) operator(()operator(()ident(str) operator(()ident(format) predefined_constant(#f) string<delimiter(")content(~F)delimiter(")> ident(num)operator(\))operator(\))operator(\))
                       operator(()ident(substring) ident(str) operator(()keyword(or) operator(()ident(string-index) ident(str) char(#\\.)operator(\))
                                          operator(()ident(string-length) ident(str)operator(\))operator(\))operator(\))operator(\))operator(\))operator(\))operator(\))operator(\))

comment(;; @@PLEAC@@_2.18)
comment(;; format can handle simple 's' plurals with ~p, and 'y/ies' plurals)
comment(;; with the @ prefix:)

operator(()ident(format) predefined_constant(#t) string<delimiter(")content(It took ~D hour~P)content(\\n)delimiter(")> ident(hours) ident(hours)operator(\))

operator(()ident(format) predefined_constant(#t) string<delimiter(")content(It took ~D centur~@P)content(\\n)delimiter(")> ident(centuries) ident(centuries)operator(\))

operator(()keyword(define) ident(noun-plural)
  operator(()keyword(let*) operator(()operator(()ident(suffixes) operator(')operator(()operator(()string<delimiter(")content(ss)delimiter(")>  operator(.) string<delimiter(")content(sses)delimiter(")>operator(\))
                     operator(()string<delimiter(")content(ph)delimiter(")>  operator(.) string<delimiter(")content(phes)delimiter(")>operator(\))
                     operator(()string<delimiter(")content(sh)delimiter(")>  operator(.) string<delimiter(")content(shes)delimiter(")>operator(\))
                     operator(()string<delimiter(")content(ch)delimiter(")>  operator(.) string<delimiter(")content(ches)delimiter(")>operator(\))
                     operator(()string<delimiter(")content(z)delimiter(")>   operator(.) string<delimiter(")content(zes)delimiter(")>operator(\))
                     operator(()string<delimiter(")content(ff)delimiter(")>  operator(.) string<delimiter(")content(ffs)delimiter(")>operator(\))
                     operator(()string<delimiter(")content(f)delimiter(")>   operator(.) string<delimiter(")content(ves)delimiter(")>operator(\))
                     operator(()string<delimiter(")content(ey)delimiter(")>  operator(.) string<delimiter(")content(eys)delimiter(")>operator(\))
                     operator(()string<delimiter(")content(y)delimiter(")>   operator(.) string<delimiter(")content(ies)delimiter(")>operator(\))
                     operator(()string<delimiter(")content(ix)delimiter(")>  operator(.) string<delimiter(")content(ices)delimiter(")>operator(\))
                     operator(()string<delimiter(")content(s)delimiter(")>   operator(.) string<delimiter(")content(ses)delimiter(")>operator(\))
                     operator(()string<delimiter(")content(x)delimiter(")>   operator(.) string<delimiter(")content(xes)delimiter(")>operator(\))
                     operator(()string<delimiter(")content(ius)delimiter(")> operator(.) string<delimiter(")content(ii)delimiter(")>operator(\))operator(\))operator(\))
        operator(()ident(suffix-match)
         operator(()ident(string-append) string<delimiter(")content(()delimiter(")> operator(()ident(string-join) operator(()ident(map) ident(car) ident(suffixes)operator(\)) string<delimiter(")content(|)delimiter(")>operator(\)) string<delimiter(")content(\)$)delimiter(")>operator(\))operator(\))
        operator(()ident(suffix-rx) operator(()ident(make-regexp) ident(suffix-match)operator(\))operator(\))operator(\))
    operator(()keyword(lambda) operator(()ident(noun)operator(\))
      operator(()keyword(let) operator(()operator(()ident(m) operator(()ident(regexp-exec) ident(suffix-rx) ident(noun)operator(\))operator(\))operator(\))
        operator(()keyword(if) ident(m)
          operator(()ident(string-append) operator(()ident(regexp-substitute) predefined_constant(#f) ident(m) operator(')ident(pre)operator(\))
                         operator(()ident(cdr) operator(()ident(assoc) operator(()ident(match:substring) ident(m)operator(\)) ident(suffixes)operator(\))operator(\))operator(\))
          operator(()ident(string-append) ident(noun) string<delimiter(")content(s)delimiter(")>operator(\))operator(\))operator(\))operator(\))operator(\))operator(\))

comment(;; @@PLEAC@@_2.19)
error(#)ident(!/usr/local/bin/guile) ident(-)ident(s)
ident(!)error(#)

comment(;; very naive factoring algorithm)
operator(()keyword(define) operator(()ident(factor) ident(n)operator(\))
  operator(()keyword(let) operator(()operator(()ident(factors) operator(')operator(()operator(\))operator(\))
        operator(()ident(limit) operator(()ident(inexact->exact) operator(()ident(round) operator(()ident(sqrt) ident(n)operator(\))operator(\))operator(\))operator(\))
        operator(()ident(twos) integer(0)operator(\))operator(\))
    comment(;; factor out 2's)
    operator(()ident(while) operator(()ident(even?) ident(n)operator(\))
           operator(()keyword(set!) ident(n) operator(()ident(ash) ident(n) ident(-)integer(1)operator(\))operator(\))
           operator(()keyword(set!) ident(twos) operator(()integer(1)ident(+) ident(twos)operator(\))operator(\))operator(\))
    operator(()keyword(if) operator(()ident(>) ident(twos) integer(0)operator(\)) operator(()keyword(set!) ident(factors) operator(()ident(list) operator(()keyword(cons) integer(2) ident(twos)operator(\))operator(\))operator(\))operator(\))
    comment(;; factor out odd primes)
    operator(()keyword(let) ident(loop) operator(()operator(()ident(i) integer(3)operator(\))operator(\))
      operator(()keyword(let) operator(()operator(()ident(r) operator(()ident(remainder) ident(n) ident(i)operator(\))operator(\))operator(\))
        operator(()keyword(cond) operator(()operator(()ident(=) ident(r) integer(0)operator(\))
               operator(()keyword(set!) ident(n) operator(()ident(quotient) ident(n) ident(i)operator(\))operator(\))
               operator(()keyword(let*) operator(()operator(()ident(old-val) operator(()ident(assv) ident(i) ident(factors)operator(\))operator(\))
                      operator(()ident(new-val) operator(()keyword(if) ident(old-val) operator(()integer(1)ident(+) operator(()ident(cdr) ident(old-val)operator(\))operator(\)) integer(1)operator(\))operator(\))operator(\))
                 operator(()keyword(set!) ident(factors) operator(()ident(assv-set!) ident(factors) ident(i) ident(new-val)operator(\))operator(\))operator(\))
               operator(()ident(loop) ident(i)operator(\))operator(\))
              operator(()operator(()ident(<) ident(i) ident(limit)operator(\))
               operator(()ident(loop) operator(()ident(+) integer(2) ident(i)operator(\))operator(\))operator(\))operator(\))operator(\))operator(\))
    comment(;; remainder)
    operator(()keyword(if) operator(()ident(>) ident(n) integer(1)operator(\)) operator(()keyword(set!) ident(factors) operator(()keyword(cons) operator(()keyword(cons) ident(n) integer(1)operator(\)) ident(factors)operator(\))operator(\))operator(\))
    operator(()ident(reverse!) ident(factors)operator(\))operator(\))operator(\))

comment(;; pretty print a term of a factor)
operator(()keyword(define) operator(()ident(pp-term) ident(pair)operator(\))
  operator(()keyword(if) operator(()ident(=) operator(()ident(cdr) ident(pair)operator(\)) integer(1)operator(\))
    operator(()ident(number->string) operator(()ident(car) ident(pair)operator(\))operator(\))
    operator(()ident(format) predefined_constant(#f) string<delimiter(")content(~A^~A)delimiter(")> operator(()ident(car) ident(pair)operator(\)) operator(()ident(cdr) ident(pair)operator(\))operator(\))operator(\))operator(\))

comment(;; factor each number given on the command line)
operator(()ident(for-each)
 operator(()keyword(lambda) operator(()ident(n)operator(\))
   operator(()keyword(let) operator(()operator(()ident(factors) operator(()ident(factor) ident(n)operator(\))operator(\))operator(\))
     operator(()ident(format) predefined_constant(#t) string<delimiter(")content(~A = ~A)delimiter(")> ident(n) operator(()ident(pp-term) operator(()ident(car) ident(factors)operator(\))operator(\))operator(\))
     operator(()ident(for-each)
      operator(()keyword(lambda) operator(()ident(x)operator(\)) operator(()ident(format) predefined_constant(#t) string<delimiter(")content( * ~A)delimiter(")> operator(()ident(pp-term) ident(x)operator(\))operator(\))operator(\))
      operator(()ident(cdr) ident(factors)operator(\))operator(\))
     operator(()ident(newline)operator(\))operator(\))operator(\))
 operator(()ident(map) ident(string->number) operator(()ident(cdr) operator(()ident(command-line)operator(\))operator(\))operator(\))operator(\))

comment(;; @@PLEAC@@_3.0)
comment(;; Use the builtin POSIX time functions)

comment(;; get the current time)
operator(()ident(current-time)operator(\))   comment(; number of seconds since the epoch)
operator(()ident(gettimeofday)operator(\))   comment(; pair of seconds and microseconds since the epoch)

comment(;; create a time object from an integer (e.g. returned by current-time\))
operator(()ident(localtime) ident(time)operator(\)) comment(; in localtime)
operator(()ident(gmtime) ident(time)operator(\))    comment(; in UTC)

comment(;; get/set broken down components of a time object)

operator(()ident(tm:sec) ident(time)operator(\))    operator(()ident(set-tm:sec) ident(time) ident(secs)operator(\))    comment(; seconds (0-59\))
operator(()ident(tm:min) ident(time)operator(\))    operator(()ident(set-tm:min) ident(time) ident(mins)operator(\))    comment(; minutes (0-59\))
operator(()ident(tm:hour) ident(time)operator(\))   operator(()ident(set-tm:hour) ident(time) ident(hours)operator(\))  comment(; hours (0-23\))
operator(()ident(tm:mday) ident(time)operator(\))   operator(()ident(set-tm:mday) ident(time) ident(mday)operator(\))   comment(; day of the month (1-31\))
operator(()ident(tm:mon) ident(time)operator(\))    operator(()ident(set-tm:mon) ident(time) ident(month)operator(\))   comment(; month (0-11\))
operator(()ident(tm:year) ident(time)operator(\))   operator(()ident(set-tm:year) ident(time) ident(year)operator(\))   comment(; year minus 1900 (70-\))
operator(()ident(tm:wday) ident(time)operator(\))   operator(()ident(set-tm:wday) ident(time) ident(wday)operator(\))   comment(; day of the week (0-6\))
                                           comment(; where Sunday is 0)
operator(()ident(tm:yday) ident(time)operator(\))   operator(()ident(set-tm:yday) ident(time) ident(yday)operator(\))   comment(; day of year (0-365\))
operator(()ident(tm:isdst) ident(time)operator(\))  operator(()ident(set-tm:isdst) ident(time) ident(isdst)operator(\)) comment(; daylight saving indicator)
                                           comment(; 0 for "no", > 0 for "yes",)
                                           comment(; < 0 for "unknown")
operator(()ident(tm:gmtoff) ident(time)operator(\)) operator(()ident(set-tm:gmtoff) ident(time) ident(off)operator(\))  comment(; time zone offset in seconds)
                                           comment(; west of UTC (-46800 to 43200\))
operator(()ident(tm:zone) ident(time)operator(\))   operator(()ident(set-tm:zone) ident(time) ident(zone)operator(\))   comment(; Time zone label (a string\),)
                                           comment(; not necessarily unique.)

operator(()ident(format) predefined_constant(#t) string<delimiter(")content(Today is day ~A of the current year.)content(\\n)delimiter(")>
        operator(()ident(tm:yday) operator(()ident(localtime) operator(()ident(current-time)operator(\))operator(\))operator(\))operator(\))

comment(;; Or use SRFI-19 - Time and Date Procedures)
operator(()ident(use-modules) operator(()ident(srfi) ident(srfi-19)operator(\))operator(\))

operator(()keyword(define) ident(now) operator(()ident(current-date)operator(\))operator(\))  comment(; immutable once created)

operator(()ident(date-nanosecond) ident(now)operator(\))        comment(; 0-9,999,999)
operator(()ident(date-second) ident(now)operator(\))            comment(; 0-60 (60 represents a leap second\))
operator(()ident(date-minute) ident(now)operator(\))            comment(; 0-59)
operator(()ident(date-hour) ident(now)operator(\))              comment(; 0-23)
operator(()ident(date-day) ident(now)operator(\))               comment(; 0-31)
operator(()ident(date-month) ident(now)operator(\))             comment(; 1-12)
operator(()ident(date-year) ident(now)operator(\))              comment(; integer representing the year)
operator(()ident(date-year-day) ident(now)operator(\))          comment(; day of year (Jan 1 is 1, etc.\))
operator(()ident(date-week-day) ident(now)operator(\))          comment(; day of week (Sunday is 0, etc.\))
operator(()ident(date-week-number) ident(now) ident(start)operator(\)) comment(; week of year, ignoring a first partial week)
                             comment(; start is the first day of week as above)
operator(()ident(date-zone-offset) ident(now)operator(\))       comment(; integer number of seconds east of GMT)

operator(()ident(format) predefined_constant(#t) string<delimiter(")content(Today is day ~A of the current year.)content(\\n)delimiter(")>
        operator(()ident(date-year-day) operator(()ident(current-date)operator(\))operator(\))operator(\))

comment(;; @@PLEAC@@_3.1)
comment(;; using format and POSIX time components)
operator(()ident(use-modules) operator(()ident(ice-9) ident(format)operator(\))operator(\))
operator(()keyword(let) operator(()operator(()ident(now) operator(()ident(localtime) operator(()ident(current-time)operator(\))operator(\))operator(\))operator(\))
  operator(()ident(format) predefined_constant(#t) string<delimiter(")content(The current date is ~4'0D ~2'0D ~2'0D)content(\\n)delimiter(")>
          operator(()ident(+) integer(1900) operator(()ident(tm:year) ident(now)operator(\))operator(\)) operator(()ident(tm:mon) ident(now)operator(\)) operator(()ident(tm:mday) ident(now)operator(\))operator(\))operator(\))

comment(;; using format and SRFI-19 time components)
operator(()ident(use-modules) operator(()ident(srfi) ident(srfi-19)operator(\)) operator(()ident(ice-9) ident(format)operator(\))operator(\))
operator(()keyword(let) operator(()operator(()ident(now) operator(()ident(current-date)operator(\))operator(\))operator(\))
  operator(()ident(format) predefined_constant(#t) string<delimiter(")content(The current date is ~4'0d-~2'0D-~2'0D)content(\\n)delimiter(")>
          operator(()ident(date-year) ident(now)operator(\)) operator(()ident(date-month) ident(now)operator(\)) operator(()ident(date-day) ident(now)operator(\))operator(\))operator(\))

comment(;; using POSIX strftime with a libc time format string)
operator(()ident(display) operator(()ident(strftime) string<delimiter(")content(%Y-%m-%d)content(\\n)delimiter(")> operator(()ident(localtime) operator(()ident(current-time)operator(\))operator(\))operator(\))operator(\))

comment(;; @@PLEAC@@_3.2)
comment(;; set the individual components of a time struct and use mktime)
operator(()keyword(define) ident(time) operator(()ident(localtime) operator(()ident(current-time)operator(\))operator(\))operator(\))
operator(()ident(set-tm:mday) ident(time) ident(mday)operator(\))
operator(()ident(set-tm:mon) ident(time) ident(mon)operator(\))
operator(()ident(set-tm:year) ident(time) ident(year)operator(\))
operator(()ident(car) operator(()ident(mktime) ident(time)operator(\))operator(\))  comment(; mktime returns a (epoch-seconds . time\) pair)

comment(;; or use SRFI-19's make-date and date->time-monotonic)
operator(()ident(use-modules) operator(()ident(srfi) ident(srfi-19)operator(\))operator(\))
operator(()ident(date->time-monotonic)
 operator(()ident(make-date) ident(nanosecond) ident(second) ident(minute) ident(hour) ident(day) ident(month) ident(year) ident(zone-offset)operator(\))operator(\))

comment(;; @@PLEAC@@_3.3)
comment(;; use localtime or gmtime with the accessors mentioned in the)
comment(;; introduction to this chapter)
operator(()keyword(let) operator(()operator(()ident(time) operator(()ident(localtime) ident(seconds)operator(\))operator(\))operator(\))  comment(; or gmtime)
  operator(()ident(format) predefined_constant(#t) string<delimiter(")content(Dateline: ~2'0d:~2'0d:~2'0d-~4'0d/~2'0d/~2'0d)content(\\n)delimiter(")>
          operator(()ident(tm:hour) ident(time)operator(\)) operator(()ident(tm:min) ident(time)operator(\)) operator(()ident(tm:sec) ident(time)operator(\))
          operator(()ident(+) integer(1900) operator(()ident(tm:year) ident(time)operator(\))operator(\)) operator(()integer(1)ident(+) operator(()ident(tm:mon) ident(time)operator(\))operator(\)) operator(()ident(tm:mday) ident(time)operator(\))operator(\))operator(\))

comment(;; or use SRFI-19)
operator(()ident(use-modules) operator(()ident(srfi) ident(srfi-19)operator(\))operator(\))
operator(()keyword(let*) operator(()operator(()ident(time) operator(()ident(make-time) ident(time-monotonic) ident(nanosecond) ident(second)operator(\))operator(\))operator(\))
  operator(()ident(display) operator(()ident(date->string) operator(()ident(time-monotonic->date) ident(time)operator(\)) string<delimiter(")content(~T-~1)content(\\n)delimiter(")>operator(\))operator(\))operator(\))

comment(;; @@PLEAC@@_3.4)
comment(;; just add or subtract epoch seconds)
operator(()keyword(define) ident(when) operator(()ident(+) ident(now) ident(difference)operator(\))operator(\))
operator(()keyword(define) ident(then) operator(()ident(-) ident(now) ident(difference)operator(\))operator(\))

comment(;; if you have DMYHMS values, you can convert them to times or add)
comment(;; them as seconds:)
operator(()keyword(define) ident(birthtime) integer(96176750)operator(\))
operator(()keyword(define) ident(interval) operator(()ident(+) integer(5)                  comment(; 5 seconds)
                    operator(()ident(*) integer(17) integer(60)operator(\))          comment(; 17 minutes)
                    operator(()ident(*) integer(2) integer(60) integer(60)operator(\))        comment(; 2 hours)
                    operator(()ident(*) integer(55) integer(60) integer(60) integer(24)operator(\))operator(\))operator(\))  comment(; and 55 days)
operator(()keyword(define) ident(then) operator(()ident(+) ident(birthtime) ident(interval)operator(\))operator(\))
operator(()ident(format) predefined_constant(#t) string<delimiter(")content(Then is ~A)content(\\n)delimiter(")> operator(()ident(strftime) string<delimiter(")content(%a %b %d %T %Y)delimiter(")> operator(()ident(localtime) ident(then)operator(\))operator(\))operator(\))

comment(;; @@PLEAC@@_3.5)
comment(;; subtract the epoch seconds:)
operator(()keyword(define) ident(bree) integer(361535725)operator(\))
operator(()keyword(define) ident(nat) integer(96201950)operator(\))
operator(()keyword(define) ident(difference) operator(()ident(-) ident(bree) ident(nat)operator(\))operator(\))
operator(()ident(format) predefined_constant(#t) string<delimiter(")content(There were ~A seconds between Nat and Bree)content(\\n)delimiter(")> ident(difference)operator(\))

comment(;; or use SRFI-19's time arithmetic procedures:)
operator(()ident(use-modules) operator(()ident(srfi) ident(srfi-19)operator(\))operator(\))
operator(()keyword(define) ident(time1) operator(()ident(make-time) ident(time-monotonic) ident(nano1) ident(sec1)operator(\))operator(\))
operator(()keyword(define) ident(time2) operator(()ident(make-time) ident(time-monotonic) ident(nano2) ident(sec2)operator(\))operator(\))
operator(()keyword(define) ident(duration) operator(()ident(time-difference) ident(time1) ident(time2)operator(\))operator(\))
operator(()ident(time=?) operator(()ident(subtract-duration) ident(time1) ident(duration)operator(\)) ident(time2)operator(\)) comment(; #t)
operator(()ident(time=?) operator(()ident(add-duration) ident(time2) ident(duration)operator(\)) ident(time1)operator(\))      comment(; #t)

comment(;; @@PLEAC@@_3.6)
comment(;; convert to a SRFI-19 date and use the accessors)
operator(()ident(use-modules) operator(()ident(srfi) ident(srfi-19)operator(\))operator(\))
operator(()ident(date-day) ident(date)operator(\))
operator(()ident(date-year-day) ident(date)operator(\))
operator(()ident(date-week-day) ident(date)operator(\))
operator(()ident(date-week-number) ident(date) ident(start-day-of-week)operator(\))

comment(;; @@PLEAC@@_3.7)
comment(;; use the strptime function:)
operator(()keyword(define) ident(time-pair) operator(()ident(strptime) string<delimiter(")content(%Y-%m-%d)delimiter(")> string<delimiter(")content(1998-06-03)delimiter(")>operator(\))operator(\))
operator(()ident(format) predefined_constant(#t) string<delimiter(")content(Time is ~A)content(\\n)content(.)delimiter(")> operator(()ident(strftime) string<delimiter(")content(%b %d, %Y)delimiter(")> operator(()ident(car) ident(time-pair)operator(\))operator(\))operator(\))

comment(;; or use SRFI-19's string->date:)
operator(()ident(use-modules) operator(()ident(srfi) ident(srfi-19)operator(\))operator(\))
operator(()keyword(define) ident(date) operator(()ident(string->date) string<delimiter(")content(1998-06-03)delimiter(")> string<delimiter(")content(~Y-~m-~d)delimiter(")>operator(\))operator(\))
operator(()ident(format) predefined_constant(#t) string<delimiter(")content(Time is ~A.)content(\\n)delimiter(")> operator(()ident(date->string) ident(date)operator(\))operator(\))

comment(;; @@PLEAC@@_3.8)
comment(;; use the already seen strftime:)
operator(()ident(format) predefined_constant(#t) string<delimiter(")content(strftime gives: ~A)content(\\n)delimiter(")>
        operator(()ident(strftime) string<delimiter(")content(%A %D)delimiter(")> operator(()ident(localtime) operator(()ident(current-time)operator(\))operator(\))operator(\))operator(\))

comment(;; or SRFI-19's date->string:)
operator(()ident(use-modules) operator(()ident(srfi) ident(srfi-19)operator(\))operator(\))
operator(()ident(format) predefined_constant(#t) string<delimiter(")content(default date->string gives: ~A)content(\\n)delimiter(")> operator(()ident(date->string) operator(()ident(current-date)operator(\))operator(\))operator(\))
operator(()ident(format) predefined_constant(#t) string<delimiter(")content(date->string gives: ~A)content(\\n)delimiter(")>
        operator(()ident(date->string) operator(()ident(current-date)operator(\)) string<delimiter(")content(~a ~b ~e ~H:~M:~S ~z ~Y)delimiter(")>operator(\))operator(\))

comment(;; @@PLEAC@@_3.9)
comment(;; gettimeofday will return seconds and microseconds:)
operator(()keyword(define) ident(t0) operator(()ident(gettimeofday)operator(\))operator(\))
comment(;; do your work here)
operator(()keyword(define) ident(t1) operator(()ident(gettimeofday)operator(\))operator(\))
operator(()ident(format) predefined_constant(#t) string<delimiter(")content(You took ~A seconds and ~A microseconds)content(\\n)delimiter(")>
        operator(()ident(-) operator(()ident(car) ident(t1)operator(\)) operator(()ident(car) ident(t0)operator(\))operator(\)) operator(()ident(-) operator(()ident(cdr) ident(t1)operator(\)) operator(()ident(cdr) ident(t0)operator(\))operator(\))operator(\))

comment(;; you can also get more detailed info about the real and processor)
comment(;; times:)
operator(()keyword(define) ident(runtime) operator(()ident(times)operator(\))operator(\))
operator(()ident(tms:clock) ident(runtime)operator(\))  comment(; the current real time)
operator(()ident(tms:utime) ident(runtime)operator(\))  comment(; the CPU time units used by the calling process)
operator(()ident(tms:stime) ident(runtime)operator(\))  comment(; the CPU time units used by the system on behalf)
                     comment(; of the calling process.)
operator(()ident(tms:cutime) ident(runtime)operator(\)) comment(; the CPU time units used by terminated child)
                     comment(; processes of the calling process, whose status)
                     comment(; has been collected (e.g., using `waitpid'\).)
operator(()ident(tms:cstime) ident(runtime)operator(\)) comment(; the CPU times units used by the system on)
		     comment(; behalf of terminated child processes)

comment(;; you can also use the time module to time execution:)
operator(()ident(use-modules) operator(()ident(ice-9) ident(time)operator(\))operator(\))
operator(()ident(time) operator(()ident(sleep) integer(3)operator(\))operator(\))
comment(;; clock utime stime cutime cstime gctime)
comment(;; 3.01  0.00  0.00   0.00   0.00   0.00)
comment(;; 0)

comment(;; @@PLEAC@@_3.10)
operator(()ident(sleep) ident(i)operator(\))   comment(; sleep for i seconds)
operator(()ident(usleep) ident(i)operator(\))  comment(; sleep for i microseconds (not available on all platforms\))

comment(;; @@PLEAC@@_4.0)
operator(()keyword(define) ident(nested) operator(')operator(()string<delimiter(")content(this)delimiter(")> string<delimiter(")content(that)delimiter(")> string<delimiter(")content(the)delimiter(")> string<delimiter(")content(other)delimiter(")>operator(\))operator(\))
operator(()keyword(define) ident(nested) operator(')operator(()string<delimiter(")content(this)delimiter(")> string<delimiter(")content(that)delimiter(")> operator(()string<delimiter(")content(the)delimiter(")> string<delimiter(")content(other)delimiter(")>operator(\))operator(\))operator(\))
operator(()keyword(define) ident(tune) operator(')operator(()string<delimiter(")content(The)delimiter(")> string<delimiter(")content(Star-Spangled)delimiter(")> string<delimiter(")content(Banner)delimiter(")>operator(\))operator(\))

comment(;; @@PLEAC@@_4.1)
operator(()keyword(define) ident(a) operator(')operator(()string<delimiter(")content(quick)delimiter(")> string<delimiter(")content(brown)delimiter(")> string<delimiter(")content(fox)delimiter(")>operator(\))operator(\))
operator(()keyword(define) ident(a) operator(')operator(()string<delimiter(")content(Why)delimiter(")> string<delimiter(")content(are)delimiter(")> string<delimiter(")content(you)delimiter(")> string<delimiter(")content(teasing)delimiter(")> string<delimiter(")content(me?)delimiter(")>operator(\))operator(\))

operator(()ident(use-modules) operator(()ident(srfi) ident(srfi-13)operator(\))operator(\))
operator(()keyword(define) ident(lines)
  operator(()ident(map) ident(string-trim)
       operator(()ident(string-tokenize) string<delimiter(")content(\\)content(
    The boy stood on the burning deck,
    It was as hot as glass.)delimiter(")>
			char(#\\newline)operator(\))operator(\))operator(\))

operator(()keyword(define) ident(bigarray)
  operator(()ident(with-input-from-file) string<delimiter(")content(mydatafile)delimiter(")>
    operator(()keyword(lambda) operator(()operator(\))
      operator(()keyword(let) ident(loop) operator(()operator(()ident(lines) operator(')operator(()operator(\))operator(\))
		 operator(()ident(next-line) operator(()ident(read-line)operator(\))operator(\))operator(\))
	operator(()keyword(if) operator(()ident(eof-object?) ident(next-line)operator(\))
	    operator(()ident(reverse) ident(lines)operator(\))
	    operator(()ident(loop) operator(()keyword(cons) ident(next-line) ident(lines)operator(\))
		  operator(()ident(read-line)operator(\))operator(\))operator(\))operator(\))operator(\))operator(\))operator(\))

operator(()keyword(define) ident(banner) string<delimiter(")content(The Mines of Moria)delimiter(")>operator(\))

operator(()keyword(define) ident(name) string<delimiter(")content(Gandalf)delimiter(")>operator(\))
operator(()keyword(define) ident(banner)
  operator(()ident(string-append) string<delimiter(")content(Speak, )delimiter(")> ident(name) string<delimiter(")content(, and enter!)delimiter(")>operator(\))operator(\))
operator(()keyword(define) ident(banner)
  operator(()ident(format) predefined_constant(#f) string<delimiter(")content(Speak, ~A, and welcome!)delimiter(")> ident(name)operator(\))operator(\))

comment(;; Advanced shell-like function is provided by guile-scsh, the Guile)
comment(;; port of SCSH, the Scheme shell.  Here we roll our own using the)
comment(;; pipe primitives that come with core Guile.)
operator(()ident(use-modules) operator(()ident(ice-9) ident(popen)operator(\))operator(\))

operator(()keyword(define) operator(()ident(drain-output) ident(port)operator(\))
  operator(()keyword(let) ident(loop) operator(()operator(()ident(chars) operator(')operator(()operator(\))operator(\))
             operator(()ident(next) operator(()ident(read-char) ident(port)operator(\))operator(\))operator(\))
    operator(()keyword(if) operator(()ident(eof-object?) ident(next)operator(\))
        operator(()ident(list->string) operator(()ident(reverse!) ident(chars)operator(\))operator(\))
        operator(()ident(loop) operator(()keyword(cons) ident(next) ident(chars)operator(\))
              operator(()ident(read-char) ident(port)operator(\))operator(\))operator(\))operator(\))operator(\))

operator(()keyword(define) operator(()ident(qx) ident(pipeline)operator(\))
  operator(()keyword(let*) operator(()operator(()ident(pipe) operator(()ident(open-input-pipe) ident(pipeline)operator(\))operator(\))
         operator(()ident(output) operator(()ident(drain-output) ident(pipe)operator(\))operator(\))operator(\))
    operator(()ident(close-pipe) ident(pipe)operator(\))
    ident(output)operator(\))operator(\))

operator(()keyword(define) ident(his-host) string<delimiter(")content(www.perl.com)delimiter(")>operator(\))
operator(()keyword(define) ident(host-info) operator(()ident(qx) operator(()ident(format) predefined_constant(#f) string<delimiter(")content(nslookup ~A)delimiter(")> ident(his-host)operator(\))operator(\))operator(\))

operator(()keyword(define) ident(perl-info) operator(()ident(qx) operator(()ident(format) predefined_constant(#f) string<delimiter(")content(ps ~A)delimiter(")> operator(()ident(getpid)operator(\))operator(\))operator(\))operator(\))
operator(()keyword(define) ident(shell-info) operator(()ident(qx) string<delimiter(")content(ps $$)delimiter(")>operator(\))operator(\))

operator(()keyword(define) ident(banner) operator(')operator(()string<delimiter(")content(Costs)delimiter(")> string<delimiter(")content(only)delimiter(")> string<delimiter(")content($4.95)delimiter(")>operator(\))operator(\))
operator(()keyword(define) ident(brax)    operator(()ident(map) ident(string) operator(()ident(string->list) string<delimiter(")content((\)<>{}[])delimiter(")>operator(\))operator(\))operator(\))
operator(()keyword(define) ident(rings)   operator(()ident(string-tokenize) string<delimiter(")content(Nenya Narya Vilya)delimiter(")>operator(\))operator(\))
operator(()keyword(define) ident(tags)    operator(()ident(string-tokenize) string<delimiter(")content(LI TABLE TR TD A IMG H1 P)delimiter(")>operator(\))operator(\))
operator(()keyword(define) ident(sample)
  operator(()ident(string-tokenize) string<delimiter(")content(The vertical bar (|\) looks and behaves like a pipe.)delimiter(")>operator(\))operator(\))
operator(()keyword(define) ident(ships)  operator(')operator(()string<delimiter(")content(Niña)delimiter(")> string<delimiter(")content(Pinta)delimiter(")> string<delimiter(")content(Santa María)delimiter(")>operator(\))operator(\))

comment(;; @@PLEAC@@_4.2)
operator(()keyword(define) ident(array) operator(')operator(()string<delimiter(")content(red)delimiter(")> string<delimiter(")content(yellow)delimiter(")> string<delimiter(")content(green)delimiter(")>operator(\))operator(\))

operator(()keyword(begin)
  operator(()ident(display) string<delimiter(")content(I have )delimiter(")>operator(\))
  operator(()ident(for-each) ident(display) ident(array)operator(\))
  operator(()ident(display) string<delimiter(")content( marbles.)content(\\n)delimiter(")>operator(\))operator(\))
comment(;; I have redyellowgreen marbles.)

operator(()keyword(begin)
  operator(()ident(display) string<delimiter(")content(I have )delimiter(")>operator(\))
  operator(()ident(for-each) operator(()keyword(lambda) operator(()ident(colour)operator(\))
	      operator(()ident(display) ident(colour)operator(\))
	      operator(()ident(display) string<delimiter(")content( )delimiter(")>operator(\))operator(\))
	    ident(array)operator(\))
  operator(()ident(display) string<delimiter(")content(marbles.)content(\\n)delimiter(")>operator(\))operator(\))
comment(;; I have red yellow green marbles.)

comment(;; commify - insertion of commas into list output)
operator(()keyword(define) operator(()ident(commify) ident(strings)operator(\))
  operator(()keyword(let) operator(()operator(()ident(len) operator(()ident(length) ident(strings)operator(\))operator(\))operator(\))
    operator(()keyword(case) ident(len)
      operator(()operator(()integer(0)operator(\)) string<delimiter(")delimiter(")>operator(\))
      operator(()operator(()integer(1)operator(\)) operator(()ident(car) ident(strings)operator(\))operator(\))
      operator(()operator(()integer(2)operator(\)) operator(()ident(string-append) operator(()ident(car) ident(strings)operator(\)) string<delimiter(")content( and )delimiter(")> operator(()ident(cadr) ident(strings)operator(\))operator(\))operator(\))
      operator(()operator(()integer(3)operator(\)) operator(()ident(string-append) operator(()ident(car) ident(strings)operator(\)) string<delimiter(")content(, )delimiter(")>
                          operator(()ident(cadr) ident(strings)operator(\)) string<delimiter(")content(, and )delimiter(")>
                          operator(()ident(caddr) ident(strings)operator(\))operator(\))operator(\))
      operator(()ident(else)
       operator(()ident(string-append) operator(()ident(car) ident(strings)operator(\)) string<delimiter(")content(, )delimiter(")>
                      operator(()ident(commify) operator(()ident(cdr) ident(strings)operator(\))operator(\))operator(\))operator(\))operator(\))operator(\))operator(\))

operator(()keyword(define) ident(lists) operator(')operator(()operator(()string<delimiter(")content(just one thing)delimiter(")>operator(\))
                operator(()string<delimiter(")content(Mutt)delimiter(")> string<delimiter(")content(Jeff)delimiter(")>operator(\))
                operator(()string<delimiter(")content(Peter)delimiter(")> string<delimiter(")content(Paul)delimiter(")> string<delimiter(")content(Mary)delimiter(")>operator(\))
                operator(()string<delimiter(")content(To our parents)delimiter(")> string<delimiter(")content(Mother Theresa)delimiter(")> string<delimiter(")content(God)delimiter(")>operator(\))
                operator(()string<delimiter(")content(pastrami)delimiter(")> string<delimiter(")content(ham and cheese)delimiter(")> string<delimiter(")content(peanut butter and jelly)delimiter(")> string<delimiter(")content(tuna)delimiter(")>operator(\))
                operator(()string<delimiter(")content(recycle tired, old phrases)delimiter(")> string<delimiter(")content(ponder big, happy thoughts)delimiter(")>operator(\))
                operator(()string<delimiter(")content(recycle tired, old phrases)delimiter(")>
                 string<delimiter(")content(ponder big, happy thoughts)delimiter(")>
                 string<delimiter(")content(sleep and dream peacefully)delimiter(")>operator(\))operator(\))operator(\))

operator(()ident(for-each) operator(()keyword(lambda) operator(()ident(list)operator(\))
            operator(()ident(display) string<delimiter(")content(The list is: )delimiter(")>operator(\))
            operator(()ident(display) operator(()ident(commify) ident(list)operator(\))operator(\))
            operator(()ident(display) string<delimiter(")content(.)content(\\n)delimiter(")>operator(\))operator(\))
          ident(lists)operator(\))

comment(;; The list is: just one thing.)
comment(;; The list is: Mutt and Jeff.)
comment(;; The list is: Peter, Paul, and Mary.)
comment(;; The list is: To our parents, Mother Theresa, and God.)
comment(;; The list is: pastrami, ham and cheese, peanut butter and jelly, and tuna.)
comment(;; The list is: recycle tired, old phrases and ponder big, happy thoughts.)
comment(;; The list is: recycle tired, old phrases, ponder big, happy thoughts, and sleep and dream peacefully.)

comment(;; @@PLEAC@@_4.3)
comment(;;-----------------------------)

comment(;; Scheme does not normally grow and shrink arrays in the way that)
comment(;; Perl can.  The more usual operations are adding and removing from)
comment(;; the head of a list using the `cons' and `cdr' procedures.)
comment(;; However ...)
operator(()keyword(define) operator(()ident(grow/shrink) ident(list) ident(new-size)operator(\))
  operator(()keyword(let) operator(()operator(()ident(size) operator(()ident(length) ident(list)operator(\))operator(\))operator(\))
    operator(()keyword(cond) operator(()operator(()ident(<) ident(size) ident(new-size)operator(\))
           operator(()ident(grow/shrink) operator(()keyword(cons) string<delimiter(")delimiter(")> ident(list)operator(\)) ident(new-size)operator(\))operator(\))
          operator(()operator(()ident(>) ident(size) ident(new-size)operator(\))
           operator(()ident(grow/shrink) operator(()ident(cdr) ident(list)operator(\)) ident(new-size)operator(\))operator(\))
          operator(()ident(else) ident(list)operator(\))operator(\))operator(\))operator(\))

operator(()keyword(define) operator(()ident(element) ident(list) ident(i)operator(\))
  operator(()ident(list-ref) ident(list) operator(()ident(-) operator(()ident(length) ident(list)operator(\)) ident(i) integer(1)operator(\))operator(\))operator(\))

operator(()keyword(define) operator(()ident(set-element) ident(list) ident(i) ident(value)operator(\))
  operator(()keyword(if) operator(()ident(>=) ident(i) operator(()ident(length) ident(list)operator(\))operator(\))
      operator(()keyword(set!) ident(list) operator(()ident(grow/shrink) ident(list) operator(()ident(-) ident(i) integer(1)operator(\))operator(\))operator(\))operator(\))
  operator(()ident(set-car!) operator(()ident(list-cdr-ref) ident(list) operator(()ident(-) operator(()ident(length) ident(list)operator(\)) ident(i) integer(1)operator(\))operator(\))operator(\))
  ident(list)operator(\))

operator(()keyword(define) operator(()ident(what-about) ident(list)operator(\))
  operator(()keyword(let) operator(()operator(()ident(len) operator(()ident(length) ident(list)operator(\))operator(\))operator(\))
    operator(()ident(format) predefined_constant(#t) string<delimiter(")content(The array now has ~A elements.)content(\\n)delimiter(")> ident(len)operator(\))
    operator(()ident(format) predefined_constant(#t) string<delimiter(")content(The index of the last element is ~A.)content(\\n)delimiter(")> operator(()ident(-) ident(len) integer(1)operator(\))operator(\))
    operator(()ident(format) predefined_constant(#t) string<delimiter(")content(Element #3 is `~A'.)content(\\n)delimiter(")> operator(()keyword(if) operator(()ident(>) ident(len) integer(3)operator(\))
                                           operator(()ident(element) ident(list) integer(3)operator(\))
                                           string<delimiter(")delimiter(")>operator(\))operator(\))operator(\))operator(\))

comment(;; In the emulation of Perl arrays implemented here, the elements are)
comment(;; in reverse order when compared to normal Scheme lists.)
operator(()keyword(define) ident(people) operator(()ident(reverse) operator(')operator(()string<delimiter(")content(Crosby)delimiter(")> string<delimiter(")content(Stills)delimiter(")> string<delimiter(")content(Nash)delimiter(")> string<delimiter(")content(Young)delimiter(")>operator(\))operator(\))operator(\))
operator(()ident(what-about) ident(people)operator(\))
comment(;;-----------------------------)
comment(;; The array now has 4 elements.)
comment(;; The index of the last element is 3.)
comment(;; Element #3 is `Young'.)
comment(;;-----------------------------)
operator(()keyword(set!) ident(people) operator(()ident(grow/shrink) ident(people) integer(3)operator(\))operator(\))
operator(()ident(what-about) ident(people)operator(\))
comment(;;-----------------------------)
comment(;; The array now has 3 elements.)
comment(;; The index of the last element is 2.)
comment(;; Element #3 is `'.)
comment(;;-----------------------------)
operator(()keyword(set!) ident(people) operator(()ident(grow/shrink) ident(people) integer(10001)operator(\))operator(\))
operator(()ident(what-about) ident(people)operator(\))
comment(;;-----------------------------)
comment(;; The array now has 10001 elements.)
comment(;; The index of the last element is 10000.)
comment(;; Element #3 is `'.)
comment(;;-----------------------------)

comment(;; @@PLEAC@@_4.4)
comment(; Using a 'list' i.e. chain of pairs)
operator(()keyword(define) ident(*mylist*) operator(')operator(()integer(1) integer(2) integer(3)operator(\))operator(\))

comment(; Apply procedure to each member of 'mylist')
operator(()ident(for-each)
  operator(()keyword(lambda) operator(()ident(item)operator(\)) operator(()ident(print) ident(item)operator(\))operator(\))
  ident(*mylist*)operator(\))

comment(;; ------------)

comment(; Using a 'vector' i.e. one-dimensional array)
operator(()keyword(define) ident(*bad-users*) operator(')operator(#()string<delimiter(")content(lou)delimiter(")> string<delimiter(")content(mo)delimiter(")> string<delimiter(")content(sterling)delimiter(")> string<delimiter(")content(john)delimiter(")>operator(\))operator(\))

operator(()keyword(define) operator(()ident(complain) ident(user)operator(\))
  operator(()ident(print) string<delimiter(")content(You're a *bad user*,)delimiter(")> ident(user)operator(\))operator(\))

operator(()ident(array-for-each)
  operator(()keyword(lambda) operator(()ident(user)operator(\)) operator(()ident(complain) ident(user)operator(\))operator(\))
  ident(*bad-users*)operator(\))

comment(;; ------------)

comment(; Could probably get away with sorting a list of strings ...)
operator(()keyword(define) ident(*sorted-environ*)
  operator(()ident(sort) operator(()ident(environ)operator(\)) ident(string<?)operator(\))operator(\))

operator(()ident(for-each)
  operator(()keyword(lambda) operator(()ident(var)operator(\)) operator(()ident(display) ident(var)operator(\)) operator(()ident(newline)operator(\))operator(\))
  ident(*sorted-environ*)operator(\))

comment(;; ----)

comment(; ... but the intent here is to sort a hash table, so we'll use)
comment(; an 'assoc', Scheme's native dictionary type, which is really)
comment(; nothing more than a list of conses / dotted pairs [hash tables)
comment(; will be used in later examples])
operator(()keyword(define) operator(()ident(cons->env-string) ident(a)operator(\))
  operator(()ident(string-append) operator(()ident(car) ident(a)operator(\)) string<delimiter(")content(=)delimiter(")> operator(()ident(cdr) ident(a)operator(\))operator(\))operator(\))

operator(()keyword(define) operator(()ident(env-string->cons) ident(s)operator(\))
  operator(()keyword(let) operator(()operator(()ident(key-value) operator(()ident(string-split) ident(s) char(#\\=)operator(\))operator(\))operator(\))
    operator(()keyword(cons) operator(()ident(car) ident(key-value)operator(\)) operator(()ident(cadr) ident(key-value)operator(\))operator(\))operator(\))operator(\))

operator(()keyword(define) ident(*sorted-environ-assoc*)
  operator(()ident(sort)
    operator(()ident(map)
      operator(()keyword(lambda) operator(()ident(var)operator(\)) operator(()ident(env-string->cons) ident(var)operator(\))operator(\))
      operator(()ident(environ)operator(\))operator(\))
    operator(()keyword(lambda) operator(()ident(left) ident(right)operator(\)) operator(()ident(string<?) operator(()ident(car) ident(left)operator(\)) operator(()ident(car) ident(right)operator(\))operator(\))operator(\)) operator(\))operator(\))

operator(()ident(for-each)
  operator(()keyword(lambda) operator(()ident(var)operator(\))
    operator(()ident(print) operator(()ident(car) ident(var)operator(\)) string<delimiter(")content(=)delimiter(")> operator(()ident(cdr) ident(var)operator(\))operator(\))operator(\))
  ident(*sorted-environ-assoc*)operator(\))

comment(;; ----------------------------)

operator(()keyword(define) ident(*MAX-QUOTA*) integer(100)operator(\))

operator(()keyword(define) operator(()ident(get-all-users)operator(\)) ident(...)operator(\))
operator(()keyword(define) operator(()ident(get-usage) ident(user)operator(\)) ident(...)operator(\))
operator(()keyword(define) operator(()ident(complain) ident(user)operator(\)) ident(...)operator(\))

operator(()ident(for-each)
  operator(()keyword(lambda) operator(()ident(user)operator(\))
    operator(()keyword(let) operator(()operator(()ident(disk-usage) operator(()ident(get-usage) ident(user)operator(\))operator(\))operator(\))
      operator(()keyword(if) operator(()ident(>) ident(disk-usage) ident(*MAX-QUOTA*)operator(\))
        operator(()ident(complain) ident(user)operator(\))operator(\))operator(\))operator(\))
  operator(()ident(get-all-users)operator(\))operator(\))

comment(;; ----------------------------)

operator(()ident(for-each)
  operator(()keyword(lambda) operator(()ident(user)operator(\)) operator(()keyword(if) operator(()ident(string=?) ident(user) string<delimiter(")content(tchrist)delimiter(")>operator(\)) operator(()ident(print) ident(user)operator(\))operator(\))operator(\))
  operator(()ident(string-split) operator(()ident(qx) string<delimiter(")content(who|cut -d' ' -f1|uniq)delimiter(")>operator(\)) char(#\\newline)operator(\))operator(\))

comment(;; ----------------------------)

operator(()ident(use-modules) operator(()ident(srfi) ident(srfi-13)operator(\)) operator(()ident(srfi) ident(srfi-14)operator(\))operator(\))

operator(()keyword(do) operator(()operator(()ident(line) operator(()ident(read-line)operator(\)) operator(()ident(read-line)operator(\))operator(\))operator(\))
    operator(()operator(()ident(eof-object?) ident(line)operator(\))operator(\))
  operator(()ident(for-each)
    operator(()keyword(lambda) operator(()ident(word)operator(\)) operator(()ident(print) operator(()ident(string-reverse) ident(word)operator(\))operator(\))operator(\))
    operator(()ident(string-tokenize) ident(line) ident(char-set:graphic)operator(\))operator(\))operator(\))

comment(;; ----------------------------)

comment(; Updates vector in-place [accepts variable number of vectors])
comment(; See also the library function, 'array-map-in-order!' and its)
comment(; brethren)
operator(()keyword(define) operator(()ident(vector-map-in-order!) ident(proc) ident(vec) operator(.) ident(rest)operator(\))
  operator(()keyword(let) operator(()operator(()ident(all-vec) operator(()keyword(cons) ident(vec) ident(rest)operator(\))operator(\))operator(\))
    operator(()ident(for-each)
      operator(()keyword(lambda) operator(()ident(vec)operator(\))
        operator(()keyword(let) operator(()operator(()ident(end) operator(()ident(vector-length) ident(vec)operator(\))operator(\))operator(\))
          operator(()keyword(let) ident(loop) operator(()operator(()ident(idx) integer(0)operator(\))operator(\))
            operator(()keyword(cond)
              operator(()operator(()ident(=) ident(idx) ident(end)operator(\)) operator(')operator(()operator(\))operator(\))
              operator(()ident(else)
                operator(()ident(vector-set!) ident(vec) ident(idx) operator(()ident(apply) ident(proc) operator(()ident(list) operator(()ident(vector-ref) ident(vec) ident(idx)operator(\))operator(\))operator(\))operator(\))
                operator(()ident(loop) operator(()ident(+) ident(idx) integer(1)operator(\))operator(\))operator(\))operator(\)) operator(\))operator(\))operator(\))
      ident(all-vec)operator(\))operator(\))operator(\))

comment(;; ----)

comment(; A non-mutating version - illustration only, as library routines)
comment(; [SRFI-43 and built-ins] should be preferred)
operator(()keyword(define) operator(()ident(vector-map-in-order) ident(proc) ident(vec) operator(.) ident(rest)operator(\))
  operator(()keyword(let*) operator(()operator(()ident(all-vec) operator(()keyword(cons) ident(vec) ident(rest)operator(\))operator(\))
         operator(()ident(new-vec-len) operator(()ident(reduce) ident(+) integer(0) operator(()ident(map) ident(vector-length) ident(all-vec)operator(\))operator(\))operator(\))
         operator(()ident(new-vec) operator(()ident(make-vector) ident(new-vec-len)operator(\))operator(\))
         operator(()ident(new-vec-idx) integer(0)operator(\))operator(\))
    operator(()keyword(let) ident(loop) operator(()operator(()ident(all-vec) ident(all-vec)operator(\))operator(\))
      operator(()keyword(cond)
        operator(()operator(()ident(=) ident(new-vec-idx) ident(new-vec-len)operator(\)) ident(new-vec)operator(\))
        operator(()ident(else)
          operator(()ident(array-for-each)
            operator(()keyword(lambda) operator(()ident(element)operator(\))
              operator(()ident(vector-set!) ident(new-vec) ident(new-vec-idx) operator(()ident(apply) ident(proc) operator(()ident(list) ident(element)operator(\))operator(\))operator(\))
              operator(()keyword(set!) ident(new-vec-idx) operator(()ident(+) ident(new-vec-idx) integer(1)operator(\))operator(\))operator(\))
            operator(()ident(car) ident(all-vec)operator(\))operator(\))
          operator(()ident(loop) operator(()ident(cdr) ident(all-vec)operator(\))operator(\)) operator(\))operator(\))operator(\)) operator(\))operator(\))

comment(;; ------------)

operator(()keyword(define) ident(*array*) operator(')operator(#()integer(1) integer(2) integer(3)operator(\))operator(\))

operator(()ident(array-for-each)
  operator(()keyword(lambda) operator(()ident(item)operator(\))
    operator(()ident(print) string<delimiter(")content(i =)delimiter(")> ident(item)operator(\))operator(\))
  ident(*array*)operator(\))

comment(;; ------------)

operator(()keyword(define) ident(*array*) operator(')operator(#()integer(1) integer(2) integer(3)operator(\))operator(\))

operator(()ident(array-for-each)
  operator(()keyword(lambda) operator(()ident(item)operator(\))
    operator(()ident(print) string<delimiter(")content(i =)delimiter(")> ident(item)operator(\))operator(\))
  ident(*array*)operator(\))

comment(; Since a 'vector' is mutable, in-place updates allowed)
operator(()ident(vector-map-in-order!)
  operator(()keyword(lambda) operator(()ident(item)operator(\)) operator(()ident(-) ident(item) integer(1)operator(\))operator(\))
  ident(*array*)operator(\))

operator(()ident(print) ident(*array*)operator(\))

comment(;; ------------)

operator(()keyword(define) ident(*a*) operator(')operator(#()integer(0.5) integer(3)operator(\))operator(\))
operator(()keyword(define) ident(*b*) operator(')operator(#()integer(0) integer(1)operator(\))operator(\))

operator(()ident(vector-map-in-order!)
  operator(()keyword(lambda) operator(()ident(item)operator(\)) operator(()ident(*) ident(item) integer(7)operator(\))operator(\))
  ident(*a*) ident(*b*)operator(\))

operator(()ident(print) ident(*a*) ident(*b*)operator(\))

comment(;; ----------------------------)

comment(; Using 'for-each' to iterate over several container items is a)
comment(; simple matter of passing a list of those items e.g. a list of)
comment(; strings, or of arrays etc.)
comment(;)
comment(; However, complications arise when:)
comment(; * Heterogenous list of items e.g. list contains all of arrays,)
comment(;   hashes, strings, etc. Necesitates different handling based on type)
comment(; * Item needs updating. It is not possible to alter the item reference)
comment(;   and updating an item's internals is only possible if the relevant)
comment(;   mutating procedures are implemented e.g. specified string characters)
comment(;   may be altered in-place, but character deletion requires a new be)
comment(;   created [i.e. altering the item reference], so is not possible)

operator(()keyword(define) ident(*scalar*) string<delimiter(")content(123 )delimiter(")>operator(\))
operator(()keyword(define) ident(*array*) operator(')operator(#()string<delimiter(")content( 123 )delimiter(")> string<delimiter(")content(456 )delimiter(")>operator(\))operator(\))
operator(()keyword(define) ident(*hash*) operator(()ident(list) operator(()keyword(cons) string<delimiter(")content(key1)delimiter(")> string<delimiter(")content(123 )delimiter(")>operator(\)) operator(()keyword(cons) string<delimiter(")content(key2)delimiter(")> string<delimiter(")content( 456)delimiter(")>operator(\))operator(\))operator(\))

comment(; Illustrates iteration / handling of heterogenous types)
operator(()ident(for-each)
  operator(()keyword(lambda) operator(()ident(item)operator(\))
    operator(()keyword(cond)
      operator(()operator(()ident(string?) ident(item)operator(\)) operator(()ident(do-stuff-with-string) ident(item)operator(\))operator(\))
      operator(()operator(()ident(vector?) ident(item)operator(\)) operator(()ident(do-stuff-with-vector) ident(item)operator(\))operator(\))
      operator(()operator(()ident(pair?) ident(item)operator(\)) operator(()ident(do-stuff-with-hash) ident(item)operator(\))operator(\))
      operator(()ident(else) operator(()ident(print) string<delimiter(")content(unknown type)delimiter(")>operator(\))operator(\))operator(\))operator(\))
  operator(()ident(list) ident(*scalar*) ident(*array*) ident(*hash*)operator(\))operator(\))

comment(; So, for item-replacement-based updating you need to use explicit)
comment(; iteration e.g. 'do' loop, or recursion [as is done in the code for)
comment(; 'vector-map-in-order!'] - examples in next section. Or, you could)
comment(; create a new 'for-each' type control structure using Scheme's)
comment(; macro facility [example not shown])

comment(;; @@PLEAC@@_4.5)
operator(()keyword(define) ident(*array*) operator(')operator(#()integer(1) integer(2) integer(3)operator(\))operator(\))

comment(;; ----)

comment(; Whilst a 'vector' is mutable, 'array-for-each' passes only a copy)
comment(; of each cell, thus there is no way to perform updates)
operator(()ident(array-for-each)
  operator(()keyword(lambda) operator(()ident(item)operator(\))
    ident(...) keyword(do) ident(some) ident(non-array-mutating) ident(task) ident(with) operator(')ident(item)operator(')ident(...)operator(\))
  ident(*array*)operator(\))

comment(;; ------------)

comment(; For mutating operations, use one of the mutating 'array-map-...' routines)
comment(; or the custom, 'vector-map-in-order!')
operator(()ident(vector-map-in-order!)
  operator(()keyword(lambda) operator(()ident(item)operator(\))
    ident(...) keyword(do) ident(some) ident(array-mutating) ident(task) ident(with) operator(')ident(item)operator(')ident(...)operator(\))
  ident(*array*)operator(\))

comment(;; ------------)

comment(; Alternatively, use 'do' to iterate over the array and directly update )
operator(()keyword(let) operator(()operator(()ident(vector-length) operator(()ident(vector-length) ident(*array*)operator(\))operator(\))operator(\))
  operator(()keyword(do) operator(()operator(()ident(i) integer(0) operator(()ident(+) ident(i) integer(1)operator(\))operator(\))operator(\))
      operator(()operator(()ident(=) ident(i) ident(vector-length)operator(\))operator(\))
    ident(...) keyword(do) ident(some) ident(array-mutating) ident(task) ident(with) ident(current) ident(array) ident(element) ident(...)operator(\))operator(\))

comment(;; ------------)

comment(; Alternatively, use a 'named let' to iterate over array and directly update )
operator(()keyword(let) operator(()operator(()ident(vector-length) operator(()ident(vector-length) ident(*array*)operator(\))operator(\))operator(\))
  operator(()keyword(let) ident(loop) operator(()operator(()ident(i) integer(0)operator(\))operator(\))
    operator(()keyword(cond)
      operator(()operator(()ident(=) ident(i) ident(vector-length)operator(\)) operator(')operator(()operator(\))operator(\))
      operator(()ident(else)
        ident(...) keyword(do) ident(some) ident(array-mutating) ident(task) ident(with) ident(current) ident(array) ident(element) ident(...)
        operator(()ident(loop) operator(()ident(+) ident(i) integer(1)operator(\))operator(\))operator(\))operator(\)) operator(\))operator(\))

comment(;; ----------------------------)

operator(()keyword(define) ident(*fruits*) operator(')operator(#()string<delimiter(")content(Apple)delimiter(")> string<delimiter(")content(Blackberry)delimiter(")>operator(\))operator(\))

comment(;; ------------)

operator(()ident(array-for-each)
  operator(()keyword(lambda) operator(()ident(fruit)operator(\))
    operator(()ident(print) ident(fruit) string<delimiter(")content(tastes good in a pie.)delimiter(")>operator(\))operator(\))
  ident(*fruits*)operator(\))

comment(;; ------------)

operator(()keyword(let) operator(()operator(()ident(vector-length) operator(()ident(vector-length) ident(*fruits*)operator(\))operator(\))operator(\))
  operator(()keyword(do) operator(()operator(()ident(i) integer(0) operator(()ident(+) ident(i) integer(1)operator(\))operator(\))operator(\))
      operator(()operator(()ident(=) ident(i) ident(vector-length)operator(\))operator(\))
    operator(()ident(print) operator(()ident(vector-ref) ident(*fruits*) ident(i)operator(\)) string<delimiter(")content(tastes good in a pie.)delimiter(")>operator(\)) operator(\))operator(\))

comment(;; ----------------------------)

operator(()keyword(define) ident(*rogue-cats*) operator(')operator(()string<delimiter(")content(Blacky)delimiter(")> string<delimiter(")content(Ginger)delimiter(")> string<delimiter(")content(Puss)delimiter(")>operator(\))operator(\))

operator(()keyword(define) ident(*name-list*) operator(()ident(acons) operator(')ident(felines) ident(*rogue-cats*) operator(')operator(()operator(\))operator(\))operator(\))

comment(;; ------------)

operator(()ident(for-each)
  operator(()keyword(lambda) operator(()ident(cat)operator(\))
    operator(()ident(print) ident(cat) string<delimiter(")content(purrs hypnotically..)delimiter(")>operator(\))operator(\))
  operator(()ident(cdr) operator(()ident(assoc) operator(')ident(felines) ident(*name-list*)operator(\))operator(\))operator(\))

comment(;; ------------)

operator(()keyword(let) ident(loop) operator(()operator(()ident(felines) operator(()ident(cdr) operator(()ident(assoc) operator(')ident(felines) ident(*name-list*)operator(\))operator(\))operator(\))operator(\))
  operator(()keyword(cond)
    operator(()operator(()ident(null?) ident(felines)operator(\)) operator(')operator(()operator(\))operator(\))
    operator(()ident(else)
      operator(()ident(print) operator(()ident(car) ident(felines)operator(\)) string<delimiter(")content(purrs hypnotically..)delimiter(")>operator(\))
      operator(()ident(loop) operator(()ident(cdr) ident(felines)operator(\))operator(\))operator(\))operator(\))operator(\))

comment(;; @@PLEAC@@_4.6)
operator(()ident(use-modules) operator(()ident(srfi) ident(srfi-1)operator(\))operator(\))

comment(; Simplest [read: least code] means of removing duplicates is to use )
comment(; SRFI-1's 'delete-duplicates' routine)

operator(()keyword(define) ident(*non-uniq-num-list*) operator(')operator(()integer(1) integer(2) integer(3) integer(1) integer(2) integer(3)operator(\))operator(\))
operator(()keyword(define) ident(*uniq*) operator(()ident(delete-duplicates) ident(*my-non-uniq-num-list*)operator(\))

comment(;; ------------)

operator(()ident(use-modules) operator(()ident(srfi) ident(srfi-1)operator(\))operator(\))

comment(; Another simple alternative is to use SRFI-1's 'lset-union' routine. In)
comment(; general, the 'lset-...' routines:)
comment(; - convenient, but not fast; probably best avoided for 'large' sets)
comment(; - operate on standard lists, so simple matter of type-converting arrays and such)
comment(; - care needs to be taken in choosing the needed equality function)

operator(()keyword(define) ident(*non-uniq-string-list*) operator(')operator(()string<delimiter(")content(abc)delimiter(")> string<delimiter(")content(def)delimiter(")> string<delimiter(")content(ghi)delimiter(")> string<delimiter(")content(abc)delimiter(")> string<delimiter(")content(def)delimiter(")> string<delimiter(")content(ghi)delimiter(")>operator(\))operator(\))
operator(()keyword(define) ident(*uniq*) operator(()ident(lset-union) ident(string=?) ident(*non-uniq-string-list*) ident(*non-uniq-string-list*)operator(\))operator(\))

comment(;; ----)

operator(()keyword(define) ident(*non-uniq-sym-list*) operator(')operator(()operator(')ident(a) operator(')ident(b) operator(')ident(c) operator(')ident(a) operator(')ident(b) operator(')ident(c)operator(\))operator(\))
operator(()keyword(define) ident(*uniq*) operator(()ident(lset-union) ident(equal?) ident(*my-non-uniq-sym-list*) ident(*my-non-uniq-sym-list*)operator(\))operator(\))

comment(;; ----)

operator(()keyword(define) ident(*non-uniq-num-list*) operator(')operator(()integer(1) integer(2) integer(3) integer(1) integer(2) integer(3)operator(\))operator(\))
operator(()keyword(define) ident(*uniq*) operator(()ident(lset-union) ident(=) ident(*my-non-uniq-num-list*) ident(*my-non-uniq-num-list*)operator(\))operator(\))

comment(;; ----------------------------)

comment(;; Perl Cookbook-based examples - illustrative only, *not* recommended approaches)

operator(()ident(use-modules) operator(()ident(srfi) ident(srfi-1)operator(\))operator(\))

operator(()keyword(define) ident(*list*) operator(')operator(()integer(1) integer(2) integer(3) integer(1) integer(2) integer(7) integer(8) integer(1) integer(8) integer(2) integer(1) integer(3)operator(\))operator(\))
operator(()keyword(define) ident(*seen*) operator(')operator(()operator(\))operator(\))

comment(; Use hash to filter out unique items)
operator(()ident(for-each)
  operator(()keyword(lambda) operator(()ident(item)operator(\))
    operator(()keyword(if) operator(()ident(not) operator(()ident(assoc-ref) ident(*seen*) ident(item)operator(\))operator(\))
      operator(()keyword(set!) ident(*seen*) operator(()ident(assoc-set!) ident(*seen*) ident(item) predefined_constant(#t)operator(\))operator(\))operator(\))operator(\))
  ident(*list*)operator(\))

comment(; Generate list of unique items)
operator(()keyword(define) ident(*uniq*)
  operator(()ident(fold-right)
    operator(()keyword(lambda) operator(()ident(pair) ident(accum)operator(\)) operator(()keyword(cons) operator(()ident(car) ident(pair)operator(\)) ident(accum)operator(\))operator(\))
    operator(')operator(()operator(\))
    ident(*seen*)operator(\))operator(\))

comment(;; ------------)

operator(()keyword(define) ident(*list*) operator(')operator(()integer(1) integer(2) integer(3) integer(1) integer(2) integer(7) integer(8) integer(1) integer(8) integer(2) integer(1) integer(3)operator(\))operator(\))
operator(()keyword(define) ident(*seen*) operator(')operator(()operator(\))operator(\))

comment(; Build list of unique items by checking set membership)
operator(()ident(for-each)
  operator(()keyword(lambda) operator(()ident(item)operator(\))
    operator(()keyword(if) operator(()ident(not) operator(()ident(member) ident(item) ident(*seen*)operator(\))operator(\))
      operator(()keyword(set!) ident(*seen*) operator(()keyword(cons) ident(item) ident(*seen*)operator(\))operator(\))operator(\))operator(\))
  ident(*list*)operator(\))

comment(;; ------------)

operator(()keyword(define) ident(*users*)
  operator(()ident(sort)
    operator(()ident(string-split) operator(()ident(qx) string<delimiter(")content(who|cut -d' ' -f1)delimiter(")>operator(\)) char(#\\newline)operator(\))
    ident(string<?)operator(\))operator(\))

operator(()keyword(define) ident(*seen*) operator(')operator(()operator(\))operator(\))

comment(; Build list of unique users by checking set membership)
operator(()ident(for-each)
  operator(()keyword(lambda) operator(()ident(user)operator(\))
    operator(()keyword(if) operator(()ident(not) operator(()ident(member) ident(user) ident(*seen*)operator(\))operator(\))
      operator(()keyword(set!) ident(*seen*) operator(()keyword(cons) ident(item) ident(*seen*)operator(\))operator(\))operator(\))operator(\))
  ident(*list*)operator(\))

comment(;; @@PLEAC@@_4.7)
comment(; All problems in this section involve, at core, set difference)
comment(; operations. Thus, the most compact and straightforward approach is)
comment(; to utilise SRFI-1's 'lset-difference' routine)

operator(()ident(use-modules) operator(()ident(srfi) ident(srfi-1)operator(\))operator(\))

operator(()keyword(define) ident(*a*) operator(')operator(()integer(1) integer(3) integer(5) integer(6) integer(7) integer(8)operator(\))operator(\))
operator(()keyword(define) ident(*b*) operator(')operator(()integer(2) integer(3) integer(5) integer(7) integer(9)operator(\))operator(\))

comment(; *difference* contains elements in *a* but not in *b*: 1 6 8)
operator(()keyword(define) ident(*difference*) operator(()ident(lset-difference) ident(=) ident(*a*) ident(*b*)operator(\))operator(\))

comment(; *difference* contains elements in *b* but not in *a*: 2 9)
operator(()keyword(set!) ident(*difference*) operator(()ident(lset-difference) ident(=) ident(*b*) ident(*a*)operator(\))operator(\))

comment(;; ----------------------------)

comment(;; Perl Cookbook-based example - illustrative only, *not* recommended approaches)

operator(()ident(use-modules) operator(()ident(srfi) ident(srfi-1)operator(\))operator(\))

operator(()keyword(define) ident(*a*) operator(')operator(()integer(1) integer(3) integer(5) integer(6) integer(7) integer(8)operator(\))operator(\))
operator(()keyword(define) ident(*b*) operator(')operator(()integer(2) integer(3) integer(5) integer(7) integer(9)operator(\))operator(\))

operator(()keyword(define) ident(*a-only*) operator(')operator(()operator(\))operator(\))

comment(; Build list of items in *a* but not in *b*)
operator(()ident(for-each)
  operator(()keyword(lambda) operator(()ident(item)operator(\))
    operator(()keyword(if) operator(()ident(not) operator(()ident(member) ident(item) ident(*b*)operator(\))operator(\))
      operator(()keyword(set!) ident(*a-only*) operator(()keyword(cons) ident(item) ident(*a-only*)operator(\))operator(\))operator(\))operator(\))
  ident(*a*)operator(\))

comment(;; @@PLEAC@@_4.8)
comment(; The SRFI-1 'lset-xxx' routines are appropriate here)

operator(()ident(use-modules) operator(()ident(srfi) ident(srfi-1)operator(\))operator(\))

operator(()keyword(define) ident(*a*) operator(')operator(()integer(1) integer(3) integer(5) integer(6) integer(7) integer(8)operator(\))operator(\))
operator(()keyword(define) ident(*b*) operator(')operator(()integer(2) integer(3) integer(5) integer(7) integer(9)operator(\))operator(\))

comment(; Combined elements of *a* and *b* sans duplicates: 1 2 3 5 6 7 8 9)
operator(()keyword(define) ident(*union*) operator(()ident(lset-union) ident(=) ident(*a*) ident(*b*)operator(\))operator(\))

comment(; Elements common to both *a* and *b*: 3 5 7)
operator(()keyword(define) ident(*intersection*) operator(()ident(lset-intersection) ident(=) ident(*a*) ident(*b*)operator(\))operator(\))

comment(; Elements in *a* but not in *b*: 1 6 8)
operator(()keyword(define) ident(*difference*) operator(()ident(lset-difference) ident(=) ident(*a*) ident(*b*)operator(\))operator(\))

comment(;; ----------------------------)

comment(;; Perl Cookbook-based example - illustrative only, *not* recommended approaches)

operator(()ident(use-modules) operator(()ident(srfi) ident(srfi-1)operator(\))operator(\))

operator(()keyword(define) ident(*a*) operator(')operator(()integer(1) integer(3) integer(5) integer(6) integer(7) integer(8)operator(\))operator(\))
operator(()keyword(define) ident(*b*) operator(')operator(()integer(2) integer(3) integer(5) integer(7) integer(9)operator(\))operator(\))

operator(()keyword(define) ident(*union*) operator(')operator(()operator(\))operator(\))
operator(()keyword(define) ident(*isect*) operator(')operator(()operator(\))operator(\))
operator(()keyword(define) ident(*diff*) operator(')operator(()operator(\))operator(\))

comment(;; ------------)

comment(; Union and intersection)
operator(()ident(for-each)
  operator(()keyword(lambda) operator(()ident(item)operator(\)) operator(()keyword(set!) ident(*union*) operator(()ident(assoc-set!) ident(*union*) ident(item) predefined_constant(#t)operator(\))operator(\))operator(\))
  ident(*a*)operator(\))

operator(()ident(for-each)
  operator(()keyword(lambda) operator(()ident(item)operator(\))
    operator(()keyword(if) operator(()ident(assoc-ref) ident(*union*) ident(item)operator(\))
      operator(()keyword(set!) ident(*isect*) operator(()ident(assoc-set!) ident(*isect*) ident(item) predefined_constant(#t)operator(\))operator(\))operator(\))
    operator(()keyword(set!) ident(*union*) operator(()ident(assoc-set!) ident(*union*) ident(item) predefined_constant(#t)operator(\))operator(\))operator(\))
  ident(*b*)operator(\))

comment(; Difference *a* and *b*)
operator(()ident(for-each)
  operator(()keyword(lambda) operator(()ident(item)operator(\))
    operator(()keyword(if) operator(()ident(not) operator(()ident(assoc-ref) ident(*isect*) ident(item)operator(\))operator(\))
      operator(()keyword(set!) ident(*diff*) operator(()ident(assoc-set!) ident(*diff*) ident(item) predefined_constant(#t)operator(\))operator(\))operator(\))operator(\))
  ident(*a*)operator(\))

operator(()keyword(set!) ident(*union*)
  operator(()ident(fold)
    operator(()keyword(lambda) operator(()ident(pair) ident(accum)operator(\)) operator(()keyword(cons) operator(()ident(car) ident(pair)operator(\)) ident(accum)operator(\))operator(\))
    operator(')operator(()operator(\))
    ident(*union*)operator(\))operator(\))

operator(()keyword(set!) ident(*isect*)
  operator(()ident(fold)
    operator(()keyword(lambda) operator(()ident(pair) ident(accum)operator(\)) operator(()keyword(cons) operator(()ident(car) ident(pair)operator(\)) ident(accum)operator(\))operator(\))
    operator(')operator(()operator(\))
    ident(*isect*)operator(\))operator(\))

operator(()keyword(set!) ident(*diff*)
  operator(()ident(fold)
    operator(()keyword(lambda) operator(()ident(pair) ident(accum)operator(\)) operator(()keyword(cons) operator(()ident(car) ident(pair)operator(\)) ident(accum)operator(\))operator(\))
    operator(')operator(()operator(\))
    ident(*diff*)operator(\))operator(\))

operator(()ident(print) string<delimiter(")content(Union count:       )delimiter(")> operator(()ident(length) ident(*union*)operator(\))operator(\))
operator(()ident(print) string<delimiter(")content(Intersection count:)delimiter(")> operator(()ident(length) ident(*isect*)operator(\))operator(\))
operator(()ident(print) string<delimiter(")content(Difference count:  )delimiter(")> operator(()ident(length) ident(*diff*)operator(\))operator(\))

comment(;; @@PLEAC@@_4.9)
comment(; Arrays, specifically vectors in the current context, are fixed-size)
comment(; entities; joining several such together requires copying of their)
comment(; contents into a new, appropriately-sized, array. This task may be)
comment(; performed:)

comment(; * Directly: loop through existing arrays copying elements into a)
comment(;   newly-created array)

operator(()keyword(define) operator(()ident(vector-join) ident(vec) operator(.) ident(rest)operator(\))
  operator(()keyword(let*) operator(()operator(()ident(all-vec) operator(()keyword(cons) ident(vec) ident(rest)operator(\))operator(\))
         operator(()ident(new-vec-len) operator(()ident(reduce) ident(+) integer(0) operator(()ident(map) ident(vector-length) ident(all-vec)operator(\))operator(\))operator(\))
         operator(()ident(new-vec) operator(()ident(make-vector) ident(new-vec-len)operator(\))operator(\))
         operator(()ident(new-vec-idx) integer(0)operator(\))operator(\))
    operator(()keyword(let) ident(loop) operator(()operator(()ident(all-vec) ident(all-vec)operator(\))operator(\))
      operator(()keyword(cond)
        operator(()operator(()ident(=) ident(new-vec-idx) ident(new-vec-len)operator(\)) ident(new-vec)operator(\))
        operator(()ident(else)
          operator(()ident(array-for-each)
            operator(()keyword(lambda) operator(()ident(element)operator(\))
              operator(()ident(vector-set!) ident(new-vec) ident(new-vec-idx) ident(element)operator(\))
              operator(()keyword(set!) ident(new-vec-idx) operator(()ident(+) ident(new-vec-idx) integer(1)operator(\))operator(\))operator(\))
            operator(()ident(car) ident(all-vec)operator(\))operator(\))
          operator(()ident(loop) operator(()ident(cdr) ident(all-vec)operator(\))operator(\)) operator(\))operator(\))operator(\)) operator(\))operator(\))

comment(;; ----)

operator(()keyword(define) ident(*array1*) operator(')operator(#()integer(1) integer(2) integer(3)operator(\))operator(\))
operator(()keyword(define) ident(*array2*) operator(')operator(#()integer(4) integer(5) integer(6)operator(\))operator(\))

operator(()keyword(define) ident(*newarray*)
  operator(()ident(vector-join) ident(*array1*) ident(*array2*)operator(\))operator(\))

comment(;; ----------------------------)

comment(; * Indirectly; convert arrays to lists, append the lists, convert)
comment(;   resulting list back into an array)

operator(()keyword(define) ident(*array1*) operator(')operator(#()integer(1) integer(2) integer(3)operator(\))operator(\))
operator(()keyword(define) ident(*array2*) operator(')operator(#()integer(4) integer(5) integer(6)operator(\))operator(\))

operator(()keyword(define) ident(*newarray*)
  operator(()ident(list->vector) operator(()ident(append) operator(()ident(vector->list) ident(*array1*)operator(\)) operator(()ident(vector->list) ident(*array2*)operator(\))operator(\)) operator(\))operator(\))

comment(; Of course if random access is not required, it is probably best to simply)
comment(; use lists since a wealth of list manipulation routines are available)

comment(;; ----------------------------)

comment(; While Perl offers an all-purpose 'splice' routine, a cleaner approach is)
comment(; to separate out such functionality; here three routines are implemented)
comment(; together offering an equivalent to 'splice'. The routines are:)
comment(; * vector-replace! [use with 'vector-copy' to avoid changing original])
comment(;   e.g. (vector-replace! vec ...\))
comment(;        (set! new-vec (vector-replace! (vector-copy vec\) ...\)\))
comment(; * vector-delete)
comment(; * vector-insert)

operator(()keyword(define) operator(()ident(vector-replace!) ident(vec) ident(pos) ident(item) operator(.) ident(rest)operator(\))
  operator(()keyword(let*) operator(()operator(()ident(all-items) operator(()keyword(cons) ident(item) ident(rest)operator(\))operator(\))
         operator(()ident(pos) operator(()keyword(if) operator(()ident(<) ident(pos) integer(0)operator(\)) operator(()ident(+) operator(()ident(vector-length) ident(vec)operator(\)) ident(pos)operator(\)) ident(pos)operator(\))operator(\))
         operator(()ident(in-bounds)
           operator(()ident(not) operator(()ident(>) operator(()ident(+) ident(pos) operator(()ident(length) ident(all-items)operator(\))operator(\)) operator(()ident(vector-length) ident(vec)operator(\))operator(\))operator(\))operator(\))operator(\))
    operator(()keyword(if) ident(in-bounds)
      operator(()keyword(let) ident(loop) operator(()operator(()ident(i) ident(pos)operator(\)) operator(()ident(all-items) ident(all-items)operator(\))operator(\))
        operator(()keyword(cond)
          operator(()operator(()ident(null?) ident(all-items)operator(\)) ident(vec)operator(\))
          operator(()ident(else)
            operator(()ident(vector-set!) ident(vec) ident(i) operator(()ident(car) ident(all-items)operator(\))operator(\))
            operator(()ident(loop) operator(()ident(+) ident(i) integer(1)operator(\)) operator(()ident(cdr) ident(all-items)operator(\))operator(\))operator(\)) operator(\))operator(\))
    comment(;else)
      ident(vec)operator(\))operator(\))operator(\))

operator(()keyword(define) operator(()ident(vector-delete) ident(vec) ident(pos) ident(len)operator(\))
  operator(()keyword(let*) operator(()operator(()ident(new-vec-len) operator(()ident(-) operator(()ident(vector-length) ident(vec)operator(\)) ident(len)operator(\))operator(\))
         operator(()ident(new-vec) predefined_constant(#f)operator(\))
         operator(()ident(pos) operator(()keyword(if) operator(()ident(<) ident(pos) integer(0)operator(\)) operator(()ident(+) operator(()ident(vector-length) ident(vec)operator(\)) ident(pos)operator(\)) ident(pos)operator(\))operator(\))operator(\))
    operator(()keyword(cond)
      operator(()operator(()ident(<) ident(new-vec-len) integer(0)operator(\)) ident(vec)operator(\))
      operator(()ident(else)
        operator(()keyword(set!) ident(new-vec) operator(()ident(make-vector) ident(new-vec-len)operator(\))operator(\))
        operator(()keyword(let) ident(loop) operator(()operator(()ident(vec-idx) integer(0)operator(\)) operator(()ident(new-vec-idx) integer(0)operator(\))operator(\))
          operator(()keyword(cond)
            operator(()operator(()ident(=) ident(new-vec-idx) ident(new-vec-len)operator(\)) ident(new-vec)operator(\))
            operator(()ident(else)
              operator(()keyword(if) operator(()ident(=) ident(vec-idx) ident(pos)operator(\)) operator(()keyword(set!) ident(vec-idx) operator(()ident(+) ident(vec-idx) ident(len)operator(\))operator(\))operator(\))
              operator(()ident(vector-set!) ident(new-vec) ident(new-vec-idx) operator(()ident(vector-ref) ident(vec) ident(vec-idx)operator(\))operator(\))
              operator(()ident(loop) operator(()ident(+) ident(vec-idx) integer(1)operator(\)) operator(()ident(+) ident(new-vec-idx) integer(1)operator(\))operator(\)) operator(\))operator(\))operator(\)) operator(\))operator(\)) operator(\))operator(\))

comment(; This routine would probably benefit from having 'cmd' implemented as a keyword)
comment(; argument. However, 'cmd' implemented as a positional to keep example simple)
operator(()keyword(define) operator(()ident(vector-insert) ident(vec) ident(pos) ident(cmd) ident(item) operator(.) ident(rest)operator(\))
  operator(()keyword(let*) operator(()operator(()ident(all-item-vec) operator(()ident(list->array) integer(1) operator(()keyword(cons) ident(item) ident(rest)operator(\))operator(\))operator(\))
         operator(()ident(all-item-vec-len) operator(()ident(vector-length) ident(all-item-vec)operator(\))operator(\))
         operator(()ident(vec-len) operator(()ident(vector-length) ident(vec)operator(\))operator(\))
         operator(()ident(new-vec) operator(()ident(make-vector) operator(()ident(+) ident(vec-len) ident(all-item-vec-len)operator(\))operator(\))operator(\))
         operator(()ident(pos) operator(()keyword(if) operator(()ident(<) ident(pos) integer(0)operator(\)) operator(()ident(+) operator(()ident(vector-length) ident(vec)operator(\)) ident(pos)operator(\)) ident(pos)operator(\))operator(\))operator(\))
    operator(()keyword(if) operator(()ident(eq?) ident(cmd) operator(')ident(after)operator(\)) operator(()keyword(set!) ident(pos) operator(()ident(+) ident(pos) integer(1)operator(\))operator(\))operator(\))
    operator(()ident(vector-move-left!) ident(vec) integer(0) ident(pos) ident(new-vec) integer(0)operator(\))
    operator(()ident(vector-move-left!) ident(all-item-vec) integer(0) ident(all-item-vec-len) ident(new-vec) ident(pos)operator(\))
    operator(()ident(vector-move-left!) ident(vec) ident(pos) ident(vec-len) ident(new-vec) operator(()ident(+) ident(pos) ident(all-item-vec-len)operator(\))operator(\))
    ident(new-vec)operator(\))operator(\))

comment(;; ----)

operator(()keyword(define) ident(*members*) operator(')operator(#()string<delimiter(")content(Time)delimiter(")> string<delimiter(")content(Flies)delimiter(")>operator(\))operator(\))
operator(()keyword(define) ident(*initiates*) operator(')operator(#()string<delimiter(")content(An)delimiter(")> string<delimiter(")content(Arrow)delimiter(")>operator(\))operator(\))

operator(()keyword(set!) ident(*members*) operator(()ident(vector-join) ident(*members*) ident(*initiates*)operator(\))operator(\))

comment(;; ------------)

operator(()keyword(set!) ident(*members*) operator(()ident(vector-insert) ident(*members*) integer(1) operator(')ident(after) string<delimiter(")content(Like)delimiter(")> ident(*initiates*)operator(\))operator(\))
operator(()ident(print) ident(*members*)operator(\))

operator(()keyword(set!) ident(*members*) operator(()ident(vector-replace) ident(*members*) integer(0) string<delimiter(")content(Fruit)delimiter(")>operator(\))operator(\))
operator(()keyword(set!) ident(*members*) operator(()ident(vector-replace) ident(*members*) ident(-)integer(2) string<delimiter(")content(A)delimiter(")> string<delimiter(")content(Banana)delimiter(")>operator(\))operator(\))
operator(()ident(print) ident(*members*)operator(\))

comment(; was: '#("Time" "Flies" "An" "Arrow"\))
comment(; now: '#("Fruit" "Flies" "Like" "A" "Banana"\))

comment(;; @@PLEAC@@_4.10)
comment(; As for appending arrays, there is the choice of iterating through)
comment(; the array:)
operator(()keyword(define) operator(()ident(vector-reverse!) ident(vec)operator(\))
  operator(()keyword(let) ident(loop) operator(()operator(()ident(i) integer(0)operator(\)) operator(()ident(j) operator(()ident(-) operator(()ident(vector-length) ident(vec)operator(\)) integer(1)operator(\))operator(\))operator(\))
    operator(()keyword(cond)
      operator(()operator(()ident(>=) ident(i) ident(j)operator(\)) ident(vec)operator(\))
      operator(()ident(else)
        operator(()ident(vector-ref-swap!) ident(vec) ident(i) ident(j)operator(\))
        operator(()ident(loop) operator(()ident(+) ident(i) integer(1)operator(\)) operator(()ident(-) ident(j) integer(1)operator(\))operator(\))operator(\))operator(\)) operator(\))operator(\))

comment(;; ------------)

operator(()keyword(define) ident(*array*) operator(')operator(#()integer(1) integer(2) integer(3)operator(\))operator(\))

operator(()ident(vector-reverse!) ident(*array*)operator(\))

comment(;; ------------)

operator(()keyword(define) ident(*array*) operator(')operator(#()integer(1) integer(2) integer(3)operator(\))operator(\))

operator(()keyword(do) operator(()operator(()ident(i) operator(()ident(-) operator(()ident(vector-length) ident(*array*)operator(\)) integer(1)operator(\)) operator(()ident(-) ident(i) integer(1)operator(\))operator(\))operator(\))
    operator(()operator(()ident(<) ident(i) integer(0)operator(\))operator(\))
  ident(...) keyword(do) ident(something) ident(with) ident(*array*) ident(...)operator(\))

comment(;; ----------------------------)

comment(; or of converting to / from a list, performing any manipulation using)
comment(; the list routines)

operator(()keyword(define) ident(*array*) operator(')operator(#()integer(1) integer(2) integer(3)operator(\))operator(\))

operator(()keyword(define) ident(*newarray*)
  operator(()ident(list->vector) operator(()ident(reverse) operator(()ident(sort) operator(()ident(vector->list) ident(*array*)operator(\)) ident(<)operator(\))operator(\)) operator(\))operator(\))

comment(;; @@PLEAC@@_4.11)
operator(()keyword(define) ident(*array*) operator(')operator(#()integer(1) integer(2) integer(3) integer(4) integer(5) integer(6) integer(7) integer(8)operator(\))operator(\))

comment(;; ------------)

comment(; Remove first 3 elements)
operator(()keyword(define) ident(*front*) operator(()ident(vector-delete) ident(*array*) integer(0) integer(3)operator(\))operator(\))

comment(; Remove last 3 elements)
operator(()keyword(define) ident(*end*) operator(()ident(vector-delete) ident(*array*) ident(-)integer(1) integer(3)operator(\))operator(\))

comment(;; ----------------------------)

comment(; Another helper routine)
operator(()keyword(define) operator(()ident(vector-slice) ident(vec) ident(pos) ident(len)operator(\))
  operator(()keyword(let*) operator(()operator(()ident(vec-len) operator(()ident(vector-length) ident(vec)operator(\))operator(\))
         operator(()ident(pos) operator(()keyword(if) operator(()ident(<) ident(pos) integer(0)operator(\)) operator(()ident(+) ident(vec-len) ident(pos)operator(\)) ident(pos)operator(\))operator(\))
         operator(()ident(in-bounds)
           operator(()ident(not) operator(()ident(>) operator(()ident(+) ident(pos) ident(len)operator(\)) ident(vec-len)operator(\))operator(\))operator(\))operator(\))
    operator(()keyword(if) ident(in-bounds)
      operator(()keyword(let) operator(()operator(()ident(new-vec) operator(()ident(make-vector) ident(len)operator(\))operator(\))operator(\))
        operator(()keyword(let) ident(loop) operator(()operator(()ident(vec-idx) ident(pos)operator(\)) operator(()ident(new-vec-idx) integer(0)operator(\))operator(\))
          operator(()keyword(cond)
            operator(()operator(()ident(=) ident(new-vec-idx) ident(len)operator(\)) ident(new-vec)operator(\))
            operator(()ident(else)
              operator(()ident(vector-set!) ident(new-vec) ident(new-vec-idx) operator(()ident(vector-ref) ident(vec) ident(vec-idx)operator(\))operator(\))
              operator(()ident(loop) operator(()ident(+) ident(vec-idx) integer(1)operator(\)) operator(()ident(+) ident(new-vec-idx) integer(1)operator(\))operator(\))operator(\)) operator(\))operator(\))operator(\))
    comment(;else)
      ident(vec)operator(\))operator(\))operator(\))

comment(; Both the following use, 'values', to return two values; this approach)
comment(; is quite contrived and is taken to mimic the Perl examples, not)
comment(; because it is a recommended one [returning a single list would probably)
comment(; be more sensible])
operator(()keyword(define) operator(()ident(shift2) ident(vec)operator(\))
  operator(()keyword(let) operator(()operator(()ident(vec) operator(()ident(vector-slice) ident(vec) integer(0) integer(2)operator(\))operator(\))operator(\))
    operator(()ident(values) operator(()ident(vector-ref) ident(vec) integer(0)operator(\)) operator(()ident(vector-ref) ident(vec) integer(1)operator(\))operator(\)) operator(\))operator(\))

operator(()keyword(define) operator(()ident(pop2) ident(vec)operator(\))
  operator(()keyword(let) operator(()operator(()ident(vec) operator(()ident(vector-slice) ident(vec) ident(-)integer(1) integer(2)operator(\))operator(\))operator(\))
    operator(()ident(values) operator(()ident(vector-ref) ident(vec) integer(0)operator(\)) operator(()ident(vector-ref) ident(vec) integer(1)operator(\))operator(\)) operator(\))operator(\))

comment(;; ------------)

operator(()keyword(define) ident(*friends*) operator(')operator(#()operator(')ident(Peter) operator(')ident(Paul) operator(')ident(Mary) operator(')ident(Jim) operator(')ident(Tim)operator(\))operator(\))

operator(()ident(let-values) operator(() operator(()operator(()ident(this) ident(that)operator(\)) operator(()ident(shift2) ident(*friends*)operator(\))operator(\)) operator(\))
  operator(()ident(print) ident(this) string<delimiter(")content(:)delimiter(")> ident(that)operator(\))operator(\))

comment(;; ------------)

operator(()keyword(define) ident(*beverages*) operator(')operator(#()operator(')ident(Dew) operator(')ident(Jolt) operator(')ident(Cola) operator(')ident(Sprite) operator(')ident(Fresca)operator(\))operator(\))

operator(()ident(let-values) operator(() operator(()operator(()ident(d1) ident(d2)operator(\)) operator(()ident(pop2) ident(*beverages*)operator(\))operator(\)) operator(\))
  operator(()ident(print) ident(d1) string<delimiter(")content(:)delimiter(")> ident(d2)operator(\))operator(\))

comment(;; @@PLEAC@@_4.12)
comment(; SRFI-1 [list manipulation] routines are ideal for the types of task)
comment(; in this and the next section, in particular, 'for-each' and 'find',)
comment(; 'list-index', and many others for more specialist functions. The same)
comment(; applies to vectors with the SRFI-43 routines, 'vector-index' and)
comment(; 'vector-skip', though the approach taken in this chapter has been to)
comment(; implement functionally similar vector manipulation routines to more)
comment(; closely mimic the Perl examples)

comment(; Return #f, or first index for which 'pred' returns true)
operator(()keyword(define) operator(()ident(vector-first-idx) ident(pred) ident(vec)operator(\)) 
  operator(()keyword(let) operator(()operator(()ident(vec-len) operator(()ident(vector-length) ident(vec)operator(\))operator(\))operator(\))
    operator(()keyword(let) ident(loop) operator(()operator(()ident(idx) integer(0)operator(\))operator(\))
      operator(()keyword(cond)
        operator(()operator(()ident(=) ident(idx) ident(vec-len)operator(\)) predefined_constant(#f)operator(\))
        operator(()ident(else)
          operator(()keyword(if) operator(()ident(pred) operator(()ident(vector-ref) ident(vec) ident(idx)operator(\))operator(\))
            ident(idx)
          comment(;else)
            operator(()ident(loop) operator(()ident(+) ident(idx) integer(1)operator(\))operator(\))operator(\)) operator(\))operator(\))operator(\))operator(\))operator(\))

comment(; Return #f, or first index for which 'pred' returns true)
operator(()keyword(define) operator(()ident(list-first-idx) ident(pred) ident(list)operator(\))
  operator(()keyword(let) ident(loop) operator(()operator(()ident(idx) integer(0)operator(\)) operator(()ident(list) ident(list)operator(\))operator(\))
    operator(()keyword(cond)
      operator(()operator(()ident(null?) ident(list)operator(\)) predefined_constant(#f)operator(\))
      operator(()ident(else)
        operator(()keyword(if) operator(()ident(pred) operator(()ident(car) ident(list)operator(\))operator(\))
          ident(idx)
        comment(;else)
          operator(()ident(loop) operator(()ident(+) ident(idx) integer(1)operator(\)) operator(()ident(cdr) ident(list)operator(\))operator(\))operator(\)) operator(\))operator(\))operator(\))operator(\))

comment(;; ------------)

operator(()keyword(define) ident(*array*) operator(')operator(#()integer(1) integer(2) integer(3) integer(4) integer(5) integer(6) integer(7) integer(8)operator(\))operator(\))

operator(()ident(print)
  operator(()ident(vector-first-idx)
    operator(()keyword(lambda) operator(()ident(x)operator(\)) operator(()ident(=) ident(x) integer(9)operator(\))operator(\))
    ident(*array*)operator(\))operator(\))

comment(;; ----)

operator(()keyword(define) ident(*list*) operator(')operator(()integer(1) integer(2) integer(3) integer(4) integer(5) integer(6) integer(7) integer(8)operator(\))operator(\))

operator(()ident(print)
  operator(()ident(list-first-idx)
    operator(()keyword(lambda) operator(()ident(x)operator(\)) operator(()ident(=) ident(x) integer(4)operator(\))operator(\))
    ident(*list*)operator(\))operator(\))

comment(;; ----)

operator(()ident(use-modules) operator(()ident(srfi) ident(srfi-1)operator(\))operator(\))

operator(()ident(print)
  operator(()ident(list-index)
    operator(()keyword(lambda) operator(()ident(x)operator(\)) operator(()ident(=) ident(x) integer(4)operator(\))operator(\))
    ident(*list*)operator(\))operator(\))

comment(;; ----------------------------)

comment(; The Perl 'highest paid engineer' example isn't really a 'first match')
comment(; type of problem - the routines shown earlier really aren't suited to)
comment(; this. Better suited, instead, are the SRFI-1 routines like 'fold',)
comment(; 'fold-right' and 'reduce', even old standbys like 'filter' and 'for-each')

operator(()keyword(define) ident(+)ident(null-salary-rec+)
  operator(()ident(list) operator(')operator(()operator(\)) integer(0) operator(')operator(()operator(\))operator(\))operator(\))

operator(()keyword(define) ident(*salaries*)
  operator(()ident(list)
    operator(()ident(list) operator(')ident(engineer) integer(43000) operator(')ident(Bob)operator(\))
    operator(()ident(list) operator(')ident(programmer) integer(48000) operator(')ident(Andy)operator(\))
    operator(()ident(list) operator(')ident(engineer) integer(35000) operator(')ident(Champ)operator(\)) 
    operator(()ident(list) operator(')ident(engineer) integer(49000) operator(')ident(Bubbles)operator(\))
    operator(()ident(list) operator(')ident(programmer) integer(47000) operator(')ident(Twig)operator(\))
    operator(()ident(list) operator(')ident(engineer) integer(34000) operator(')ident(Axel)operator(\)) operator(\))operator(\))

comment(;; ----------------------------)

operator(()keyword(define) ident(*highest-paid-engineer*)
  operator(()ident(reduce)
    operator(()keyword(lambda) operator(()ident(salary-rec) ident(acc)operator(\))
      operator(()keyword(if)
        operator(()keyword(and)
          operator(()ident(eq?) operator(()ident(car) ident(salary-rec)operator(\)) operator(')ident(engineer)operator(\))
          operator(()ident(>) operator(()ident(cadr) ident(salary-rec)operator(\)) operator(()ident(cadr) ident(acc)operator(\))operator(\))operator(\))
        ident(salary-rec)
      comment(;else)
        ident(acc)operator(\))operator(\))
    ident(+)ident(null-salary-rec+)
    ident(*salaries*)operator(\))operator(\))

operator(()ident(print) ident(*highest-paid-engineer*)operator(\))

comment(;; ------------)

operator(()keyword(define) ident(*highest-paid-engineer*)
  operator(()ident(fold-right)
    operator(()keyword(lambda) operator(()ident(salary-rec) ident(acc)operator(\))
      operator(()keyword(if) operator(()ident(>) operator(()ident(cadr) ident(salary-rec)operator(\)) operator(()ident(cadr) ident(acc)operator(\))operator(\))
        ident(salary-rec)
      comment(;else)
        ident(acc)operator(\))operator(\))
    ident(+)ident(null-salary-rec+)
    operator(()ident(filter)
      operator(()keyword(lambda) operator(()ident(salary-rec)operator(\))
        operator(()ident(eq?) operator(()ident(car) ident(salary-rec)operator(\)) operator(')ident(engineer)operator(\))operator(\))
      ident(*salaries*)operator(\))operator(\)) operator(\))

operator(()ident(print) ident(*highest-paid-engineer*)operator(\))

comment(;; ------------)

operator(()keyword(define) ident(*highest-paid-engineer*) ident(+)ident(null-salary-rec+)operator(\))

operator(()ident(for-each)
  operator(()keyword(lambda) operator(()ident(salary-rec)operator(\))
    operator(()keyword(if)
      operator(()keyword(and)
        operator(()ident(eq?) operator(()ident(car) ident(salary-rec)operator(\)) operator(')ident(engineer)operator(\))
        operator(()ident(>) operator(()ident(cadr) ident(salary-rec)operator(\)) operator(()ident(cadr) ident(*highest-paid-engineer*)operator(\))operator(\))operator(\))
      operator(()keyword(set!) ident(*highest-paid-engineer*) ident(salary-rec)operator(\))operator(\))operator(\))
  ident(*salaries*)operator(\))

operator(()ident(print) ident(*highest-paid-engineer*)operator(\))

comment(;; @@PLEAC@@_4.13)
comment(; All tasks in this section consist of either generating a collection,)
comment(; or filtering a larger collection, of elements matching some criteria;)
comment(; obvious candidates are the 'filter' and 'array-filter' routines, though)
comment(; others like 'for-each' can also be applied)

operator(()keyword(define) ident(*list-matching*) operator(()ident(filter) ident(PRED) ident(LIST)operator(\))operator(\))
operator(()keyword(define) ident(*vector-matching*) operator(()ident(array-filter) ident(PRED) ident(ARRAY)operator(\))operator(\))

comment(;; ----------------------------)

operator(()keyword(define) ident(*nums*) operator(')operator(()integer(1e7) integer(3e7) integer(2e7) integer(4e7) integer(1e7) integer(3e7) integer(2e7) integer(4e7)operator(\))operator(\))

operator(()keyword(define) ident(*bigs*) 
  operator(()ident(filter)
    operator(()keyword(lambda) operator(()ident(num)operator(\)) operator(()ident(>) ident(num) integer(1000000)operator(\))operator(\))
    ident(*nums*)operator(\))operator(\))

comment(;; ------------)

operator(()keyword(define) ident(*users*)
  operator(()ident(list)
    operator(')operator(()ident(u1) operator(.) integer(2e7)operator(\))
    operator(')operator(()ident(u2) operator(.) integer(1e7)operator(\))
    operator(')operator(()ident(u3) operator(.) integer(4e7)operator(\))
    operator(')operator(()ident(u4) operator(.) integer(3e7)operator(\)) operator(\))operator(\))

operator(()keyword(define) ident(*pigs*)
  operator(()ident(fold-right)
    operator(()keyword(lambda) operator(()ident(pair) ident(accum)operator(\)) operator(()keyword(cons) operator(()ident(car) ident(pair)operator(\)) ident(accum)operator(\))operator(\))
    operator(')operator(()operator(\))
    operator(()ident(filter)
      operator(()keyword(lambda) operator(()ident(pair)operator(\)) operator(()ident(>) operator(()ident(cdr) ident(pair)operator(\)) integer(1e7)operator(\))operator(\))
      ident(*users*)operator(\))operator(\))operator(\))

operator(()ident(print) ident(*pigs*)operator(\))

comment(;; ------------)

operator(()keyword(define) ident(*salaries*)
  operator(()ident(list)
    operator(()ident(list) operator(')ident(engineer) integer(43000) operator(')ident(Bob)operator(\))
    operator(()ident(list) operator(')ident(programmer) integer(48000) operator(')ident(Andy)operator(\))
    operator(()ident(list) operator(')ident(engineer) integer(35000) operator(')ident(Champ)operator(\)) 
    operator(()ident(list) operator(')ident(engineer) integer(49000) operator(')ident(Bubbles)operator(\))
    operator(()ident(list) operator(')ident(programmer) integer(47000) operator(')ident(Twig)operator(\))
    operator(()ident(list) operator(')ident(engineer) integer(34000) operator(')ident(Axel)operator(\)) operator(\))operator(\))

operator(()keyword(define) ident(*engineers*)
  operator(()ident(filter)
    operator(()keyword(lambda) operator(()ident(salary-rec)operator(\))
      operator(()ident(eq?) operator(()ident(car) ident(salary-rec)operator(\)) operator(')ident(engineer)operator(\))operator(\))
    ident(*salaries*)operator(\))operator(\))

operator(()ident(print) ident(*engineers*)operator(\))

comment(;; ------------)

operator(()keyword(define) ident(*applicants*)
  operator(()ident(list)
    operator(()ident(list) operator(')ident(a1) integer(26000) operator(')ident(Bob)operator(\))
    operator(()ident(list) operator(')ident(a2) integer(28000) operator(')ident(Andy)operator(\))
    operator(()ident(list) operator(')ident(a3) integer(24000) operator(')ident(Candy)operator(\)) operator(\))operator(\))

operator(()keyword(define) ident(*secondary-assistance*)
  operator(()ident(filter)
    operator(()keyword(lambda) operator(()ident(salary-rec)operator(\))
      operator(()keyword(and)
        operator(()ident(>) operator(()ident(cadr) ident(salary-rec)operator(\)) integer(26000)operator(\))
        operator(()ident(<) operator(()ident(cadr) ident(salary-rec)operator(\)) integer(30000)operator(\))operator(\))operator(\))
    ident(*applicants*)operator(\))operator(\))

operator(()ident(print) ident(*secondary-assistance*)operator(\))

comment(;; @@PLEAC@@_4.14)
comment(; Sorting numeric data in Scheme is very straightforward ...)

operator(()keyword(define) ident(*unsorted*) operator(')operator(()integer(5) integer(8) integer(1) integer(7) integer(4) integer(2) integer(3) integer(6)operator(\))operator(\)) 

comment(;; ------------)

comment(; Ascending sort - use '<' as comparator)
operator(()keyword(define) ident(*sorted*) 
  operator(()ident(sort)
    ident(*unsorted*)
    ident(<)operator(\))operator(\))

operator(()ident(print) ident(*sorted*)operator(\))

comment(;; ------------)

comment(; Descending sort - use '>' as comparator)
operator(()keyword(define) ident(*sorted*) 
  operator(()ident(sort)
    ident(*unsorted*)
    ident(>)operator(\))operator(\))

operator(()ident(print) ident(*sorted*)operator(\))

comment(;; @@PLEAC@@_4.15)
comment(; A customised lambda may be passed as comparator to 'sort', so)
comment(; sorting on one or more 'fields' is quite straightforward)

operator(()keyword(define) ident(*unordered*) operator(')operator(() ident(...) operator(\))operator(\))

comment(; COMPARE is some comparator suited for the element type being)
comment(; sorted)
operator(()keyword(define) ident(*ordered*)
  operator(()ident(sort)
    ident(*unordered*)
    operator(()keyword(lambda) operator(()ident(left) ident(right)operator(\))
      operator(()ident(COMPARE) ident(left) ident(right)operator(\))operator(\))operator(\))operator(\))

comment(;; ------------)

operator(()keyword(define) ident(*unordered*)
  operator(()ident(list)
    operator(()keyword(cons) operator(')ident(s) integer(34)operator(\))
    operator(()keyword(cons) operator(')ident(e) integer(12)operator(\))
    operator(()keyword(cons) operator(')ident(c) integer(45)operator(\))
    operator(()keyword(cons) operator(')ident(q) integer(11)operator(\))
    operator(()keyword(cons) operator(')ident(g) integer(24)operator(\)) operator(\))operator(\))

operator(()keyword(define) ident(*pre-computed*)
  operator(()ident(map)
    comment(; Here element is returned unaltered, but it would normally be)
    comment(; transformed in som way)
    operator(()keyword(lambda) operator(()ident(element)operator(\)) ident(element)operator(\))
    ident(*unordered*)operator(\))operator(\))

operator(()keyword(define) ident(*ordered-pre-computed*)
  operator(()ident(sort)
    ident(*pre-computed*)
    comment(; Sort on the first field [assume it is the 'key'] )
    operator(()keyword(lambda) operator(()ident(left) ident(right)operator(\))
      operator(()ident(string<?)
        operator(()ident(symbol->string) operator(()ident(car) ident(left)operator(\))operator(\))
        operator(()ident(symbol->string) operator(()ident(car) ident(right)operator(\))operator(\))operator(\))operator(\))operator(\))operator(\))

comment(; Extract the second field [assume it is the 'value'])
operator(()keyword(define) ident(*ordered*)
  operator(()ident(map) 
    operator(()keyword(lambda) operator(()ident(element)operator(\)) operator(()ident(cdr) ident(element)operator(\))operator(\))
    ident(*ordered-pre-computed*)operator(\))operator(\))

comment(;; ----------------------------)

operator(()keyword(define) ident(*employees*)
  operator(()ident(list)
    operator(()ident(list) operator(')ident(Bob) integer(43000) integer(123) integer(42)operator(\))
    operator(()ident(list) operator(')ident(Andy) integer(48000) integer(124) integer(35)operator(\))
    operator(()ident(list) operator(')ident(Champ) integer(35000) integer(125) integer(37)operator(\)) 
    operator(()ident(list) operator(')ident(Bubbles) integer(49000) integer(126) integer(34)operator(\))
    operator(()ident(list) operator(')ident(Twig) integer(47000) integer(127) integer(36)operator(\))
    operator(()ident(list) operator(')ident(Axel) integer(34000) integer(128) integer(31)operator(\)) operator(\))operator(\))

operator(()keyword(define) ident(*ordered*)
  operator(()ident(sort)
    ident(*employees*)
    operator(()keyword(lambda) operator(()ident(left) ident(right)operator(\))
      operator(()ident(string<?)
        operator(()ident(symbol->string) operator(()ident(car) ident(left)operator(\))operator(\))
        operator(()ident(symbol->string) operator(()ident(car) ident(right)operator(\))operator(\))operator(\))operator(\))operator(\))operator(\))

comment(;; ------------)

operator(()ident(for-each)
  operator(()keyword(lambda) operator(()ident(employee)operator(\))
    operator(()ident(print) operator(()ident(car) ident(employee)operator(\)) string<delimiter(")content(earns $)delimiter(")> operator(()ident(cadr) ident(employee)operator(\))operator(\))operator(\))
  operator(()ident(sort)
    ident(*employees*)
    operator(()keyword(lambda) operator(()ident(left) ident(right)operator(\))
      operator(()ident(string<?)
        operator(()ident(symbol->string) operator(()ident(car) ident(left)operator(\))operator(\))
        operator(()ident(symbol->string) operator(()ident(car) ident(right)operator(\))operator(\))operator(\))operator(\))operator(\))operator(\))

comment(;; ------------)

operator(()keyword(define) ident(*bonus*)
  operator(()ident(list)
    operator(')operator(()integer(125) operator(.) integer(1000)operator(\))
    operator(')operator(()integer(127) operator(.) integer(1500)operator(\)) operator(\))operator(\))

operator(()ident(for-each)
  operator(()keyword(lambda) operator(()ident(employee)operator(\))
    operator(()keyword(let) operator(()operator(()ident(bonus) operator(()ident(assoc-ref) ident(*bonus*) operator(()ident(caddr) ident(employee)operator(\))operator(\))operator(\))operator(\))
      operator(()keyword(if) operator(()ident(not) ident(bonus)operator(\))
        operator(')operator(()operator(\))
      comment(;else)
        operator(()ident(print) operator(()ident(car) ident(employee)operator(\)) string<delimiter(")content(earned bonus)delimiter(")> ident(bonus)operator(\)) operator(\))operator(\))operator(\))
  operator(()ident(sort)
    ident(*employees*)
    operator(()keyword(lambda) operator(()ident(left) ident(right)operator(\))
      operator(()ident(string<?)
        operator(()ident(symbol->string) operator(()ident(car) ident(left)operator(\))operator(\))
        operator(()ident(symbol->string) operator(()ident(car) ident(right)operator(\))operator(\))operator(\))operator(\))operator(\))operator(\))

comment(;; ----------------------------)

operator(()ident(use-modules) operator(()ident(srfi) ident(srfi-1)operator(\)) operator(()ident(ice-9) ident(rdelim)operator(\)) operator(()ident(ice-9) ident(regex)operator(\))operator(\))

operator(()keyword(define) ident(*filename*) string<delimiter(")content(/etc/passwd)delimiter(")>operator(\))
operator(()keyword(define) ident(*users*) operator(')operator(()operator(\))operator(\))

operator(()keyword(let) operator(()operator(()ident(port) operator(()ident(open-input-file) ident(*filename*)operator(\))operator(\))operator(\))
  operator(()keyword(let) ident(loop) operator(()operator(()ident(line&terminator) operator(()ident(read-line) ident(port) operator(')ident(split)operator(\))operator(\))operator(\))
    operator(()keyword(cond)
      operator(()operator(()ident(eof-object?) operator(()ident(cdr) ident(line&terminator)operator(\))operator(\)) operator(')operator(()operator(\))operator(\))
      operator(()ident(else)
        operator(()keyword(set!) ident(*users*)
          operator(()ident(assoc-set!)
            ident(*users*)
            operator(()ident(car) operator(()ident(string-split) operator(()ident(car) ident(line&terminator)operator(\)) char(#\\:)operator(\))operator(\))
            predefined_constant(#t)operator(\))operator(\))
        operator(()ident(loop) operator(()ident(read-line) ident(port) operator(')ident(split)operator(\))operator(\)) operator(\))operator(\))operator(\)) 
  operator(()ident(close-input-port) ident(port)operator(\))operator(\))

operator(()ident(for-each)
  operator(()keyword(lambda) operator(()ident(user)operator(\)) operator(()ident(print) operator(()ident(car) ident(user)operator(\))operator(\))operator(\))
  operator(()ident(sort)
    ident(*users*)
    operator(()keyword(lambda) operator(()ident(left) ident(right)operator(\))
      operator(()ident(string<?)
        operator(()ident(car) ident(left)operator(\))
        operator(()ident(car) ident(right)operator(\))operator(\))operator(\))operator(\))operator(\))

comment(;; @@PLEAC@@_4.16)
comment(; Use SRFI-1's 'circular-list' routine to build a circular list)
operator(()ident(use-modules) operator(()ident(srfi) ident(srfi-1)operator(\))operator(\))

operator(()keyword(define) ident(*processes*) operator(()ident(circular-list) integer(1) integer(2) integer(3) integer(4) integer(5)operator(\))operator(\))

operator(()keyword(let) ident(loop) operator(()operator(()ident(processes) ident(*processes*)operator(\))operator(\))
  operator(()ident(print) string<delimiter(")content(Handling process)delimiter(")> operator(()ident(car) ident(processes)operator(\))operator(\))
  operator(()ident(sleep) integer(1)operator(\))
  operator(()ident(loop) operator(()ident(cdr) ident(processes)operator(\))operator(\))operator(\))

comment(;; @@PLEAC@@_4.17)
operator(()ident(use-modules) operator(()ident(srfi) ident(srfi-1)operator(\))operator(\))

comment(; Implements Fischer-Yates shuffle algorithm)
operator(()keyword(define) operator(()ident(vector-shuffle!) ident(vec)operator(\))
  operator(()keyword(let) operator(()operator(()ident(vector-length) operator(()ident(vector-length) ident(vec)operator(\))operator(\))operator(\))
    operator(()keyword(let) ident(loop) operator(()operator(()ident(i) ident(vector-length)operator(\)) operator(()ident(j) operator(()ident(+) integer(1) operator(()ident(random) ident(vector-length)operator(\))operator(\))operator(\))operator(\))
      operator(()keyword(cond)
        operator(()operator(()ident(=) ident(i) integer(1)operator(\)) operator(')operator(()operator(\))operator(\))
        operator(()operator(()ident(not) operator(()ident(=) ident(i) ident(j)operator(\))operator(\))
          operator(()ident(vector-ref-swap!) ident(vec) operator(()ident(-) ident(i) integer(1)operator(\)) operator(()ident(-) ident(j) integer(1)operator(\))operator(\))
          operator(()ident(loop) operator(()ident(-) ident(i) integer(1)operator(\)) operator(()ident(+) integer(1) operator(()ident(random) operator(()ident(-) ident(i) integer(1)operator(\))operator(\))operator(\))operator(\))operator(\))
        operator(()ident(else)
          operator(()ident(loop) operator(()ident(-) ident(i) integer(1)operator(\)) operator(()ident(+) integer(1) operator(()ident(random) operator(()ident(-) ident(i) integer(1)operator(\))operator(\))operator(\))operator(\))operator(\)) operator(\))operator(\))operator(\))operator(\))

operator(()keyword(define) operator(()ident(vector-ref-swap!) ident(vec) ident(idx1) ident(idx2)operator(\))
  operator(()keyword(let) operator(()operator(()ident(tmp) operator(()ident(vector-ref) ident(vec) ident(idx1)operator(\))operator(\))operator(\))
    operator(()ident(vector-set!) ident(vec) ident(idx1) operator(()ident(vector-ref) ident(vec) ident(idx2)operator(\))operator(\))
    operator(()ident(vector-set!) ident(vec) ident(idx2) ident(tmp)operator(\))operator(\))operator(\))

comment(; Generate vector of values 1 .. 10)
operator(()keyword(define) ident(*irange*) operator(()ident(list->vector) operator(()ident(iota) integer(10) integer(1) integer(1)operator(\))operator(\))operator(\))

comment(; Shuffle array values)
operator(()ident(vector-shuffle!) ident(*irange*)operator(\))

comment(;; @@PLEAC@@_4.18)
comment(;; @@INCOMPLETE@@)
comment(;; @@INCOMPLETE@@)

comment(;; @@PLEAC@@_4.19)
comment(;; @@INCOMPLETE@@)
comment(;; @@INCOMPLETE@@)

comment(;; @@PLEAC@@_5.0)
comment(;; ---------------------------------------------------------------------)
comment(;; Scheme offers two dictionary types:)
comment(;;)
comment(;; * Association list [list of pairs e.g. '((k1 . v1\) (k2 . v2\) ...\)])
comment(;; * Hash table [vector of pairs plus hash algorithm])
comment(;;)
comment(;; Implementation differences aside, they are remarkably similar in that)
comment(;; the functions operating on them are similar named, and offer the same)
comment(;; interface. Examples:)
comment(;;)
comment(;; * Retrieve an item: (assoc-ref hash key\) (hash-ref hash key\))
comment(;; * Update an item:   (assoc-set! hash key value\) (hash-set! hash key value\) )
comment(;;)
comment(;; Hash tables would tend to be used where performance was critical e.g.)
comment(;; near constant-time lookups, or where entry updates are frequent, whilst)
comment(;; association lists would be used where table-level traversals and )
comment(;; manipulations require maximum flexibility)
comment(;;)
comment(;; Many of the sections include examples using both association lists and)
comment(;; hash tables. However, where only one of these is shown, implementing)
comment(;; the other is usually a trivial exercise. Finally, any helper functions)
comment(;; will be included in the Appendix)
comment(;; ---------------------------------------------------------------------)

comment(; Association lists)
operator(()keyword(define) ident(*age*)
  operator(()ident(list)
    operator(()keyword(cons) operator(')ident(Nat) integer(24)operator(\))
    operator(()keyword(cons) operator(')ident(Jules) integer(25)operator(\))
    operator(()keyword(cons) operator(')ident(Josh) integer(17)operator(\))operator(\))operator(\))

comment(;; or, perhaps more compactly:)
operator(()keyword(define) ident(*age*)
  operator(()ident(list)
    operator(')operator(()ident(Nat) operator(.) integer(24)operator(\))
    operator(')operator(()ident(Jules) operator(.) integer(25)operator(\))
    operator(')operator(()ident(Josh) operator(.) integer(17)operator(\))operator(\))operator(\))

comment(;; ------------)

comment(; Guile built-in association list support)
operator(()keyword(define) ident(*age*) operator(()ident(acons) operator(')ident(Nat) integer(24) operator(')operator(()operator(\))operator(\))operator(\))
operator(()keyword(set!) ident(*age*) operator(()ident(acons) operator(')ident(Jules) integer(25) ident(*age*)operator(\))operator(\))
operator(()keyword(set!) ident(*age*) operator(()ident(acons) operator(')ident(Josh) integer(17) ident(*age*)operator(\))operator(\))

comment(;; ----)

comment(; SRFI-1 association list support)
operator(()ident(use-modules) operator(()ident(srfi) ident(srfi-1)operator(\))operator(\))

operator(()keyword(define) ident(*age*) operator(()ident(alist-cons) operator(')ident(Nat) integer(24) operator(')operator(()operator(\))operator(\))operator(\))
operator(()keyword(set!) ident(*age*) operator(()ident(alist-cons) operator(')ident(Jules) integer(25) ident(*age*)operator(\))operator(\))
operator(()keyword(set!) ident(*age*) operator(()ident(alist-cons) operator(')ident(Josh) integer(17) ident(*age*)operator(\))operator(\))

comment(;; ------------)

operator(()keyword(define) ident(*food-colour*)
  operator(()ident(list)
    operator(')operator(()ident(Apple) operator(.) string<delimiter(")content(red)delimiter(")>operator(\))
    operator(')operator(()ident(Banana) operator(.) string<delimiter(")content(yellow)delimiter(")>operator(\))
    operator(')operator(()ident(Lemon) operator(.) string<delimiter(")content(yellow)delimiter(")>operator(\))
    operator(')operator(()ident(Carrot) operator(.) string<delimiter(")content(orange)delimiter(")>operator(\))operator(\))operator(\))

comment(;; ----------------------------)

comment(; Hash tables. Guile offers an implementation, and it is also )
comment(; possible to use SRFI-69 hash tables; only the former will be)
comment(; illustrated here)

operator(()keyword(define) ident(*age*) operator(()ident(make-hash-table) integer(20)operator(\))operator(\))
comment(; or)
operator(()keyword(define) ident(*age*) operator(()ident(make-vector) integer(20) operator(')operator(()operator(\))operator(\))operator(\))

operator(()ident(hash-set!) ident(*age*) operator(')ident(Nat) integer(24)operator(\))
operator(()ident(hash-set!) ident(*age*) operator(')ident(Jules) integer(25)operator(\))
operator(()ident(hash-set!) ident(*age*) operator(')ident(Josh) integer(17)operator(\))

operator(()ident(hash-for-each)
  operator(()keyword(lambda) operator(()ident(key) ident(value)operator(\)) operator(()ident(print) ident(key)operator(\))operator(\))
  ident(*age*)operator(\))

comment(; or, if vector used as hash table, can also use:)

operator(()ident(array-for-each)
  operator(()keyword(lambda) operator(()ident(pair)operator(\))
    operator(()keyword(if) operator(()ident(not) operator(()ident(null?) ident(pair)operator(\))operator(\)) operator(()ident(print) operator(()ident(car) ident(pair)operator(\))operator(\))operator(\))operator(\))
  ident(*age*)operator(\))

comment(;; ------------)

operator(()keyword(define) ident(*food-colour*) operator(()ident(make-hash-table) integer(20)operator(\))operator(\))

operator(()ident(hash-set!) ident(*food-colour*) operator(')ident(Apple) string<delimiter(")content(red)delimiter(")>operator(\))
operator(()ident(hash-set!) ident(*food-colour*) operator(')ident(Banana) string<delimiter(")content(yellow)delimiter(")>operator(\))
operator(()ident(hash-set!) ident(*food-colour*) operator(')ident(Lemon) string<delimiter(")content(yellow)delimiter(")>operator(\))
operator(()ident(hash-set!) ident(*food-colour*) operator(')ident(Carrot) string<delimiter(")content(orange)delimiter(")>operator(\))

comment(;; @@PLEAC@@_5.1)
operator(()keyword(set!) ident(*hash*) operator(()ident(acons) ident(key) ident(value) ident(*hash*)operator(\))operator(\))

comment(;; ------------)

operator(()keyword(set!) ident(*food-colour*) operator(()ident(acons) operator(')ident(Raspberry) string<delimiter(")content(pink)delimiter(")> ident(*food-colour*)operator(\))operator(\))

operator(()ident(print) string<delimiter(")content(Known foods:)delimiter(")>operator(\))
operator(()ident(for-each)
  operator(()keyword(lambda) operator(()ident(pair)operator(\)) operator(()ident(print) operator(()ident(car) ident(pair)operator(\))operator(\))operator(\))
  ident(*food-colour*)operator(\))

comment(;; ----------------------------)

operator(()ident(hash-set!) ident(*hash*) ident(key) ident(value)operator(\))

comment(;; ------------)

operator(()ident(hash-set!) ident(*food-colour*) operator(')ident(Raspberry) string<delimiter(")content(pink)delimiter(")>operator(\))

operator(()ident(print) string<delimiter(")content(Known foods:)delimiter(")>operator(\))
operator(()ident(hash-for-each)
  operator(()keyword(lambda) operator(()ident(key) ident(value)operator(\)) operator(()ident(print) ident(key)operator(\))operator(\))
  ident(*food-colour*)operator(\))

comment(;; @@PLEAC@@_5.2)
comment(; 'assoc' returns the pair, (key . value\))
operator(()keyword(if) operator(()ident(assoc) ident(key) ident(hash)operator(\))
  ident(...) ident(found) ident(...)
comment(;else)
  ident(...) ident(not) ident(found) ident(...)

comment(; 'assoc-ref' returns the value only)
operator(()keyword(if) operator(()ident(assoc-ref) ident(hash) ident(key)operator(\))
  ident(...) ident(found) ident(...)
comment(;else)
  ident(...) ident(not) ident(found) ident(...)

comment(;; ------------)

comment(; *food-colour* association list from an earlier section)

operator(()ident(for-each)
  operator(()keyword(lambda) operator(()ident(name)operator(\))
    operator(()keyword(let) operator(()operator(()ident(pair) operator(()ident(assoc) ident(name) ident(*food-colour*)operator(\))operator(\))operator(\))
      operator(()keyword(if) ident(pair)
        operator(()ident(print) operator(()ident(symbol->string) operator(()ident(car) ident(pair)operator(\))operator(\)) string<delimiter(")content(is a food)delimiter(")>operator(\))
      comment(;else)
        operator(()ident(print) operator(()ident(symbol->string) ident(name)operator(\)) string<delimiter(")content(is a drink)delimiter(")>operator(\)) operator(\))operator(\))operator(\))
  operator(()ident(list) operator(')ident(Banana) operator(')ident(Martini)operator(\))operator(\))

comment(;; ----------------------------)

comment(; 'hash-get-handle' returns the pair, (key . value\))
operator(()keyword(if) operator(()ident(hash-get-handle) ident(hash) ident(key)operator(\))
  ident(...) ident(found) ident(...)
comment(;else)
  ident(...) ident(not) ident(found) ident(...)

comment(; 'hash-ref' returns the value only)
operator(()keyword(if) operator(()ident(hash-ref) ident(hash) ident(key)operator(\))
  ident(...) ident(found) ident(...)
comment(;else)
  ident(...) ident(not) ident(found) ident(...)

comment(;; ------------)

comment(; *food-colour* hash table from an earlier section)

operator(()ident(for-each)
  operator(()keyword(lambda) operator(()ident(name)operator(\))
    operator(()keyword(let) operator(()operator(()ident(value) operator(()ident(hash-ref) ident(*food-colour*) ident(name)operator(\))operator(\))operator(\))
      operator(()keyword(if) ident(value)
        operator(()ident(print) operator(()ident(symbol->string) ident(name)operator(\)) string<delimiter(")content(is a food)delimiter(")>operator(\))
      comment(;else)
        operator(()ident(print) operator(()ident(symbol->string) ident(name)operator(\)) string<delimiter(")content(is a drink)delimiter(")>operator(\)) operator(\))operator(\))operator(\))
  operator(()ident(list) operator(')ident(Banana) operator(')ident(Martini)operator(\))operator(\))

comment(;; ----------------------------)

operator(()keyword(define) ident(*age*) operator(()ident(make-hash-table) integer(20)operator(\))operator(\))

operator(()ident(hash-set!) ident(*age*) operator(')ident(Toddler) integer(3)operator(\))
operator(()ident(hash-set!) ident(*age*) operator(')ident(Unborn) integer(0)operator(\))
operator(()ident(hash-set!) ident(*age*) operator(')ident(Phantasm) operator(')operator(()operator(\))operator(\))

operator(()ident(for-each)
  operator(()keyword(lambda) operator(()ident(thing)operator(\))
    operator(()keyword(let) operator(()operator(()ident(value) operator(()ident(hash-ref) ident(*age*) ident(thing)operator(\))operator(\))operator(\))
      operator(()ident(display) ident(thing)operator(\))
      operator(()keyword(if) ident(value) operator(()ident(display) string<delimiter(")content( Exists)delimiter(")>operator(\))operator(\))
      operator(()keyword(if) operator(()keyword(and) ident(value) operator(()ident(not) operator(()ident(string-null?) ident(value)operator(\))operator(\))operator(\)) operator(()ident(display) string<delimiter(")content( Defined)delimiter(")>operator(\))operator(\))
      comment(; Testing for non-zero as true is not applicable, so testing)
      comment(; for non-equality with zero )
      operator(()keyword(if) operator(()keyword(and) ident(value) operator(()ident(not) operator(()ident(eq?) ident(value) integer(0)operator(\))operator(\))operator(\)) operator(()ident(display) string<delimiter(")content( True)delimiter(")>operator(\))operator(\))
      operator(()ident(print) string<delimiter(")delimiter(")>operator(\)) operator(\))operator(\))
  operator(()ident(list) operator(')ident(Toddler) operator(')ident(Unborn) operator(')ident(Phantasm) operator(')ident(Relic)operator(\))operator(\))

comment(;; @@PLEAC@@_5.3)
operator(()ident(assoc-remove!) ident(hash) ident(key)operator(\))

comment(;; ------------)

operator(()ident(use-modules) operator(()ident(srfi) ident(srfi-1)operator(\))operator(\))

comment(; *food-colour* association list from an earlier section)

operator(()keyword(define) operator(()ident(print-foods)operator(\))
  operator(()keyword(let) operator(()operator(()ident(foods)
          operator(()ident(fold-right)
            operator(()keyword(lambda) operator(()ident(pair) ident(accum)operator(\)) operator(()keyword(cons) operator(()ident(car) ident(pair)operator(\)) ident(accum)operator(\))operator(\))
            operator(')operator(()operator(\))
            ident(*food-colour*)operator(\))operator(\))operator(\))
    operator(()ident(display) string<delimiter(")content(Keys: )delimiter(")>operator(\)) operator(()ident(print) ident(foods)operator(\))
    operator(()ident(print) string<delimiter(")content(Values:)delimiter(")>operator(\))
    operator(()ident(for-each)
      operator(()keyword(lambda) operator(()ident(food)operator(\))
        operator(()keyword(let) operator(()operator(()ident(colour) operator(()ident(assoc-ref) ident(*food-colour*) ident(food)operator(\))operator(\))operator(\))
          operator(()keyword(cond)
            operator(()operator(()ident(string-null?) ident(colour)operator(\)) operator(()ident(display) string<delimiter(")content((undef\) )delimiter(")>operator(\))operator(\))
            operator(()ident(else) operator(()ident(display) operator(()ident(string-append) ident(colour) string<delimiter(")content( )delimiter(")>operator(\))operator(\))operator(\)) operator(\))operator(\))operator(\))
      ident(foods)operator(\))operator(\))
    operator(()ident(newline)operator(\))operator(\))

operator(()ident(print) string<delimiter(")content(Initially:)delimiter(")>operator(\))
operator(()ident(print-foods)operator(\))

operator(()ident(print) string<delimiter(")content(\\n)content(With Banana undef)delimiter(")>operator(\))
operator(()ident(assoc-set!) ident(*food-colour*) operator(')ident(Banana) string<delimiter(")delimiter(")>operator(\))
operator(()ident(print-foods)operator(\))

operator(()ident(print) string<delimiter(")content(\\n)content(With Banana deleted)delimiter(")>operator(\))
operator(()ident(assoc-remove!) ident(*food-colour*) operator(')ident(Banana)operator(\))
operator(()ident(print-foods)operator(\))

comment(;; ----------------------------)

operator(()ident(hash-remove!) ident(hash) ident(key)operator(\))

comment(;; ------------)

operator(()ident(use-modules) operator(()ident(srfi) ident(srfi-1)operator(\))operator(\))

comment(; *food-colour* hash table from an earlier section)

operator(()keyword(define) operator(()ident(print-foods)operator(\))
  operator(()keyword(let) operator(()operator(()ident(foods)
          operator(()ident(hash-fold)
            operator(()keyword(lambda) operator(()ident(key) ident(value) ident(accum)operator(\)) operator(()keyword(cons) ident(key) ident(accum)operator(\))operator(\))
            operator(')operator(()operator(\))
            ident(*food-colour*)operator(\))operator(\))operator(\))
    operator(()ident(display) string<delimiter(")content(Keys: )delimiter(")>operator(\)) operator(()ident(print) operator(()ident(reverse) ident(foods)operator(\))operator(\))
    operator(()ident(print) string<delimiter(")content(Values:)delimiter(")>operator(\))
    operator(()ident(for-each)
      operator(()keyword(lambda) operator(()ident(food)operator(\))
        operator(()keyword(let) operator(()operator(()ident(colour) operator(()ident(hash-ref) ident(*food-colour*) ident(food)operator(\))operator(\))operator(\))
          operator(()keyword(cond)
            operator(()operator(()ident(string-null?) ident(colour)operator(\)) operator(()ident(display) string<delimiter(")content((undef\) )delimiter(")>operator(\))operator(\))
            operator(()ident(else) operator(()ident(display) operator(()ident(string-append) ident(colour) string<delimiter(")content( )delimiter(")>operator(\))operator(\))operator(\)) operator(\))operator(\))operator(\))
      ident(foods)operator(\))operator(\))
    operator(()ident(newline)operator(\))operator(\))

operator(()ident(print) string<delimiter(")content(Initially:)delimiter(")>operator(\))
operator(()ident(print-foods)operator(\))

operator(()ident(print) string<delimiter(")content(\\n)content(With Banana undef)delimiter(")>operator(\))
operator(()ident(hash-set!) ident(*food-colour*) operator(')ident(Banana) string<delimiter(")delimiter(")>operator(\))
operator(()ident(print-foods)operator(\))

operator(()ident(print) string<delimiter(")content(\\n)content(With Banana deleted)delimiter(")>operator(\))
operator(()ident(hash-remove!) ident(*food-colour*) operator(')ident(Banana)operator(\))
operator(()ident(print-foods)operator(\))

comment(;; @@PLEAC@@_5.4)
comment(; Since an association list is nothing more than a list of pairs, it)
comment(; may be traversed using 'for-each')
operator(()ident(for-each)
  operator(()keyword(lambda) operator(()ident(pair)operator(\))
    operator(()keyword(let) operator(()operator(()ident(key) operator(()ident(car) ident(pair)operator(\))operator(\))
          operator(()ident(value) operator(()ident(cdr) ident(pair)operator(\))operator(\))operator(\))
      ident(...) keyword(do) ident(something) ident(with) ident(key) ident(/) ident(value) ident(...)operator(\))operator(\))
  ident(hash)operator(\))

comment(;; ----------------------------)

comment(; A 'for-each'-like function is available for hash table traversal)
operator(()ident(hash-for-each)
  operator(()keyword(lambda) operator(()ident(key) ident(value)operator(\))
    ident(...) keyword(do) ident(something) ident(with) ident(key) ident(/) ident(value) ident(...)operator(\))
  ident(hash)operator(\))

comment(; If the hash table is directly implemented as a vector, then it is)
comment(; also possible to traverse it using, 'array-for-each', though a )
comment(; check for empty slots is needed )
operator(()ident(array-for-each)
  operator(()keyword(lambda) operator(()ident(pair)operator(\))
    operator(()keyword(if) operator(()ident(not) operator(()ident(null?) ident(pair)operator(\))operator(\)) ident(...) keyword(do) ident(something) ident(with) ident(key) ident(/) ident(value) ident(...)operator(\))operator(\))
  ident(hash)operator(\))

comment(;; ----------------------------)

comment(; *food-colour* association list from an earlier section)

operator(()ident(for-each)
  operator(()keyword(lambda) operator(()ident(pair)operator(\))
    operator(()keyword(let) operator(()operator(()ident(food) operator(()ident(car) ident(pair)operator(\))operator(\))
          operator(()ident(colour) operator(()ident(cdr) ident(pair)operator(\))operator(\))operator(\))
      operator(()ident(print) operator(()ident(symbol->string) ident(food)operator(\)) string<delimiter(")content(is)delimiter(")> ident(colour)operator(\)) operator(\))operator(\))
  ident(*food-colour*)operator(\))

comment(;; ------------)

comment(; *food-colour* association list from an earlier section)

operator(()ident(for-each)
  operator(()keyword(lambda) operator(()ident(food)operator(\))
    operator(()ident(print) operator(()ident(symbol->string) ident(food)operator(\)) string<delimiter(")content(is)delimiter(")> operator(()ident(assoc-ref) ident(*food-colour*) ident(food)operator(\))operator(\))operator(\))
  operator(()ident(sort)
    operator(()ident(fold-right)
      operator(()keyword(lambda) operator(()ident(pair) ident(accum)operator(\)) operator(()keyword(cons) operator(()ident(car) ident(pair)operator(\)) ident(accum)operator(\))operator(\))
      operator(')operator(()operator(\))
      ident(*food-colour*)operator(\))
    operator(()keyword(lambda) operator(()ident(left) ident(right)operator(\))
      operator(()ident(string<?) operator(()ident(symbol->string) ident(left)operator(\)) operator(()ident(symbol->string) ident(right)operator(\))operator(\))operator(\))operator(\))operator(\))

comment(;; ----------------------------)

operator(()ident(use-modules) operator(()ident(srfi) ident(srfi-1)operator(\)) operator(()ident(ice-9) ident(rdelim)operator(\)) operator(()ident(ice-9) ident(regex)operator(\))operator(\))

operator(()keyword(define) ident(*filename*) string<delimiter(")content(from.txt)delimiter(")>operator(\))
operator(()keyword(define) ident(*from*) operator(')operator(()operator(\))operator(\))

operator(()keyword(let) operator(()operator(()ident(port) operator(()ident(open-input-file) ident(*filename*)operator(\))operator(\))operator(\))
  operator(()keyword(let) ident(loop) operator(()operator(()ident(line&terminator) operator(()ident(read-line) ident(port) operator(')ident(split)operator(\))operator(\))operator(\))
    operator(()keyword(cond)
      operator(()operator(()ident(eof-object?) operator(()ident(cdr) ident(line&terminator)operator(\))operator(\)) operator(')operator(()operator(\))operator(\))
      operator(()ident(else)
        operator(()keyword(let*) operator(()operator(()ident(key) operator(()ident(string->symbol)
                      operator(()ident(match:substring)
                        operator(()ident(string-match)
                          string<delimiter(")content(^From: (.*\))delimiter(")> operator(()ident(car) ident(line&terminator)operator(\))operator(\))
                        integer(1)operator(\)) operator(\))operator(\))
               operator(()ident(value) operator(()ident(assoc-ref) ident(*from*) ident(key)operator(\))operator(\))operator(\))
          operator(()keyword(if) operator(()ident(not) ident(value)operator(\)) operator(()keyword(set!) ident(value) integer(0)operator(\))operator(\))
          operator(()keyword(set!) ident(*from*) operator(()ident(assoc-set!) ident(*from*) ident(key) operator(()ident(+) integer(1) ident(value)operator(\))operator(\))operator(\))operator(\))
        operator(()ident(loop) operator(()ident(read-line) ident(port) operator(')ident(split)operator(\))operator(\)) operator(\))operator(\))operator(\)) 
  operator(()ident(close-input-port) ident(port)operator(\))operator(\))

operator(()ident(for-each)
  operator(()keyword(lambda) operator(()ident(person)operator(\))
    operator(()ident(print) operator(()ident(symbol->string) ident(person)operator(\)) string<delimiter(")content(:)delimiter(")> operator(()ident(number->string) operator(()ident(assoc-ref) ident(*from*) ident(person)operator(\))operator(\))operator(\))operator(\))
  operator(()ident(sort)
    operator(()ident(fold-right)
      operator(()keyword(lambda) operator(()ident(pair) ident(accum)operator(\)) operator(()keyword(cons) operator(()ident(car) ident(pair)operator(\)) ident(accum)operator(\))operator(\))
      operator(')operator(()operator(\))
      ident(*from*)operator(\))
    operator(()keyword(lambda) operator(()ident(left) ident(right)operator(\))
      operator(()ident(string<?) operator(()ident(symbol->string) ident(left)operator(\)) operator(()ident(symbol->string) ident(right)operator(\))operator(\))operator(\))operator(\))operator(\))

comment(;; @@PLEAC@@_5.5)
comment(; All approaches shown in the previous section apply here also, so)
comment(; there is little to be gained by repeating those examples [i.e. the)
comment(; use of 'for-each' and similar]. It is always possible, of course,)
comment(; to directly recurse over an association list:)

comment(; *food-colour* association list from an earlier section)

operator(()keyword(define) ident(*sorted-food-colour*)
  operator(()ident(sort)
    ident(*food-colour*)
    operator(()keyword(lambda) operator(()ident(left) ident(right)operator(\))
      operator(()ident(string<?)
        operator(()ident(symbol->string) operator(()ident(car) ident(left)operator(\))operator(\))
        operator(()ident(symbol->string) operator(()ident(car) ident(right)operator(\))operator(\))operator(\))operator(\)) operator(\))operator(\))

operator(()keyword(let) ident(loop) operator(()operator(()ident(hash) ident(*sorted-food-colour*)operator(\))operator(\))
  operator(()keyword(cond)
    operator(()operator(()ident(null?) ident(hash)operator(\)) operator(')operator(()operator(\))operator(\))
    operator(()ident(else)  
      operator(()ident(print)
        operator(()ident(symbol->string) operator(()ident(car) operator(()ident(car) ident(hash)operator(\))operator(\))operator(\)) string<delimiter(")content(=>)delimiter(")> operator(()ident(cdr) operator(()ident(car) ident(hash)operator(\))operator(\)) operator(\))
      operator(()ident(loop) operator(()ident(cdr) ident(hash)operator(\))operator(\))operator(\)) operator(\))operator(\))

comment(;; @@PLEAC@@_5.6)
comment(; AFAIK, Scheme doesn't offer a facility similar to Perl's 'Tie::IxHash'.)
comment(; Therefore, use an association list if retrieval [from a dictionary)
comment(; type container] in insertion order is required.)

operator(()keyword(define) ident(*food-colour*) operator(()ident(acons) operator(')ident(Banana) string<delimiter(")content(Yellow)delimiter(")> operator(')operator(()operator(\))operator(\))operator(\))
operator(()keyword(set!) ident(*food-colour*) operator(()ident(acons) operator(')ident(Apple) string<delimiter(")content(Green)delimiter(")> ident(*food-colour*)operator(\))operator(\))
operator(()keyword(set!) ident(*food-colour*) operator(()ident(acons) operator(')ident(Lemon) string<delimiter(")content(yellow)delimiter(")> ident(*food-colour*)operator(\))operator(\))

operator(()ident(print) string<delimiter(")content(In insertion order, the foods are:)delimiter(")>operator(\))
operator(()ident(for-each)
  operator(()keyword(lambda) operator(()ident(pair)operator(\))
    operator(()keyword(let) operator(()operator(()ident(food) operator(()ident(car) ident(pair)operator(\))operator(\))
          operator(()ident(colour) operator(()ident(cdr) ident(pair)operator(\))operator(\))operator(\))
      operator(()ident(print) string<delimiter(")content(  )delimiter(")> operator(()ident(symbol->string) ident(food)operator(\))operator(\)) operator(\))operator(\))
  ident(*food-colour*)operator(\))

operator(()ident(print) string<delimiter(")content(Still in insertion order, the food's colours are:)delimiter(")>operator(\))
operator(()ident(for-each)
  operator(()keyword(lambda) operator(()ident(pair)operator(\))
    operator(()keyword(let) operator(()operator(()ident(food) operator(()ident(car) ident(pair)operator(\))operator(\))
          operator(()ident(colour) operator(()ident(cdr) ident(pair)operator(\))operator(\))operator(\))
      operator(()ident(print) operator(()ident(symbol->string) ident(food)operator(\)) string<delimiter(")content(is coloured)delimiter(")> ident(colour)operator(\)) operator(\))operator(\))
  ident(*food-colour*)operator(\))

comment(;; ----------------------------)

comment(; Of course, insertion order is lost if the association list is sorted,)
comment(; or elements removed, so if maintaining insertion order is vital, it)
comment(; might pay to associate data with a timestamp [e.g. create a timestamped)
comment(; record / structure], and manipulate those entities [no example given])

comment(;; @@PLEAC@@_5.7)
operator(()keyword(define) ident(*ttys*) operator(')operator(()operator(\))operator(\))

operator(()ident(for-each)
  operator(()keyword(lambda) operator(()ident(user-tty-pair)operator(\))
    operator(()keyword(let*) operator(()operator(()ident(user-tty-pair) operator(()ident(string-split) ident(user-tty-pair) char(#\\space)operator(\))operator(\))
           operator(()ident(user) operator(()ident(string->symbol) operator(()ident(car) ident(user-tty-pair)operator(\))operator(\))operator(\))
           operator(()ident(newtty) operator(()ident(cadr) ident(user-tty-pair)operator(\))operator(\))
           operator(()ident(current-ttys) operator(()ident(assoc-ref) ident(*ttys*) ident(user)operator(\))operator(\))operator(\))
      operator(()keyword(set!) ident(*ttys*)
        operator(()ident(assoc-set!) ident(*ttys*) ident(user)
          operator(()keyword(if) operator(()ident(not) ident(current-ttys)operator(\))
            ident(newtty)
            operator(()ident(string-append) ident(current-ttys) string<delimiter(")content( )delimiter(")> ident(newtty)operator(\))operator(\)) operator(\))operator(\))operator(\))operator(\))
  operator(()ident(string-split) operator(()ident(qx) string<delimiter(")content(who|cut -d' ' -f1,2)delimiter(")>operator(\)) char(#\\newline)operator(\))operator(\))

operator(()ident(for-each)
  operator(()keyword(lambda) operator(()ident(user-ttys)operator(\))
    operator(()ident(print) operator(()ident(symbol->string) operator(()ident(car) ident(user-ttys)operator(\))operator(\)) string<delimiter(")content(:)delimiter(")> operator(()ident(cdr) ident(user-ttys)operator(\))operator(\))operator(\))
  operator(()ident(sort)
    ident(*ttys*)
    operator(()keyword(lambda) operator(()ident(left) ident(right)operator(\))
      operator(()ident(string<?)
        operator(()ident(symbol->string) operator(()ident(car) ident(left)operator(\))operator(\))
        operator(()ident(symbol->string) operator(()ident(car) ident(right)operator(\))operator(\))operator(\))operator(\))operator(\)) operator(\))

comment(;; ----------------------------)

operator(()ident(use-modules) operator(()ident(ice-9) ident(regex)operator(\))operator(\))

operator(()keyword(define) operator(()ident(multi-hash-delete) ident(hash) ident(key) ident(value)operator(\))
  operator(()keyword(let) operator(()operator(()ident(value-found) operator(()ident(assoc-ref) ident(hash) ident(key)operator(\))operator(\))operator(\))
    operator(()keyword(if) ident(value-found)
      operator(()ident(assoc-ref) ident(hash) ident(key)
        operator(()ident(regexp-substitute/global)
          predefined_constant(#f) operator(()ident(string-match) ident(value) ident(value-found)operator(\)) operator(')ident(pre) string<delimiter(")delimiter(")> operator(')ident(post) string<delimiter(")delimiter(")>operator(\))operator(\))operator(\))operator(\))operator(\))

comment(;; @@PLEAC@@_5.8)
comment(; Alternate implementatons of a hash inversion function; both assume)
comment(; key is a symbol, value is a string)

operator(()keyword(define) operator(()ident(assoc-invert) ident(assoc)operator(\))
  operator(()ident(map)
    operator(()keyword(lambda) operator(()ident(pair)operator(\))
      operator(()keyword(cons)
        operator(()ident(string->symbol) operator(()ident(cdr) ident(pair)operator(\))operator(\))
        operator(()ident(symbol->string) operator(()ident(car) ident(pair)operator(\))operator(\))operator(\))operator(\))
    ident(assoc)operator(\))operator(\))

comment(;; ------------)

operator(()keyword(define) operator(()ident(assoc-invert) ident(assoc)operator(\))
  operator(()keyword(let) ident(loop) operator(()operator(()ident(assoc) ident(assoc)operator(\)) operator(()ident(new-assoc) operator(')operator(()operator(\))operator(\))operator(\))
    operator(()keyword(cond)
      operator(()operator(()ident(null?) ident(assoc)operator(\)) ident(new-assoc)operator(\))
      operator(()ident(else) 
        operator(()ident(loop) operator(()ident(cdr) ident(assoc)operator(\))
              operator(()ident(acons)
                operator(()ident(string->symbol) operator(()ident(cdar) ident(assoc)operator(\))operator(\))
                operator(()ident(symbol->string) operator(()ident(caar) ident(assoc)operator(\))operator(\)) ident(new-assoc)operator(\))operator(\)) operator(\))operator(\)) operator(\))operator(\))

comment(;; ----------------------------)

operator(()keyword(define) ident(*surname*)
  operator(()ident(list)
    operator(')operator(()ident(Mickey) operator(.) string<delimiter(")content(Mantle)delimiter(")>operator(\))
    operator(')operator(()ident(Babe) operator(.) string<delimiter(")content(Ruth)delimiter(")>operator(\))operator(\))operator(\))

operator(()keyword(define) ident(*first-name*) operator(()ident(assoc-invert) ident(*surname*)operator(\))operator(\))

operator(()ident(print) operator(()ident(assoc-ref) ident(*first-name*) operator(')ident(Mantle)operator(\))operator(\))

comment(;; ----------------------------)

comment(; foodfind)

operator(()keyword(define) ident(*given*) operator(()ident(string->symbol) operator(()ident(cadr) operator(()ident(command-line)operator(\))operator(\))operator(\))operator(\))

operator(()keyword(define) ident(*colour*)
  operator(()ident(list)
    operator(')operator(()ident(Apple) operator(.) string<delimiter(")content(red)delimiter(")>operator(\))
    operator(')operator(()ident(Lemon) operator(.) string<delimiter(")content(yellow)delimiter(")>operator(\))
    operator(')operator(()ident(Carrot) operator(.) string<delimiter(")content(orange)delimiter(")>operator(\))operator(\))operator(\))

operator(()keyword(define) ident(*food*) operator(()ident(assoc-invert) ident(*colour*)operator(\))operator(\))

operator(()keyword(if) operator(()ident(assoc-ref) ident(*colour*) ident(*given*)operator(\))
  operator(()ident(print)
    operator(()ident(symbol->string) ident(*given*)operator(\)) 
    string<delimiter(")content(is a food with colour)delimiter(")>
    operator(()ident(assoc-ref) ident(*colour*) ident(*given*)operator(\))operator(\))operator(\))

operator(()keyword(if) operator(()ident(assoc-ref) ident(*food*) ident(*given*)operator(\))
  operator(()ident(print)
    operator(()ident(assoc-ref) ident(*food*) ident(*given*)operator(\))
    string<delimiter(")content(is a food with colour)delimiter(")>
    operator(()ident(symbol->string) ident(*given*)operator(\))operator(\))operator(\))

comment(;; @@PLEAC@@_5.9)
comment(; *food-colour* association list from an earlier section)

comment(; Use 'sort' to sort the entire hash, on key or on value, ascending or)
comment(; descending order)
operator(()keyword(define) ident(*sorted-on-key:food-colour*)
  operator(()ident(sort)
    ident(*food-colour*)
    operator(()keyword(lambda) operator(()ident(left) ident(right)operator(\))
      operator(()ident(string<?)
        operator(()ident(symbol->string) operator(()ident(car) ident(left)operator(\))operator(\))
        operator(()ident(symbol->string) operator(()ident(car) ident(right)operator(\))operator(\))operator(\))operator(\)) operator(\))operator(\))

operator(()keyword(define) ident(*sorted-on-value:food-colour*)
  operator(()ident(sort)
    ident(*food-colour*)
    operator(()keyword(lambda) operator(()ident(left) ident(right)operator(\))
      operator(()ident(string<?)
        operator(()ident(cdr) ident(left)operator(\))
        operator(()ident(cdr) ident(right)operator(\))operator(\))operator(\)) operator(\))operator(\))

comment(;; ------------)

operator(()ident(for-each)
  operator(()keyword(lambda) operator(()ident(pair)operator(\))
    operator(()keyword(let) operator(()operator(()ident(food) operator(()ident(car) ident(pair)operator(\))operator(\))
          operator(()ident(colour) operator(()ident(cdr) ident(pair)operator(\))operator(\))operator(\))
      operator(()ident(print)
        operator(()ident(symbol->string) ident(food)operator(\))
        string<delimiter(")content(is)delimiter(")>
        ident(colour)operator(\))operator(\))operator(\))
  ident(*sorted-on-key:food-colour*)operator(\))

comment(;; ----------------------------)

comment(; Alternatively, generate a list of keys or values, sort as required,)
comment(; and use list to guide the hash traversal)

operator(()keyword(define) ident(*sorted-food-colour-keys*)
  operator(()ident(sort)
    operator(()ident(fold-right)
      operator(()keyword(lambda) operator(()ident(pair) ident(accum)operator(\)) operator(()keyword(cons) operator(()ident(car) ident(pair)operator(\)) ident(accum)operator(\))operator(\))
      operator(')operator(()operator(\))
      ident(*food-colour*)operator(\))
    operator(()keyword(lambda) operator(()ident(left) ident(right)operator(\))
      operator(()ident(string<?)
        operator(()ident(symbol->string) ident(left)operator(\))
        operator(()ident(symbol->string) ident(right)operator(\))operator(\))operator(\)) operator(\))operator(\))

operator(()keyword(define) ident(*sorted-food-colour-values*)
  operator(()ident(sort)
    operator(()ident(fold-right)
      operator(()keyword(lambda) operator(()ident(pair) ident(accum)operator(\)) operator(()keyword(cons) operator(()ident(cdr) ident(pair)operator(\)) ident(accum)operator(\))operator(\))
      operator(')operator(()operator(\))
      ident(*food-colour*)operator(\))
    operator(()keyword(lambda) operator(()ident(left) ident(right)operator(\))
      operator(()ident(string<?) ident(left) ident(right)operator(\))operator(\)) operator(\))operator(\))

comment(;; ------------)

operator(()ident(for-each)
  operator(()keyword(lambda) operator(()ident(food)operator(\))
    operator(()ident(print) operator(()ident(symbol->string) ident(food)operator(\)) string<delimiter(")content(is)delimiter(")> operator(()ident(assoc-ref) ident(*food-colour*) ident(food)operator(\))operator(\))operator(\))
  ident(*sorted-food-colour-keys*)operator(\))

comment(;; @@PLEAC@@_5.10)
comment(; If merging is defined as the combining of the contents of two or more)
comment(; hashes, then it is simply a matter of copying the contents of each)
comment(; into a new hash)

comment(; Association lists can simply be appended together)
operator(()keyword(define) ident(*food-colour*)
  operator(()ident(list)
    operator(')operator(()ident(Apple) operator(.) string<delimiter(")content(red)delimiter(")>operator(\))
    operator(')operator(()ident(Banana) operator(.) string<delimiter(")content(yellow)delimiter(")>operator(\))
    operator(')operator(()ident(Lemon) operator(.) string<delimiter(")content(yellow)delimiter(")>operator(\))
    operator(')operator(()ident(Carrot) operator(.) string<delimiter(")content(orange)delimiter(")>operator(\))operator(\))operator(\))

operator(()keyword(define) ident(*drink-colour*)
  operator(()ident(list)
    operator(')operator(()ident(Galliano) operator(.) string<delimiter(")content(yellow)delimiter(")>operator(\))
    operator(')operator(()ident(Mai) ident(Tai) operator(.) string<delimiter(")content(blue)delimiter(")>operator(\))operator(\))operator(\))

operator(()keyword(define) ident(*ingested-colour*) operator(()ident(append) ident(*food-colour*) ident(*drink-colour*)operator(\))operator(\))

comment(;; ----------------------------)

comment(; Hash tables built from vectors can be copied element by element into)
comment(; a new vector, or spliced together using 'vector-join' [see Chapter 4])

operator(()keyword(define) ident(*food-colour*) operator(()ident(make-vector) integer(20) operator(')operator(()operator(\))operator(\))
comment(; ...)
operator(()keyword(define) ident(*drink-colour*) operator(()ident(make-vector) integer(20) operator(')operator(()operator(\))operator(\))
comment(; ...)

operator(()keyword(define) ident(*ingested-colour*)
  operator(()ident(vector-join) ident(*food-colour*) ident(*drink-colour*)operator(\))operator(\))

comment(;; @@PLEAC@@_5.11)
operator(()keyword(define) ident(*common*) operator(')operator(()operator(\))operator(\))
operator(()keyword(define) ident(*this-not-that*) operator(')operator(()operator(\))operator(\))

comment(;; ------------)

operator(()keyword(define) ident(*dict1*)
  operator(()ident(list)
    operator(')operator(()ident(Apple) operator(.) string<delimiter(")content(red)delimiter(")>operator(\))
    operator(')operator(()ident(Lemon) operator(.) string<delimiter(")content(yellow)delimiter(")>operator(\))
    operator(')operator(()ident(Carrot) operator(.) string<delimiter(")content(orange)delimiter(")>operator(\))operator(\))operator(\))

operator(()keyword(define) ident(*dict2*)
  operator(()ident(list)
    operator(')operator(()ident(Apple) operator(.) string<delimiter(")content(red)delimiter(")>operator(\))
    operator(')operator(()ident(Carrot) operator(.) string<delimiter(")content(orange)delimiter(")>operator(\))operator(\))operator(\))

comment(;; ------------)

comment(; Find items common to '*dict1*' and '*dict2*')
operator(()ident(for-each)
  operator(()keyword(lambda) operator(()ident(pair)operator(\))
    operator(()keyword(let) operator(()operator(()ident(key) operator(()ident(car) ident(pair)operator(\))operator(\))
          operator(()ident(value) operator(()ident(cdr) ident(pair)operator(\))operator(\))operator(\))
      operator(()keyword(if) operator(()ident(assoc-ref) ident(*dict2*) ident(key)operator(\))
        operator(()keyword(set!) ident(*common*) operator(()keyword(cons) ident(key) ident(*common*)operator(\))operator(\))operator(\)) operator(\))operator(\))
  ident(*dict1*)operator(\))

comment(;; ------------)

comment(; Find items in '*dict1*' but not '*dict2*')
operator(()ident(for-each)
  operator(()keyword(lambda) operator(()ident(pair)operator(\))
    operator(()keyword(let) operator(()operator(()ident(key) operator(()ident(car) ident(pair)operator(\))operator(\))
          operator(()ident(value) operator(()ident(cdr) ident(pair)operator(\))operator(\))operator(\))
      operator(()keyword(if) operator(()ident(not) operator(()ident(assoc-ref) ident(*dict2*) ident(key)operator(\))operator(\))
        operator(()keyword(set!) ident(*this-not-that*) operator(()keyword(cons) ident(key) ident(*this-not-that*)operator(\))operator(\))operator(\)) operator(\))operator(\))
  ident(*dict1*)operator(\))

comment(;; ----------------------------)

operator(()keyword(define) ident(*non-citrus*) operator(')operator(()operator(\))operator(\))

operator(()keyword(define) ident(*citrus-colour*)
  operator(()ident(list)
    operator(')operator(()ident(Lemon) operator(.) string<delimiter(")content(yellow)delimiter(")>operator(\))
    operator(')operator(()ident(Orange) operator(.) string<delimiter(")content(orange)delimiter(")>operator(\))
    operator(')operator(()ident(Lime) operator(.) string<delimiter(")content(green)delimiter(")>operator(\))operator(\))operator(\))

operator(()keyword(define) ident(*food-colour*)
  operator(()ident(list)
    operator(')operator(()ident(Apple) operator(.) string<delimiter(")content(red)delimiter(")>operator(\))
    operator(')operator(()ident(Banana) operator(.) string<delimiter(")content(yellow)delimiter(")>operator(\))
    operator(')operator(()ident(Lemon) operator(.) string<delimiter(")content(yellow)delimiter(")>operator(\))
    operator(')operator(()ident(Carrot) operator(.) string<delimiter(")content(orange)delimiter(")>operator(\))operator(\))operator(\))

operator(()ident(for-each)
  operator(()keyword(lambda) operator(()ident(pair)operator(\))
    operator(()keyword(let) operator(()operator(()ident(key) operator(()ident(car) ident(pair)operator(\))operator(\))
          operator(()ident(value) operator(()ident(cdr) ident(pair)operator(\))operator(\))operator(\))
      operator(()keyword(if) operator(()ident(not) operator(()ident(assoc-ref) ident(*citrus-colour*) ident(key)operator(\))operator(\))
        operator(()keyword(set!) ident(*non-citrus*) operator(()keyword(cons) ident(key) ident(*non-citrus*)operator(\))operator(\))operator(\)) operator(\))operator(\))
  ident(*food-colour*)operator(\))

comment(;; @@PLEAC@@_5.12)
comment(; All objects [including functions] are first class entities, so there)
comment(; is no problem / special treatment needed to use any object, including)
comment(; those classed as 'references' [e.g. file handles or ports] as keys)

operator(()ident(use-modules) operator(()ident(srfi) ident(srfi-1)operator(\)) operator(()ident(srfi) ident(srfi-13)operator(\))operator(\))

operator(()keyword(define) ident(*ports*) operator(')operator(()operator(\))operator(\))

operator(()ident(for-each)
  operator(()keyword(lambda) operator(()ident(filename)operator(\))
    operator(()keyword(let) operator(()operator(()ident(port) operator(()ident(open-input-file) ident(filename)operator(\))operator(\))operator(\))
      operator(()keyword(set!) ident(*ports*) operator(()ident(assoc-set!) ident(*ports*) ident(port) ident(filename)operator(\))operator(\)) operator(\))operator(\))
  operator(')operator(()string<delimiter(")content(/etc/termcap)delimiter(")> string<delimiter(")content(/vmlinux)delimiter(")> string<delimiter(")content(/bin/cat)delimiter(")>operator(\))operator(\))

operator(()ident(print)
  operator(()ident(string-append) string<delimiter(")content(open files: )delimiter(")>
    operator(()ident(string-drop)
      operator(()ident(fold-right)
        operator(()keyword(lambda) operator(()ident(pair) ident(accum)operator(\)) operator(()ident(string-append) string<delimiter(")content(, )delimiter(")> operator(()ident(cdr) ident(pair)operator(\)) ident(accum)operator(\))operator(\))
        string<delimiter(")delimiter(")>
        ident(*ports*)operator(\))
      integer(2)operator(\))operator(\))operator(\))

operator(()ident(for-each)
  operator(()keyword(lambda) operator(()ident(pair)operator(\))
    operator(()keyword(let) operator(()operator(()ident(port) operator(()ident(car) ident(pair)operator(\))operator(\))
          operator(()ident(filename) operator(()ident(cdr) ident(pair)operator(\))operator(\))operator(\))
      operator(()ident(seek) ident(port) integer(0) ident(SEEK_END)operator(\))
      operator(()ident(print) ident(filename) string<delimiter(")content(is)delimiter(")> operator(()ident(number->string) operator(()ident(ftell) ident(port)operator(\))operator(\)) string<delimiter(")content(bytes long.)delimiter(")>operator(\))
      operator(()ident(close-input-port) ident(port)operator(\)) operator(\))operator(\))
  ident(*ports*)operator(\))

comment(;; @@PLEAC@@_5.13)
comment(; An association list takes on the size of the number of elements with)
comment(; which it is initialised, so presizing is implicit)

operator(()keyword(define) ident(*hash*) operator(')operator(()operator(\))operator(\))         comment(; zero elements)

comment(;; ------------)

operator(()keyword(define) ident(*hash*)              comment(; three elements)
  operator(()ident(list)
    operator(')operator(()ident(Apple) operator(.) string<delimiter(")content(red)delimiter(")>operator(\))
    operator(')operator(()ident(Lemon) operator(.) string<delimiter(")content(yellow)delimiter(")>operator(\))
    operator(')operator(()ident(Carrot) operator(.) string<delimiter(")content(orange)delimiter(")>operator(\))operator(\))operator(\))

comment(;; ----------------------------)

comment(; A size [i.e. number of entries] must be specified when a hash table)
comment(; is created, so presizing is implicit)

operator(()keyword(define) ident(*hash*) operator(()ident(make-hash-table) integer(100)operator(\))operator(\))

comment(;; ------------)

operator(()keyword(define) ident(*hash*) operator(()ident(make-vector) integer(100) operator(')operator(()operator(\))operator(\))operator(\))

comment(;; @@PLEAC@@_5.14)
operator(()keyword(define) ident(*array*)
  operator(()ident(list) operator(')ident(a) operator(')ident(b) operator(')ident(c) operator(')ident(d) operator(')ident(d) operator(')ident(a) operator(')ident(a) operator(')ident(c) operator(')ident(d) operator(')ident(d) operator(')ident(e)operator(\))operator(\))

comment(;; ----------------------------)

operator(()keyword(define) ident(*count*) operator(')operator(()operator(\))operator(\))

operator(()ident(for-each)
  operator(()keyword(lambda) operator(()ident(element)operator(\))
    operator(()keyword(let) operator(()operator(()ident(value) operator(()ident(assoc-ref) ident(*count*) ident(element)operator(\))operator(\))operator(\))
      operator(()keyword(if) operator(()ident(not) ident(value)operator(\)) operator(()keyword(set!) ident(value) integer(0)operator(\))operator(\))
      operator(()keyword(set!) ident(*count*) operator(()ident(assoc-set!) ident(*count*) ident(element) operator(()ident(+) integer(1) ident(value)operator(\))operator(\))operator(\))operator(\))operator(\))
  ident(*array*)operator(\))

comment(;; ----------------------------)

operator(()keyword(define) ident(*count*) operator(()ident(make-hash-table) integer(20)operator(\))operator(\))

operator(()ident(for-each)
  operator(()keyword(lambda) operator(()ident(element)operator(\))
    operator(()keyword(let) operator(()operator(()ident(value) operator(()ident(hash-ref) ident(*count*) ident(element)operator(\))operator(\))operator(\))
      operator(()keyword(if) operator(()ident(not) ident(value)operator(\)) operator(()keyword(set!) ident(value) integer(0)operator(\))operator(\))
      operator(()ident(hash-set!) ident(*count*) ident(element) operator(()ident(+) integer(1) ident(value)operator(\))operator(\))operator(\))operator(\))
  ident(*array*)operator(\))

comment(;; @@PLEAC@@_5.15)
operator(()keyword(define) ident(*father*)
  operator(()ident(list)
    operator(')operator(()ident(Cain) operator(.) ident(Adam)operator(\))
    operator(')operator(()ident(Abel) operator(.) ident(Adam)operator(\))
    operator(')operator(()ident(Seth) operator(.) ident(Adam)operator(\))
    operator(')operator(()ident(Enoch) operator(.) ident(Cain)operator(\))
    operator(')operator(()ident(Irad) operator(.) ident(Enoch)operator(\))
    operator(')operator(()ident(Mehujael) operator(.) ident(Irad)operator(\))
    operator(')operator(()ident(Methusael) operator(.) ident(Mehujael)operator(\))
    operator(')operator(()ident(Lamech) operator(.) ident(Methusael)operator(\))
    operator(')operator(()ident(Jabal) operator(.) ident(Lamech)operator(\))
    operator(')operator(()ident(Jubal) operator(.) ident(Lamech)operator(\))
    operator(')operator(()ident(Tubalcain) operator(.) ident(Lamech)operator(\))
    operator(')operator(()ident(Enos) operator(.) ident(Seth)operator(\))operator(\))operator(\))

comment(;; ------------)

operator(()ident(use-modules) operator(()ident(srfi) ident(srfi-1)operator(\)) operator(()ident(ice-9) ident(rdelim)operator(\))operator(\))

operator(()keyword(let) operator(()operator(()ident(port) operator(()ident(open-input-file) ident(*filename*)operator(\))operator(\))operator(\))
  operator(()keyword(let) ident(loop) operator(()operator(()ident(line&terminator) operator(()ident(read-line) ident(port) operator(')ident(split)operator(\))operator(\))operator(\))
    operator(()keyword(cond)
      operator(()operator(()ident(eof-object?) operator(()ident(cdr) ident(line&terminator)operator(\))operator(\)) operator(')operator(()operator(\))operator(\))
      operator(()ident(else)
        operator(()keyword(let) operator(()operator(()ident(person) operator(()ident(string->symbol) operator(()ident(car) ident(line&terminator)operator(\))operator(\))operator(\))operator(\))
          operator(()keyword(let) ident(loop) operator(()operator(()ident(father) operator(()ident(assoc-ref) ident(*father*) ident(person)operator(\))operator(\))operator(\))
            operator(()keyword(if) ident(father)
            operator(()keyword(begin)
              operator(()ident(print) ident(father)operator(\))
              operator(()ident(loop) operator(()ident(assoc-ref) ident(*father*) ident(father)operator(\))operator(\)) operator(\))operator(\))operator(\))
        operator(()ident(loop) operator(()ident(read-line) ident(port) operator(')ident(split)operator(\))operator(\)) operator(\))operator(\))operator(\))operator(\))
  operator(()ident(close-input-port) ident(port)operator(\))operator(\))

comment(;; ------------)

operator(()ident(use-modules) operator(()ident(srfi) ident(srfi-1)operator(\)) operator(()ident(ice-9) ident(rdelim)operator(\))operator(\))

operator(()keyword(define) operator(()ident(assoc-invert-N:M) ident(assoc)operator(\))
  operator(()keyword(let) operator(()operator(()ident(new-assoc) operator(')operator(()operator(\))operator(\))operator(\))
    operator(()ident(for-each)
      operator(()keyword(lambda) operator(()ident(pair)operator(\))
        operator(()keyword(let*) operator(()operator(()ident(old-key) operator(()ident(car) ident(pair)operator(\))operator(\))
               operator(()ident(new-key) operator(()ident(cdr) ident(pair)operator(\))operator(\))
               operator(()ident(new-key-found) operator(()ident(assoc-ref) ident(new-assoc) ident(new-key)operator(\))operator(\))operator(\))
          operator(()keyword(if) operator(()ident(not) ident(new-key-found)operator(\))
            operator(()keyword(set!) ident(new-assoc) operator(()ident(acons) ident(new-key) operator(()ident(list) ident(old-key)operator(\)) ident(new-assoc)operator(\))operator(\)) 
          comment(;else)
            operator(()keyword(set!) ident(new-assoc) operator(()ident(assoc-set!) ident(new-assoc) ident(new-key) operator(()keyword(cons) ident(old-key) ident(new-key-found)operator(\))operator(\))operator(\)) operator(\))operator(\))operator(\))
      ident(assoc)operator(\))
  ident(new-assoc)operator(\))operator(\))

operator(()keyword(define) ident(*children*) operator(()ident(assoc-invert-N:M) ident(*father*)operator(\))operator(\))

operator(()keyword(let) operator(()operator(()ident(port) operator(()ident(open-input-file) ident(*filename*)operator(\))operator(\))operator(\))
  operator(()keyword(let) ident(loop) operator(()operator(()ident(line&terminator) operator(()ident(read-line) ident(port) operator(')ident(split)operator(\))operator(\))operator(\))
    operator(()keyword(cond)
      operator(()operator(()ident(eof-object?) operator(()ident(cdr) ident(line&terminator)operator(\))operator(\)) operator(')operator(()operator(\))operator(\))
      operator(()ident(else)
        operator(()keyword(let*) operator(()operator(()ident(person) operator(()ident(string->symbol) operator(()ident(car) ident(line&terminator)operator(\))operator(\))operator(\))
               operator(()ident(children-found) operator(()ident(assoc-ref) ident(*children*) ident(person)operator(\))operator(\))operator(\))
          operator(()ident(print) operator(()ident(symbol->string) ident(person)operator(\)) string<delimiter(")content(begat:)delimiter(")>operator(\))
          operator(()keyword(if) operator(()ident(not) ident(children-found)operator(\))
            operator(()ident(print) string<delimiter(")content(nobody)delimiter(")>operator(\))
          comment(;else)
            operator(()ident(for-each)
              operator(()keyword(lambda) operator(()ident(child)operator(\)) operator(()ident(print) operator(()ident(symbol->string) ident(child)operator(\)) string<delimiter(")content(,)delimiter(")>operator(\))operator(\))
              ident(children-found)operator(\))operator(\))
        operator(()ident(loop) operator(()ident(read-line) ident(port) operator(')ident(split)operator(\))operator(\)) operator(\))operator(\))operator(\))operator(\))
  operator(()ident(close-input-port) ident(port)operator(\))operator(\))

comment(;; @@PLEAC@@_5.16)
comment(;; @@INCOMPLETE@@)
comment(;; @@INCOMPLETE@@)

comment(;; @@PLEAC@@_7.0)
comment(;; use (open-input-file filename\) or (open filename O_RDONLY\))

operator(()keyword(define) ident(input) operator(()ident(open-input-file) string<delimiter(")content(/usr/local/widgets/data)delimiter(")>operator(\))operator(\))
operator(()keyword(let) ident(loop) operator(()operator(()ident(line) operator(()ident(read-line) ident(input) operator(')ident(concat)operator(\))operator(\))operator(\))
  operator(()keyword(cond) operator(()operator(()ident(not) operator(()ident(eof-object?) ident(line)operator(\))operator(\))
         operator(()keyword(if) operator(()ident(string-match) string<delimiter(")content(blue)delimiter(")> ident(line)operator(\))
           operator(()ident(display) ident(line)operator(\))operator(\))
         operator(()ident(loop) operator(()ident(read-line) ident(input) operator(')ident(concat)operator(\))operator(\))operator(\))operator(\))operator(\))
operator(()ident(close) ident(input)operator(\))

comment(;; Many I/O functions default to the logical STDIN/OUT)

comment(;; You can also explicitly get the standard ports with)
comment(;; [set-]current-{input,output,error}-port.)

comment(;; format takes a port as the first argument.  If #t is given, format)
comment(;; writes to stdout, if #f is given, format returns a string.)

operator(()keyword(let) ident(loop) operator(()operator(()ident(line) operator(()ident(read-line)operator(\))operator(\))operator(\))     comment(; reads from stdin)
  operator(()keyword(cond) operator(()operator(()ident(not) operator(()ident(eof-object?) ident(line)operator(\))operator(\))
         operator(()keyword(if) operator(()ident(not) operator(()ident(string-match) string<delimiter(")content([0-9])delimiter(")> ident(line)operator(\))operator(\))
           comment(;; writes to stderr)
           operator(()ident(display) string<delimiter(")content(No digit found.)content(\\n)delimiter(")> operator(()ident(current-error-port)operator(\))operator(\))
           comment(;; writes to stdout)
           operator(()ident(format) predefined_constant(#t) string<delimiter(")content(Read: ~A)content(\\n)delimiter(")> ident(line)operator(\))operator(\))
         operator(()ident(loop) operator(()ident(read-line)operator(\))operator(\))operator(\))operator(\))operator(\))

comment(;; use open-output-file)

operator(()keyword(define) ident(logfile) operator(()ident(open-output-file) string<delimiter(")content(/tmp/log)delimiter(")>operator(\))operator(\))

comment(;; increasingly specific ways of closing ports (it's safe to close a)
comment(;; closed port\))

operator(()ident(close) ident(logfile)operator(\))                comment(; #t)
operator(()ident(close-port) ident(logfile)operator(\))           comment(; #f (already closed\))
operator(()ident(close-output-port) ident(logfile)operator(\))    comment(; unspecified)

comment(;; you can rebind standard ports with set-current-<foo>-port:)

operator(()keyword(let) operator(()operator(()ident(old-out) operator(()ident(current-output-port)operator(\))operator(\))operator(\))
  operator(()ident(set-current-output-port) ident(logfile)operator(\))
  operator(()ident(display) string<delimiter(")content(Countdown initiated ...)content(\\n)delimiter(")>operator(\))
  operator(()ident(set-current-output-port) ident(old-out)operator(\))
  operator(()ident(display) string<delimiter(")content(You have 30 seconds to reach minimum safety distance.)content(\\n)delimiter(")>operator(\))operator(\))

comment(;; or)

operator(()ident(with-output-to-file) ident(logfile)
  operator(()keyword(lambda) operator(()operator(\)) operator(()ident(display) string<delimiter(")content(Countdown initiated ...)content(\\n)delimiter(")>operator(\))operator(\))operator(\))
operator(()ident(display) string<delimiter(")content(You have 30 seconds to reach minimum safety distance.)content(\\n)delimiter(")>operator(\))


comment(;; @@PLEAC@@_7.1)
operator(()keyword(define) ident(source) operator(()ident(open-input-file) ident(path)operator(\))operator(\))
operator(()keyword(define) ident(sink) operator(()ident(open-output-file) ident(path)operator(\))operator(\))

operator(()keyword(define) ident(source) operator(()ident(open) ident(path) ident(O_RDONLY)operator(\))operator(\))
operator(()keyword(define) ident(sink) operator(()ident(open) ident(path) ident(O_WRONLY)operator(\))operator(\))

comment(;;-----------------------------)
operator(()keyword(define) ident(port) operator(()ident(open-input-file) ident(path)operator(\))operator(\))
operator(()keyword(define) ident(port) operator(()ident(open-file) ident(path) string<delimiter(")content(r)delimiter(")>operator(\))operator(\))
operator(()keyword(define) ident(port) operator(()ident(open) ident(path) ident(O_RDONLY)operator(\))operator(\))
comment(;;-----------------------------)
operator(()keyword(define) ident(port) operator(()ident(open-output-file) ident(path)operator(\))operator(\))
operator(()keyword(define) ident(port) operator(()ident(open-file) ident(path) string<delimiter(")content(w)delimiter(")>operator(\))operator(\))
operator(()keyword(define) ident(port) operator(()ident(open) ident(path) operator(()ident(logior) ident(O_WRONLY) ident(O_TRUNC) ident(O_CREAT)operator(\))operator(\))operator(\))
comment(;;-----------------------------)
operator(()keyword(define) ident(port) operator(()ident(open) ident(path) operator(()ident(logior) ident(O_WRONLY) ident(O_EXCL) ident(O_CREAT)operator(\))operator(\))operator(\))
comment(;;-----------------------------)
operator(()keyword(define) ident(port) operator(()ident(open-file) ident(path) string<delimiter(")content(a)delimiter(")>operator(\))operator(\))
operator(()keyword(define) ident(port) operator(()ident(open) ident(path) operator(()ident(logior) ident(O_WRONLY) ident(O_APPEND) ident(O_CREAT)operator(\))operator(\))operator(\))
comment(;;-----------------------------)
operator(()keyword(define) ident(port) operator(()ident(open) ident(path) operator(()ident(logior) ident(O_WRONLY) ident(O_APPEND)operator(\))operator(\))operator(\))
comment(;;-----------------------------)
operator(()keyword(define) ident(port) operator(()ident(open) ident(path) ident(O_RDWR)operator(\))operator(\))
comment(;;-----------------------------)
operator(()keyword(define) ident(port) operator(()ident(open-file) ident(path) string<delimiter(")content(r+)delimiter(")>operator(\))operator(\))
operator(()keyword(define) ident(port) operator(()ident(open) ident(path) operator(()ident(logior) ident(O_RDWR) ident(O_CREAT)operator(\))operator(\))operator(\))
comment(;;-----------------------------)
operator(()keyword(define) ident(port) operator(()ident(open) ident(path) operator(()ident(logior) ident(O_RDWR) ident(O_EXCL) ident(O_CREAT)operator(\))operator(\))operator(\))
comment(;;-----------------------------)

comment(;; @@PLEAC@@_7.2)
comment(;; Nothing different needs to be done with Guile)

comment(;; @@PLEAC@@_7.3)
operator(()keyword(define) ident(expand-user)
  operator(()keyword(let) operator(()operator(()ident(rx) operator(()ident(make-regexp) string<delimiter(")content(^)content(\\\\)content(~([^/]+\)?)delimiter(")>operator(\))operator(\))operator(\))
    operator(()keyword(lambda) operator(()ident(filename)operator(\))
      operator(()keyword(let) operator(()operator(()ident(m) operator(()ident(regexp-exec) ident(rx) ident(filename)operator(\))operator(\))operator(\))
        operator(()keyword(if) ident(m)
          operator(()ident(string-append)
           operator(()keyword(if) operator(()ident(match:substring) ident(m) integer(1)operator(\))
             operator(()ident(passwd:dir) operator(()ident(getpwnam) operator(()ident(match:substring) ident(m) integer(1)operator(\))operator(\))operator(\))
             operator(()keyword(or) operator(()ident(getenv) string<delimiter(")content(HOME)delimiter(")>operator(\)) operator(()ident(getenv) string<delimiter(")content(LOGDIR)delimiter(")>operator(\))
                 operator(()ident(passwd:dir) operator(()ident(getpwuid) operator(()ident(cuserid)operator(\))operator(\))operator(\)) string<delimiter(")delimiter(")>operator(\))operator(\))
           operator(()ident(substring) ident(filename) operator(()ident(match:end) ident(m)operator(\))operator(\))operator(\))
          ident(filename)operator(\))operator(\))operator(\))operator(\))operator(\))

comment(;; @@PLEAC@@_7.4)
operator(()keyword(define) ident(port) operator(()ident(open-file) ident(filename) ident(mode)operator(\))operator(\))  comment(; raise an exception on error)

comment(;; use catch to trap errors)
operator(()ident(catch) operator(')ident(system-error) comment(; the type of error thrown)
  operator(()keyword(lambda) operator(()operator(\)) operator(()keyword(set!) ident(port) operator(()ident(open-file) ident(filename) ident(mode)operator(\))operator(\))operator(\)) comment(; thunk to try)
  operator(()keyword(lambda) operator(()ident(key) operator(.) ident(args)operator(\))  comment(; exception handler)
    operator(()keyword(let) operator(()operator(()ident(fmt) operator(()ident(cadr) ident(args)operator(\))operator(\))
          operator(()ident(msg&path) operator(()ident(caddr) ident(args)operator(\))operator(\))operator(\))
      operator(()ident(format) operator(()ident(current-error-port)operator(\)) ident(fmt) operator(()ident(car) ident(msg&path)operator(\)) operator(()ident(cadr) ident(msg&path)operator(\))operator(\))
      operator(()ident(newline)operator(\))operator(\))operator(\))operator(\))

comment(;; @@PLEAC@@_7.5)
comment(;; use the POSIX tmpnam)
operator(()keyword(let) operator(()operator(()ident(name) operator(()ident(tmpnam)operator(\))operator(\))operator(\))
  operator(()ident(call-with-output-file) ident(name)
    operator(()keyword(lambda) operator(()ident(port)operator(\))
      comment(;; ... output to port)
      operator(\))operator(\))operator(\))

comment(;; better to test and be sure you have exclusive access to the file)
comment(;; (temp file name will be available as (port-filename port\)\))
operator(()keyword(define) operator(()ident(open-temp-file)operator(\))
  operator(()keyword(let) ident(loop) operator(()operator(()ident(name) operator(()ident(tmpnam)operator(\))operator(\))operator(\))
    operator(()ident(catch) operator(')ident(system-error)
      operator(()keyword(lambda) operator(()operator(\)) operator(()ident(open) ident(name) operator(()ident(logior) ident(O_RDWR) ident(O_CREAT) ident(O_EXCL)operator(\))operator(\))operator(\))
      operator(()keyword(lambda) operator(()ident(key) operator(.) ident(args)operator(\)) operator(()ident(loop) operator(()ident(tmpnam)operator(\))operator(\))operator(\))operator(\))operator(\))operator(\))

comment(;; or let mkstemp! do the work for you:)
operator(()keyword(define) ident(port) operator(()ident(mkstemp!) ident(template-string-ending-in-XXXXXX)operator(\))operator(\))

operator(()keyword(let*) operator(()operator(()ident(tmpl) string<delimiter(")content(/tmp/programXXXXXX)delimiter(")>operator(\))
       operator(()ident(port) operator(()ident(mkstemp!) ident(tmpl)operator(\))operator(\))operator(\))
  comment(;; tmpl now contains the name of the temp file,)
  comment(;; e.g. "/tmp/programhVoEzw")
  operator(()keyword(do) operator(()operator(()ident(i) integer(0) operator(()integer(1)ident(+) ident(i)operator(\))operator(\))operator(\))
      operator(()operator(()ident(=) ident(i) integer(10)operator(\))operator(\))
    operator(()ident(format) ident(port) string<delimiter(")content(~A)content(\\n)delimiter(")> ident(i)operator(\))operator(\))
  operator(()ident(seek) ident(port) integer(0) ident(SEEK_SET)operator(\))
  operator(()ident(display) string<delimiter(")content(Tmp file has:)content(\\n)delimiter(")>operator(\))
  operator(()keyword(do) operator(()operator(()ident(line) operator(()ident(read-line) ident(port) operator(')ident(concat)operator(\)) operator(()ident(read-line) ident(port) operator(')ident(concat)operator(\))operator(\))operator(\))
      operator(()operator(()ident(eof-object?) ident(line)operator(\))operator(\))
    operator(()ident(display) ident(line)operator(\))operator(\))
  operator(()ident(close) ident(port)operator(\))operator(\))

comment(;; @@PLEAC@@_7.6)
comment(;; string ports are ideal for this)

operator(()keyword(define) ident(DATA) string<delimiter(")content(
your data goes here
)delimiter(")>operator(\))

operator(()ident(call-with-input-string)
 ident(DATA)
 operator(()keyword(lambda) operator(()ident(port)operator(\))
   comment(;; ... process input from port)
   operator(\))operator(\))

comment(;; or)

operator(()ident(with-input-from-string) ident(DATA)
  operator(()keyword(lambda) operator(()operator(\))
    comment(;; ... stdin now comes from DATA)
    operator(\))operator(\))

comment(;; @@PLEAC@@_7.7)
comment(;; to process lines of current-input-port:)
operator(()keyword(do) operator(()operator(()ident(line) operator(()ident(read-line)operator(\)) operator(()ident(read-line)operator(\))operator(\))operator(\))
    operator(()operator(()ident(eof-object?) ident(line)operator(\))operator(\))
  comment(;; ... do something with line)
  operator(\))

comment(;; a general filter template:)

operator(()keyword(define) operator(()ident(body)operator(\))
  operator(()keyword(do) operator(()operator(()ident(line) operator(()ident(read-line)operator(\)) operator(()ident(read-line)operator(\))operator(\))operator(\))
      operator(()operator(()ident(eof-object?) ident(line)operator(\))operator(\))
    operator(()ident(display) ident(line)operator(\))
    operator(()ident(newline)operator(\))operator(\))operator(\))

operator(()keyword(let) operator(()operator(()ident(args) operator(()ident(cdr) operator(()ident(command-line)operator(\))operator(\))operator(\))operator(\))
  comment(;; ... handle options here)
  operator(()keyword(if) operator(()ident(null?) ident(args)operator(\))
    operator(()ident(body)operator(\))     comment(; no args, just call body on stdin)
    operator(()ident(for-each)  comment(; otherwise, call body with stdin set to each arg in turn)
     operator(()keyword(lambda) operator(()ident(file)operator(\))
       operator(()ident(catch) operator(')ident(system-error)
         operator(()keyword(lambda) operator(()operator(\))
           operator(()ident(with-input-from-file) ident(file)
             ident(body)operator(\))operator(\))
         operator(()keyword(lambda) operator(()ident(key) operator(.) ident(args)operator(\))
           operator(()ident(format) operator(()ident(current-error-port)operator(\)) operator(()ident(cadr) ident(args)operator(\)) operator(()ident(caaddr) ident(args)operator(\))
                   operator(()ident(car) operator(()ident(cdaddr) ident(args)operator(\))operator(\))operator(\))
           operator(()ident(newline) operator(()ident(current-error-port)operator(\))operator(\))operator(\))operator(\))operator(\))
     ident(args)operator(\))operator(\))operator(\))

comment(;; example: count-chunks:)
operator(()ident(use-modules) operator(()ident(srfi) ident(srfi-1)operator(\)) operator(()ident(srfi) ident(srfi-13)operator(\)) operator(()ident(ice-9) ident(format)operator(\)) operator(()ident(ice-9) ident(regex)operator(\))operator(\))

comment(;; also use directory-files from 9.5 and globbing functions from 9.6)

comment(;; can use (ice-9 getopt-long\) described in chapter 15, or process)
comment(;; options by hand)
operator(()keyword(define) ident(opt-append) integer(0)operator(\))
operator(()keyword(define) ident(opt-ignore-ints) integer(0)operator(\))
operator(()keyword(define) ident(opt-nostdout) integer(0)operator(\))
operator(()keyword(define) ident(opt-unbuffer) integer(0)operator(\))

operator(()keyword(define) ident(args) operator(()ident(cdr) operator(()ident(command-line)operator(\))operator(\))operator(\))

operator(()keyword(do) operator(()operator(()ident(opts) ident(args) operator(()ident(cdr) ident(opts)operator(\))operator(\))operator(\))
    operator(()operator(()keyword(or) operator(()ident(null?) ident(opts)operator(\)) operator(()ident(not) operator(()ident(eq?) operator(()ident(string-ref) operator(()ident(car) ident(opts)operator(\)) integer(0)operator(\)) char(#\\-)operator(\))operator(\))operator(\))
     operator(()keyword(set!) ident(args) ident(opts)operator(\))operator(\))
  operator(()keyword(let) operator(()operator(()ident(opt) operator(()ident(car) ident(opts)operator(\))operator(\))operator(\))
    operator(()keyword(cond) operator(()operator(()ident(string=?) ident(opt) string<delimiter(")content(-a)delimiter(")>operator(\)) operator(()keyword(set!) ident(opt-append) operator(()integer(1)ident(+) ident(opt-append)operator(\))operator(\))operator(\))
          operator(()operator(()ident(string=?) ident(opt) string<delimiter(")content(-i)delimiter(")>operator(\)) operator(()keyword(set!) ident(opt-ignore-ints) operator(()integer(1)ident(+) ident(opt-ignore-ints)operator(\))operator(\))operator(\))
          operator(()operator(()ident(string=?) ident(opt) string<delimiter(")content(-n)delimiter(")>operator(\)) operator(()keyword(set!) ident(opt-nostdout) operator(()integer(1)ident(+) ident(opt-nostdout)operator(\))operator(\))operator(\))
          operator(()operator(()ident(string=?) ident(opt) string<delimiter(")content(-u)delimiter(")>operator(\)) operator(()keyword(set!) ident(opt-unbuffer) operator(()integer(1)ident(+) ident(opt-unbuffer)operator(\))operator(\))operator(\))
          operator(()ident(else) operator(()ident(throw) operator(')ident(usage-error) string<delimiter(")content(Unexpected argument: ~A)delimiter(")> ident(opt)operator(\))operator(\))operator(\))operator(\))operator(\))

comment(;; default to all C source files)
operator(()keyword(if) operator(()ident(null?) ident(args)operator(\)) operator(()keyword(set!) ident(args) operator(()ident(glob) string<delimiter(")content(*.[Cch])delimiter(")> string<delimiter(")content(.)delimiter(")>operator(\))operator(\))operator(\))

operator(()keyword(define) operator(()ident(find-login)operator(\))
  operator(()keyword(do) operator(()operator(()ident(line) operator(()ident(read-line)operator(\)) operator(()ident(read-line)operator(\))operator(\))operator(\))
      operator(()operator(()ident(eof-object?) ident(line)operator(\))operator(\))
    operator(()keyword(cond) operator(()operator(()ident(string-match) string<delimiter(")content(login)delimiter(")> ident(line)operator(\))
           operator(()ident(display) ident(line)operator(\))
           operator(()ident(newline)operator(\))operator(\))operator(\))operator(\))operator(\))

operator(()keyword(define) operator(()ident(lowercase)operator(\))
  operator(()keyword(do) operator(()operator(()ident(line) operator(()ident(read-line)operator(\)) operator(()ident(read-line)operator(\))operator(\))operator(\))
      operator(()operator(()ident(eof-object?) ident(line)operator(\))operator(\))
    operator(()ident(display) operator(()ident(string-downcase) ident(line)operator(\))operator(\))
    operator(()ident(newline)operator(\))operator(\))operator(\))

operator(()keyword(define) operator(()ident(count-chunks)operator(\))
  operator(()keyword(do) operator(()operator(()ident(line) operator(()ident(read-line)operator(\)) operator(()ident(read-line)operator(\))operator(\))
       operator(()ident(chunks) integer(0)operator(\))operator(\))
      operator(()operator(()keyword(or) operator(()ident(eof-object?) ident(line)operator(\))
           operator(()ident(string=?) ident(line) string<delimiter(")content(__DATA__)delimiter(")>operator(\)) operator(()ident(string=?) ident(line) string<delimiter(")content(__END__)delimiter(")>operator(\))operator(\))
       operator(()ident(format) predefined_constant(#t) string<delimiter(")content(Found ~A chunks)content(\\n)delimiter(")> ident(chunks)operator(\))operator(\))
    operator(()keyword(let) operator(()operator(()ident(tokens)
           operator(()ident(string-tokenize) operator(()ident(string-take) ident(line) operator(()keyword(or) operator(()ident(string-index) ident(line) char(#\\#)operator(\))
                                                  operator(()ident(string-length) ident(line)operator(\))operator(\))operator(\))operator(\))operator(\))operator(\))
      operator(()keyword(set!) ident(chunks) operator(()ident(+) ident(chunks) operator(()ident(length) ident(tokens)operator(\))operator(\))operator(\))operator(\))operator(\))operator(\))

operator(()keyword(if) operator(()ident(null?) ident(args)operator(\))
  operator(()ident(count-chunks)operator(\))     comment(; or find-login, lowercase, etc.)
  operator(()ident(for-each)
   operator(()keyword(lambda) operator(()ident(file)operator(\))
     operator(()ident(catch) operator(')ident(system-error)
       operator(()keyword(lambda) operator(()operator(\))
         operator(()ident(with-input-from-file) ident(file)
           ident(count-chunks)operator(\))operator(\))
       operator(()keyword(lambda) operator(()ident(key) operator(.) ident(args)operator(\))
         operator(()ident(format) operator(()ident(current-error-port)operator(\)) operator(()ident(cadr) ident(args)operator(\)) operator(()ident(caaddr) ident(args)operator(\))
                 operator(()ident(car) operator(()ident(cdaddr) ident(args)operator(\))operator(\))operator(\))
         operator(()ident(newline) operator(()ident(current-error-port)operator(\))operator(\))operator(\))operator(\))operator(\))
   ident(args)operator(\))operator(\))

comment(;; @@PLEAC@@_7.8)
comment(;; write changes to a temporary file then rename it)
operator(()ident(with-input-from-file) ident(old)
  operator(()keyword(lambda) operator(()operator(\))
    operator(()ident(with-output-to-file) ident(new)
      operator(()keyword(lambda) operator(()operator(\))
        operator(()keyword(do) operator(()operator(()ident(line) operator(()ident(read-line)operator(\)) operator(()ident(read-line)operator(\))operator(\))operator(\))
            operator(()operator(()ident(eof-object?) ident(line)operator(\))operator(\))
          comment(;; change line, then...)
          operator(()ident(write-line) ident(line)operator(\))operator(\))operator(\))operator(\))operator(\))operator(\))
operator(()ident(rename-file) ident(old) operator(()ident(string-append) ident(old) string<delimiter(")content(.orig)delimiter(")>operator(\))operator(\))
operator(()ident(rename-file) ident(new) ident(old)operator(\))

comment(;; @@PLEAC@@_7.9)
comment(;; no -i switch)

comment(;; @@PLEAC@@_7.10)
comment(;; open the file in read/write mode, slurp up the contents, modify it,)
comment(;; then write it back out:)
operator(()keyword(let) operator(()operator(()ident(p) operator(()ident(open-file) ident(file) string<delimiter(")content(r+)delimiter(")>operator(\))operator(\))
      operator(()ident(lines) operator(')operator(()operator(\))operator(\))operator(\))
  comment(;; read in lines)
  operator(()keyword(do) operator(()operator(()ident(line) operator(()ident(read-line) ident(p)operator(\)) operator(()ident(read-line) ident(p)operator(\))operator(\))operator(\))
      operator(()operator(()ident(eof-object?) ident(line)operator(\))operator(\))
    operator(()keyword(set!) ident(lines) operator(()keyword(cons) ident(line) ident(lines)operator(\))operator(\))operator(\))
  comment(;; modify (reverse lines\))
  operator(()ident(seek) ident(p) integer(0) ident(SEEK_SET)operator(\))
  comment(;; write out lines)
  operator(()ident(for-each) operator(()keyword(lambda) operator(()ident(x)operator(\)) operator(()ident(write-line) ident(x) ident(p)operator(\))operator(\)) ident(lines)operator(\))
  comment(;; truncate the file)
  operator(()ident(truncate-file) ident(p)operator(\))
  operator(()ident(close) ident(p)operator(\))operator(\))

operator(()keyword(let) operator(()operator(()ident(p) operator(()ident(open-file) string<delimiter(")content(foo)delimiter(")> string<delimiter(")content(r+)delimiter(")>operator(\))operator(\))
      operator(()ident(lines) operator(')operator(()operator(\))operator(\))
      operator(()ident(date) operator(()ident(date->string) operator(()ident(current-date)operator(\))operator(\))operator(\))operator(\))
  operator(()keyword(do) operator(()operator(()ident(line) operator(()ident(read-line) ident(p) operator(')ident(concat)operator(\)) operator(()ident(read-line) ident(p) operator(')ident(concat)operator(\))operator(\))operator(\))
      operator(()operator(()ident(eof-object?) ident(line)operator(\))operator(\))
    operator(()keyword(set!) ident(lines) operator(()keyword(cons) ident(line) ident(lines)operator(\))operator(\))operator(\))
  operator(()ident(seek) ident(p) integer(0) ident(SEEK_SET)operator(\))
  operator(()ident(for-each)
   operator(()keyword(lambda) operator(()ident(x)operator(\))
     operator(()ident(regexp-substitute/global) ident(p) string<delimiter(")content(DATE)delimiter(")> ident(x) operator(')ident(pre) ident(date) operator(')ident(post)operator(\))operator(\))
   operator(()ident(reverse) ident(lines)operator(\))operator(\))
  operator(()ident(truncate-file) ident(p)operator(\))
  operator(()ident(close) ident(p)operator(\))operator(\))

comment(;; @@PLEAC@@_7.11)
operator(()keyword(define) ident(p) operator(()ident(open-file) ident(path) string<delimiter(")content(r+)delimiter(")>operator(\))operator(\))
operator(()ident(flock) ident(p) ident(LOCK_EX)operator(\))
comment(;; update the file, then...)
operator(()ident(close) ident(p)operator(\))

comment(;; to increment a number in a file)
operator(()keyword(define) ident(p) operator(()ident(open) string<delimiter(")content(numfile)delimiter(")> operator(()ident(logior) ident(O_RDWR) ident(O_CREAT)operator(\))operator(\))operator(\))
operator(()ident(flock) ident(p) ident(LOCK_EX)operator(\))
comment(;; Now we have acquired the lock, it's safe for I/O)
operator(()keyword(let*) operator(()operator(()ident(obj) operator(()ident(read) ident(p)operator(\))operator(\))
       operator(()ident(num) operator(()keyword(if) operator(()ident(eof-object?) ident(obj)operator(\)) integer(0) ident(obj)operator(\))operator(\))operator(\))
  operator(()ident(seek) ident(p) integer(0) ident(SEEK_SET)operator(\))
  operator(()ident(truncate-file) ident(p)operator(\))
  operator(()ident(write) operator(()integer(1)ident(+) ident(num)operator(\)) ident(p)operator(\))
  operator(()ident(newline) ident(p)operator(\))operator(\))
operator(()ident(close) ident(p)operator(\))

comment(;; @@PLEAC@@_7.12)
comment(;; use force-output)
operator(()ident(force-output) ident(p)operator(\))

comment(;; flush all open ports)
operator(()ident(flush-all-ports)operator(\))

comment(;; @@PLEAC@@_7.13)
comment(;; use select)
operator(()ident(select) ident(inputs) ident(outputs) ident(exceptions) ident(seconds)operator(\))
operator(()ident(select) operator(()ident(list) ident(p1) ident(p2) ident(p3)operator(\)) operator(')operator(()operator(\)) operator(')operator(()operator(\))operator(\))

operator(()keyword(let*) operator(()operator(()ident(nfound) operator(()ident(select) operator(()ident(list) ident(inport)operator(\)) operator(')operator(()operator(\)) operator(')operator(()operator(\))operator(\))operator(\))
       operator(()ident(inputs) operator(()ident(car) ident(nfound)operator(\))operator(\))operator(\))
  operator(()keyword(if) operator(()ident(not) operator(()ident(null?) ident(inputs)operator(\))operator(\))
      operator(()keyword(let) operator(()operator(()ident(line) operator(()ident(read-line) ident(inport)operator(\))operator(\))operator(\))
        operator(()ident(format) predefined_constant(#t) string<delimiter(")content(I read ~A)content(\\n)delimiter(")> ident(line)operator(\))operator(\))operator(\))operator(\))

comment(;; or use char-ready? if you only need a single character)
operator(()keyword(if) operator(()ident(char-ready?) ident(p)operator(\))
  operator(()ident(format) predefined_constant(#t) string<delimiter(")content(I read ~A)content(\\n)delimiter(")> operator(()ident(read-char) ident(p)operator(\))operator(\))operator(\))

comment(;; @@PLEAC@@_7.14)
comment(;; use the O_NONBLOCK option with open)
operator(()keyword(define) ident(modem) operator(()ident(open) string<delimiter(")content(/dev/cua0)delimiter(")> operator(()ident(logior) ident(O_RDWR) ident(O_NONBLOCK)operator(\))operator(\))operator(\))

comment(;; or use fcntl if you already have a port)
operator(()keyword(let) operator(()operator(()ident(flags) operator(()ident(fcntl) ident(p) ident(F_GETFD)operator(\))operator(\))operator(\))
  operator(()ident(fcntl) ident(p) ident(F_SETFD) operator(()ident(logior) ident(flags) ident(O_NONBLOCK)operator(\))operator(\))operator(\))

comment(;; @@PLEAC@@_7.15)
comment(;; use stat)
operator(()keyword(let) operator(()operator(()ident(buf) operator(()ident(make-string) operator(()ident(stat:size) operator(()ident(stat) ident(p)operator(\))operator(\))operator(\))operator(\))operator(\))
  operator(()ident(read-string!/partial) ident(buf) ident(input)operator(\))operator(\))

comment(;; @@PLEAC@@_7.16)
comment(;; not needed - ports are first class objects)

comment(;; @@PLEAC@@_7.18)
comment(;; use for-each on the list of ports:)
operator(()ident(for-each) operator(()keyword(lambda) operator(()ident(p)operator(\)) operator(()ident(display) ident(stuff-to-print) ident(p)operator(\))operator(\)) ident(port-list)operator(\))

comment(;; or, if you don't want to keep track of the port list and know you)
comment(;; want to print to all open output ports, you can use port-for-each:)
operator(()ident(port-for-each) operator(()keyword(lambda) operator(()ident(p)operator(\)) operator(()keyword(if) operator(()ident(output-port?) ident(p)operator(\)) operator(()ident(display) ident(stuff) ident(p)operator(\))operator(\))operator(\))operator(\))

comment(;; @@PLEAC@@_7.19)
comment(;; use fdopen:)
operator(()keyword(define) ident(p) operator(()ident(fdopen) ident(num) ident(mode)operator(\))operator(\))
operator(()keyword(define) ident(p) operator(()ident(fdopen) integer(3) string<delimiter(")content(r)delimiter(")>operator(\))operator(\))

operator(()keyword(define) ident(p) operator(()ident(fdopen) operator(()ident(string->number) operator(()ident(getenv) string<delimiter(")content(MHCONTEXTFD)delimiter(")>operator(\))operator(\)) string<delimiter(")content(r)delimiter(")>operator(\))operator(\))
comment(;; after processing)
operator(()ident(close) ident(p)operator(\))

comment(;; @@PLEAC@@_7.20)
comment(;; ports are first class objects and can be aliased and passed around)
comment(;; like any other non-immediate variables:)
operator(()keyword(define) ident(alias) ident(original)operator(\))
operator(()keyword(define) ident(old-in) operator(()ident(current-input-port)operator(\))operator(\))

comment(;; or you can open two separate ports on the same file:)
operator(()keyword(define) ident(p1) operator(()ident(open-input-file) ident(path)operator(\))operator(\))
operator(()keyword(define) ident(p2) operator(()ident(open-input-file) ident(path)operator(\))operator(\))

comment(;; or use fdopen:)
operator(()keyword(define) ident(copy-of-p) operator(()ident(fdopen) operator(()ident(fileno) ident(p)operator(\)) ident(mode)operator(\))operator(\))

operator(()keyword(define) ident(old-out) operator(()ident(current-output-port)operator(\))operator(\))
operator(()keyword(define) ident(old-err) operator(()ident(current-error-port)operator(\))operator(\))

operator(()keyword(define) ident(new-out) operator(()ident(open-output-file) string<delimiter(")content(/tmp/program.out)delimiter(")>operator(\))operator(\))

operator(()ident(set-current-output-port) ident(new-out)operator(\))
operator(()ident(set-current-error-port) ident(new-out)operator(\))

operator(()ident(system) ident(joe-random-program)operator(\))

operator(()ident(close) ident(new-out)operator(\))

operator(()ident(set-current-output-port) ident(old-out)operator(\))
operator(()ident(set-current-error-port) ident(old-out)operator(\))

comment(;; @@PLEAC@@_8.0)
comment(;; open the file and loop through the port with read-line:)
operator(()keyword(let) operator(()operator(()ident(p) operator(()ident(open-input-file) ident(file)operator(\))operator(\))operator(\))
  operator(()keyword(do) operator(()operator(()ident(line) operator(()ident(read-line) ident(p)operator(\)) operator(()ident(read-line) ident(p)operator(\))operator(\))operator(\))
      operator(()operator(()ident(eof-object?) ident(line)operator(\))operator(\))
    operator(()ident(format) predefined_constant(#t) string<delimiter(")content(~A)content(\\n)delimiter(")> operator(()ident(string-length) ident(line)operator(\))operator(\))operator(\))
  operator(()ident(close) ident(p)operator(\))operator(\))

comment(;; you can use with-input-from-file to temporarily rebind stdin:)
operator(()ident(with-input-from-file) ident(file)
  operator(()keyword(lambda) operator(()operator(\))
    operator(()keyword(do) operator(()operator(()ident(line) operator(()ident(read-line)operator(\)) operator(()ident(read-line)operator(\))operator(\))operator(\))
        operator(()operator(()ident(eof-object?) ident(line)operator(\))operator(\))
      operator(()ident(format) predefined_constant(#t) string<delimiter(")content(~A)content(\\n)delimiter(")> operator(()ident(string-length) ident(line)operator(\))operator(\))operator(\))operator(\))operator(\))

comment(;; or define a utility procedure to do this)
operator(()keyword(define) operator(()ident(for-each-line) ident(proc) ident(file)operator(\))
  operator(()ident(with-input-from-file) ident(file)
    operator(()keyword(lambda) operator(()operator(\))
      operator(()keyword(do) operator(()operator(()ident(line) operator(()ident(read-line)operator(\)) operator(()ident(read-line)operator(\))operator(\))operator(\))
          operator(()operator(()ident(eof-object?) ident(line)operator(\))operator(\))
        operator(()ident(proc) ident(line)operator(\))operator(\))operator(\))operator(\))operator(\))
operator(()ident(for-each-line) operator(()keyword(lambda) operator(()ident(x)operator(\)) operator(()ident(format) predefined_constant(#t) string<delimiter(")content(~A)content(\\n)delimiter(")> operator(()ident(string-length) ident(line)operator(\))operator(\))operator(\)) ident(file)operator(\))

comment(;; read in the file as a list of lines)
operator(()keyword(define) operator(()ident(read-lines) ident(file)operator(\))
  operator(()keyword(let) operator(()operator(()ident(ls) operator(')operator(()operator(\))operator(\))operator(\))
    operator(()ident(with-input-from-file) ident(file)
      operator(()keyword(lambda) operator(()operator(\))
        operator(()keyword(do) operator(()operator(()ident(line) operator(()ident(read-line)operator(\)) operator(()ident(read-line)operator(\))operator(\))operator(\))
            operator(()operator(()ident(eof-object?) ident(line)operator(\))operator(\))
          operator(()keyword(set!) ident(ls) operator(()keyword(cons) ident(line) ident(ls)operator(\))operator(\))operator(\))
        operator(()ident(reverse) ident(ls)operator(\))operator(\))operator(\))operator(\))operator(\))

comment(;; read in the file as a single string)
operator(()keyword(define) operator(()ident(file-contents) ident(file)operator(\))
  operator(()ident(call-with-input-file) ident(file)
    operator(()keyword(lambda) operator(()ident(p)operator(\))
      operator(()keyword(let*) operator(()operator(()ident(size) operator(()ident(stat:size) operator(()ident(stat) ident(p)operator(\))operator(\))operator(\))
             operator(()ident(buf) operator(()ident(make-string) ident(size)operator(\))operator(\))operator(\))
        operator(()ident(read-string!/partial) ident(buf) ident(p)operator(\))
        ident(buf)operator(\))operator(\))operator(\))operator(\))

comment(;; use display to print human readable output)
operator(()ident(display) operator(')operator(()string<delimiter(")content(One)delimiter(")> string<delimiter(")content(two)delimiter(")> string<delimiter(")content(three)delimiter(")>operator(\)) ident(port)operator(\))  comment(; (One two three\))
operator(()ident(display) string<delimiter(")content(Baa baa black sheep.)content(\\n)delimiter(")>operator(\))     comment(; Sent to default output port)

comment(;; use write to print machine readable output)
operator(()ident(write) operator(')operator(()string<delimiter(")content(One)delimiter(")> string<delimiter(")content(two)delimiter(")> string<delimiter(")content(three)delimiter(")>operator(\)) ident(port)operator(\))    comment(; ("One" "two" "three"\))

comment(;; use (ice-9 rw\) to read/write fixed-length blocks of data:)
operator(()ident(use-modules) operator(()ident(ice-9) ident(rw)operator(\))operator(\))
operator(()keyword(let) operator(()operator(()ident(buffer) operator(()ident(make-string) integer(4096)operator(\))operator(\))operator(\))
  operator(()ident(read-string!/partial) ident(buffer) ident(port) integer(4096)operator(\))operator(\))

comment(;; truncate-file)
operator(()ident(truncate-file) ident(port) ident(length)operator(\))  comment(; truncate to length)
operator(()ident(truncate-file) ident(port)operator(\))         comment(; truncate to current pos)

comment(;; ftell)
operator(()keyword(define) ident(pos) operator(()ident(ftell) ident(port)operator(\))operator(\))
operator(()ident(format) predefined_constant(#t) string<delimiter(")content(I'm ~A bytes from the start of DATAFILE.)content(\\n)delimiter(")> ident(pos)operator(\))

comment(;; seek)
operator(()ident(seek) ident(log-port) integer(0) ident(SEEK_END)operator(\))      comment(; seek to end)
operator(()ident(seek) ident(data-port) ident(pos) ident(SEEK_SET)operator(\))   comment(; seek to pos)
operator(()ident(seek) ident(out-port) ident(-)integer(20) ident(SEEK_CUR)operator(\))    comment(; seek back 20 bytes)

comment(;; block read/write)
operator(()ident(use-modules) operator(()ident(ice-9) ident(rw)operator(\))operator(\))
operator(()ident(write-string/partial) ident(mystring) ident(data-port) operator(()ident(string-length) ident(mystring)operator(\))operator(\))
operator(()ident(read-string!/partial) ident(block) integer(256) integer(5)operator(\))

comment(;; @@PLEAC@@_8.1)
operator(()keyword(let) operator(()operator(()ident(rx) operator(()ident(make-regexp) string<delimiter(")content((.*\))content(\\\\)content(\\\\)content($)delimiter(")>operator(\))operator(\))operator(\)) comment(; or "(.*\)\\\\\\\\\\\\s*$")
  operator(()ident(with-input-from-file) ident(file)
    operator(()keyword(lambda) operator(()operator(\))
      operator(()keyword(let) ident(loop) operator(()operator(()ident(line) operator(()ident(read-line)operator(\))operator(\))operator(\))
        operator(()keyword(if) operator(()ident(not) operator(()ident(eof-object?) ident(line)operator(\))operator(\))
          operator(()keyword(let) operator(()operator(()ident(m) operator(()ident(regexp-exec) ident(rx) ident(line)operator(\))operator(\))
                operator(()ident(next) operator(()ident(read-line)operator(\))operator(\))operator(\))
            operator(()keyword(cond) operator(()operator(()keyword(and) ident(m) operator(()ident(not) operator(()ident(eof-object?) ident(next)operator(\))operator(\))operator(\))
                   operator(()ident(loop) operator(()ident(string-append) operator(()ident(match:substring) ident(m) integer(1)operator(\)) ident(next)operator(\))operator(\))operator(\))
                  operator(()ident(else)
                   comment(;; else process line here, then recurse)
                   operator(()ident(loop) ident(next)operator(\))operator(\))operator(\))operator(\))operator(\))operator(\))operator(\))operator(\))operator(\))

comment(;; @@PLEAC@@_8.2)
operator(()keyword(do) operator(()operator(()ident(line) operator(()ident(read-line) ident(p)operator(\)) operator(()ident(read-line) ident(p)operator(\))operator(\))
     operator(()ident(i) integer(0) operator(()integer(1)ident(+) ident(i)operator(\))operator(\))operator(\))
    operator(()operator(()ident(eof-object?) ident(line)operator(\)) ident(i)operator(\))operator(\))

comment(;; fastest way if your terminator is a single newline)
operator(()ident(use-modules) operator(()ident(ice-9) ident(rw)operator(\)) operator(()ident(srfi) ident(srfi-13)operator(\))operator(\))
operator(()keyword(let) operator(()operator(()ident(buf) operator(()ident(make-string) operator(()ident(expt) integer(2) integer(16)operator(\))operator(\))operator(\))
      operator(()ident(count) integer(0)operator(\))operator(\))
  operator(()keyword(do) operator(()operator(()ident(len) operator(()ident(read-string!/partial) ident(buf) ident(p)operator(\)) operator(()ident(read-string!/partial) ident(buf) ident(p)operator(\))operator(\))operator(\))
      operator(()operator(()ident(not) ident(len)operator(\)) ident(count)operator(\))
    operator(()keyword(set!) ident(count) operator(()ident(+) ident(count) operator(()ident(string-count) ident(buf) char(#\\newline) integer(0) ident(len)operator(\))operator(\))operator(\))operator(\))operator(\))

comment(;; or use port-line)
operator(()keyword(let) ident(loop) operator(()operator(()ident(line) operator(()ident(read-line) ident(p)operator(\))operator(\))operator(\))
  operator(()keyword(if) operator(()ident(eof-object?) ident(line)operator(\)) operator(()ident(port-line) ident(p)operator(\)) operator(()ident(loop) operator(()ident(read-line) ident(p)operator(\))operator(\))operator(\))operator(\))

comment(;; @@PLEAC@@_8.3)
comment(;; default behaviour of string-tokenize is to split on whitespace:)
operator(()ident(use-modules) operator(()ident(srfi) ident(srfi-13)operator(\))operator(\))
operator(()keyword(let) ident(loop) operator(()operator(()ident(line) operator(()ident(read-line) ident(p)operator(\))operator(\))operator(\))
  operator(()keyword(cond) operator(()operator(()ident(not) ident(eof-object?) ident(line)operator(\))
         operator(()ident(for-each) ident(some-function-of-word) operator(()ident(string-tokenize) ident(line)operator(\))operator(\))
         operator(()ident(loop) operator(()ident(read-line) ident(p)operator(\))operator(\))operator(\))operator(\))operator(\))

operator(()keyword(let) operator(()operator(()ident(table) operator(()ident(make-hash-table) integer(31)operator(\))operator(\))operator(\))
  operator(()keyword(let) ident(loop) operator(()operator(()ident(line) operator(()ident(read-line) ident(p)operator(\))operator(\))operator(\))
    operator(()keyword(cond) operator(()operator(()ident(not) operator(()ident(eof-object?) ident(line)operator(\))operator(\))
           operator(()ident(for-each)
            operator(()keyword(lambda) operator(()ident(w)operator(\)) operator(()ident(hash-set!) ident(table) ident(w) operator(()integer(1)ident(+) operator(()ident(hash-ref) ident(table) ident(w) integer(0)operator(\))operator(\))operator(\))operator(\))
            operator(()ident(string-tokenize) ident(line)operator(\))operator(\))
           operator(()ident(loop) operator(()ident(read-line) ident(p)operator(\))operator(\))operator(\))operator(\))operator(\))
  operator(()ident(hash-fold) operator(()keyword(lambda) operator(()ident(k) ident(v) ident(p)operator(\)) operator(()ident(format) predefined_constant(#t) string<delimiter(")content(~5D ~A)content(\\n)delimiter(")> ident(v) ident(k)operator(\))operator(\)) predefined_constant(#f) ident(table)operator(\))operator(\))

comment(;; @@PLEAC@@_8.4)
comment(;; build up the list the reverse it or fold over it:)
operator(()keyword(define) ident(lines) operator(()ident(read-lines) ident(file)operator(\))operator(\))
operator(()ident(for-each) operator(()keyword(lambda) operator(()ident(word)operator(\)) ident(do-something-with-word)operator(\)) operator(()ident(reverse) ident(lines)operator(\))operator(\))
operator(()ident(fold) operator(()keyword(lambda) operator(()ident(word) ident(acc)operator(\)) ident(do-something-with-word)operator(\)) predefined_constant(#f) ident(lines)operator(\))

comment(;; @@PLEAC@@_8.5)
comment(;; save the current position and reseek to it)
operator(()keyword(define) operator(()ident(tail) ident(file)operator(\))
  operator(()ident(call-with-input-file) ident(file)
    operator(()keyword(lambda) operator(()ident(p)operator(\))
      operator(()keyword(let) ident(loop) operator(()operator(()ident(line) operator(()ident(read-line) ident(p)operator(\))operator(\))operator(\))
        operator(()keyword(cond) operator(()operator(()ident(eof-object?) ident(line)operator(\))
               operator(()ident(sleep) ident(sometime)operator(\))
               operator(()keyword(let) operator(()operator(()ident(pos) operator(()ident(ftell) ident(p)operator(\))operator(\))operator(\))
                 operator(()ident(seek) ident(p) integer(0) ident(SEEK_SET)operator(\))
                 operator(()ident(seek) ident(p) ident(pos) ident(SEEK_SET)operator(\))operator(\))operator(\))
              operator(()ident(else)
               comment(;; process line)
               operator(\))operator(\))
        operator(()ident(loop) operator(()ident(read-line) ident(p)operator(\))operator(\))operator(\))operator(\))operator(\))operator(\))

comment(;; @@PLEAC@@_8.6)
operator(()keyword(let) operator(()operator(()ident(rand-line) predefined_constant(#f)operator(\))operator(\))
  operator(()keyword(let) ident(loop) operator(()operator(()ident(line) operator(()ident(read-line) ident(p)operator(\))operator(\))operator(\))
    operator(()keyword(cond) operator(()operator(()ident(not) operator(()ident(eof-object?) ident(line)operator(\))operator(\))
           operator(()keyword(if) operator(()ident(=) integer(0) operator(()ident(random) operator(()ident(port-line) ident(p)operator(\))operator(\))operator(\))
             operator(()keyword(set!) ident(rand-line) ident(line)operator(\))operator(\))
           operator(()ident(loop) operator(()ident(read-line) ident(p)operator(\))operator(\))operator(\))operator(\))operator(\))
  comment(;; rand-line is the random line)
  operator(\))

comment(;; @@PLEAC@@_8.7)
operator(()keyword(define) operator(()ident(shuffle) ident(list)operator(\))
  operator(()keyword(let) operator(()operator(()ident(v) operator(()ident(list->vector) ident(list)operator(\))operator(\))operator(\))
    operator(()keyword(do) operator(()operator(()ident(i) operator(()integer(1)ident(-) operator(()ident(vector-length) ident(v)operator(\))operator(\)) operator(()integer(1)ident(-) ident(i)operator(\))operator(\))operator(\))
        operator(()operator(()ident(<) ident(i) integer(0)operator(\)) operator(()ident(vector->list) ident(v)operator(\))operator(\))
      operator(()keyword(let) operator(()operator(()ident(j) operator(()ident(random) operator(()integer(1)ident(+) ident(i)operator(\))operator(\))operator(\))operator(\))
        operator(()keyword(cond) operator(()operator(()ident(not) operator(()ident(=) ident(i) ident(j)operator(\))operator(\))
               operator(()keyword(let) operator(()operator(()ident(temp) operator(()ident(vector-ref) ident(v) ident(i)operator(\))operator(\))operator(\))
                 operator(()ident(vector-set!) ident(v) ident(i) operator(()ident(vector-ref) ident(v) ident(j)operator(\))operator(\))
                 operator(()ident(vector-set!) ident(v) ident(j) ident(temp)operator(\))operator(\))operator(\))operator(\))operator(\))operator(\))operator(\))operator(\))

operator(()keyword(define) ident(rand-lines) operator(()ident(shuffle) operator(()ident(read-lines) ident(file)operator(\))operator(\))

comment(;; @@PLEAC@@_8.8)
comment(;; looking for line number desired-line-number)
operator(()keyword(do) operator(()operator(()ident(line) operator(()ident(read-line) ident(p)operator(\)) operator(()ident(read-line) ident(p)operator(\))operator(\))operator(\))
    operator(()operator(()ident(=) operator(()operator(()ident(port-line) ident(p)operator(\)) ident(desired-line-number)operator(\)) ident(line)operator(\))operator(\))operator(\))
comment(;; or read into a list)
operator(()keyword(define) ident(lines) operator(()ident(read-lines) ident(file)operator(\))operator(\))
operator(()ident(list-ref) ident(lines) ident(desired-line-number)operator(\))

comment(;; @@INCOMPLETE@@)
comment(; (define (build-index data-file index-file\))
comment(;   \))

comment(; (define (line-with-index data-file index-file line-number\))
comment(;   \))

comment(;; @@PLEAC@@_8.9)
comment(;; use string-tokenize with an appropriate character set)
operator(()ident(use-modules) operator(()ident(srfi) ident(srfi-13)operator(\)) operator(()ident(srfi) ident(srfi-14)operator(\))operator(\))
operator(()keyword(define) ident(fields) operator(()ident(string-tokenize) ident(line) operator(()ident(string->charset) string<delimiter(")content(+-)delimiter(")>operator(\))operator(\))operator(\))
operator(()keyword(define) ident(fields) operator(()ident(string-tokenize) ident(line) operator(()ident(string->charset) string<delimiter(")content(:)delimiter(")>operator(\))operator(\))operator(\))
operator(()keyword(define) ident(fields) operator(()ident(string-tokenize) ident(line)operator(\))operator(\))

comment(;; @@PLEAC@@_8.10)
operator(()keyword(let) operator(()operator(()ident(p) operator(()ident(open-file) ident(file) string<delimiter(")content(r+)delimiter(")>operator(\))operator(\))operator(\))
  operator(()keyword(let) operator(()operator(()ident(pos) integer(0)operator(\))operator(\))
    operator(()keyword(let) ident(loop) operator(()operator(()ident(line) operator(()ident(read-line) ident(p)operator(\))operator(\))operator(\))
      operator(()keyword(cond) operator(()operator(()ident(eof-object?) operator(()ident(peek-char) ident(p)operator(\))operator(\))
             operator(()ident(seek) ident(p) integer(0) ident(SEEK_SET)operator(\))
             operator(()ident(truncate-file) ident(p) ident(pos)operator(\))
             operator(()ident(close) ident(p)operator(\))operator(\))
            operator(()ident(else)
             operator(()keyword(set!) ident(pos) operator(()ident(ftell) ident(p)operator(\))operator(\))
             operator(()ident(loop) operator(()ident(read-line) ident(p)operator(\))operator(\))operator(\))operator(\))operator(\))operator(\))operator(\))

comment(;; @@PLEAC@@_8.11)
comment(;; no equivalent - don't know how Guile under windows handles this)

comment(;; @@PLEAC@@_8.12)
operator(()keyword(let*) operator(()operator(()ident(address) operator(()ident(*) ident(recsize) ident(recno)operator(\))operator(\))
       operator(()ident(buf) operator(()ident(make-string) ident(recsize)operator(\))operator(\))operator(\))
  operator(()ident(seek) ident(p) ident(address) ident(SEEK_SET)operator(\))
  operator(()ident(read-string!/partial) ident(buf) ident(p)operator(\))
  ident(buf)operator(\))

comment(;; @@PLEAC@@_8.13)
operator(()keyword(let*) operator(()operator(()ident(address) operator(()ident(*) ident(recsize) ident(recno)operator(\))operator(\))
       operator(()ident(buf) operator(()ident(make-string) ident(recsize)operator(\))operator(\))operator(\))
  operator(()ident(seek) ident(p) ident(address) ident(SEEK_SET)operator(\))
  operator(()ident(read-string!/partial) ident(buf) ident(p)operator(\))
  comment(;; modify buf, then write back with)
  operator(()ident(seek) ident(p) ident(address) ident(SEEK_SET)operator(\))
  operator(()ident(write-string/partial) ident(buf) ident(p)operator(\))
  operator(()ident(close) ident(p)operator(\))operator(\))

comment(;; @@INCOMPLETE@@)
comment(;; weekearly)

comment(;; @@PLEAC@@_8.14)
operator(()ident(seek) ident(p) ident(addr) ident(SEEK_SET)operator(\))
operator(()keyword(define) ident(str) operator(()ident(read-delimited) operator(()ident(make-string) integer(1) char(#\\n)ident(ul)operator(\)) ident(p)operator(\))operator(\))

error(#)ident(!/usr/local/bin/guile) ident(-)ident(s)
ident(!)error(#)
comment(;; bgets -- get a string from an address in a binary file)
operator(()ident(use-modules) operator(()ident(ice-9) ident(format)operator(\))operator(\))

operator(()keyword(define) ident(args) operator(()ident(cdr) operator(()ident(command-line)operator(\))operator(\))operator(\))
operator(()keyword(define) ident(file) operator(()ident(car) ident(args)operator(\))operator(\))
operator(()keyword(define) ident(addrs) operator(()ident(map) ident(string->number) operator(()ident(cdr) ident(args)operator(\))operator(\))operator(\))
operator(()keyword(define) ident(delims) operator(()ident(make-string) integer(1) char(#\\n)ident(ul)operator(\))operator(\))

operator(()ident(call-with-input-file) ident(file)
  operator(()keyword(lambda) operator(()ident(p)operator(\))
    operator(()ident(for-each)
     operator(()keyword(lambda) operator(()ident(addr)operator(\))
       operator(()ident(seek) ident(p) ident(addr) ident(SEEK_SET)operator(\))
       operator(()ident(format) predefined_constant(#t) string<delimiter(")content(~X ~O ~D ~S)content(\\n)delimiter(")> ident(addr) ident(addr) ident(addr)
               operator(()ident(read-delimited) ident(delims) ident(p)operator(\))operator(\))operator(\))
     ident(addrs)operator(\))operator(\))operator(\))

comment(;; @@INCOMPLETE@@)
comment(;; strings)

comment(;; @@PLEAC@@_9.0)
operator(()keyword(define) ident(entry) operator(()ident(stat) string<delimiter(")content(/usr/bin/vi)delimiter(")>operator(\))operator(\))
operator(()keyword(define) ident(entry) operator(()ident(stat) string<delimiter(")content(/usr/bin)delimiter(")>operator(\))operator(\))
operator(()keyword(define) ident(entry) operator(()ident(stat) ident(port)operator(\))operator(\))

operator(()ident(use-modules) operator(()ident(ice-9) ident(posix)operator(\))operator(\))

operator(()keyword(define) ident(inode) operator(()ident(stat) string<delimiter(")content(/usr/bin/vi)delimiter(")>operator(\))operator(\))
operator(()keyword(define) ident(ctime) operator(()ident(stat:ctime) ident(inode)operator(\))operator(\))
operator(()keyword(define) ident(size) operator(()ident(stat:size) ident(inode)operator(\))operator(\))

operator(()keyword(define) ident(F) operator(()ident(open-input-file) ident(filename)operator(\))operator(\))
comment(;; no equivalent - what defines -T?)
comment(; unless (-s F && -T _\) {)
comment(;     die "$filename doesn't have text in it.\\n";)
comment(; })

operator(()keyword(define) ident(dir) operator(()ident(opendir) string<delimiter(")content(/usr/bin)delimiter(")>operator(\))operator(\))
operator(()keyword(do) operator(()operator(()ident(filename) operator(()ident(readdir) ident(dir)operator(\)) operator(()ident(readdir) ident(dir)operator(\))operator(\))operator(\))
    operator(()operator(()ident(eof-object?) ident(filename)operator(\))operator(\))
  operator(()ident(format) predefined_constant(#t) string<delimiter(")content(Inside /usr/bin is something called ~A)content(\\n)delimiter(")> ident(filename)operator(\))operator(\))
operator(()ident(closedir) ident(dir)operator(\))

comment(;; @@PLEAC@@_9.1)
operator(()keyword(define) ident(inode) operator(()ident(stat) ident(filename)operator(\))operator(\))
operator(()keyword(define) ident(readtime) operator(()ident(stat:atime) ident(inode)operator(\))operator(\))
operator(()keyword(define) ident(writetime) operator(()ident(stat:mtime) ident(inode)operator(\))operator(\))

operator(()ident(utime) ident(newreadtime) ident(newwritetime) ident(filename)operator(\))

operator(()keyword(define) ident(seconds-per-day) operator(()ident(*) integer(60) integer(60) integer(24)operator(\))operator(\))
operator(()keyword(define) ident(inode) operator(()ident(stat) ident(file)operator(\))operator(\))
operator(()keyword(define) ident(atime) operator(()ident(stat:atime) ident(inode)operator(\))operator(\))
operator(()keyword(define) ident(mtime) operator(()ident(stat:mtime) ident(inode)operator(\))operator(\))
operator(()keyword(set!) ident(atime) operator(()ident(-) ident(atime) operator(()ident(*) integer(7) ident(seconds-per-day)operator(\))operator(\))operator(\))
operator(()keyword(set!) ident(mtime) operator(()ident(-) ident(mtime) operator(()ident(*) integer(7) ident(seconds-per-day)operator(\))operator(\))operator(\))
operator(()ident(utime) ident(file) ident(atime) ident(mtime)operator(\))

comment(;; mtime is optional)
operator(()ident(utime) ident(file) operator(()ident(current-time)operator(\))operator(\))
operator(()ident(utime) ident(file) operator(()ident(stat:atime) operator(()ident(stat) ident(file)operator(\))operator(\)) operator(()ident(current-time)operator(\))operator(\))

error(#)ident(!/usr/local/bin/guile) ident(-)ident(s)
ident(!)error(#)
comment(;; uvi - vi a file without changing its access times)

operator(()keyword(define) ident(file) operator(()ident(cadr) operator(()ident(command-line)operator(\))operator(\))operator(\))
operator(()keyword(define) ident(inode) operator(()ident(stat) ident(file)operator(\))operator(\))
operator(()keyword(define) ident(atime) operator(()ident(stat:atime) ident(inode)operator(\))operator(\))
operator(()keyword(define) ident(mtime) operator(()ident(stat:mtime) ident(inode)operator(\))operator(\))
operator(()ident(system) operator(()ident(string-append) operator(()keyword(or) operator(()ident(getenv) string<delimiter(")content(EDITOR)delimiter(")>operator(\))  string<delimiter(")content(vi)delimiter(")>operator(\)) string<delimiter(")content( )delimiter(")> ident(file)operator(\))operator(\))
operator(()ident(utime) ident(file) ident(atime) ident(mtime)operator(\))

comment(;; @@PLEAC@@_9.2)
operator(()ident(delete-file) ident(file)operator(\))

operator(()keyword(let) operator(()operator(()ident(count) integer(0)operator(\))operator(\))
  operator(()ident(for-each)
   operator(()keyword(lambda) operator(()ident(x)operator(\))
     operator(()ident(catch) predefined_constant(#t)
       operator(()keyword(lambda) operator(()operator(\)) operator(()ident(delete-file) ident(x)operator(\)) operator(()keyword(set!) ident(count) operator(()integer(1)ident(+) ident(count)operator(\))operator(\))operator(\))
       operator(()keyword(lambda) operator(()ident(err) operator(.) ident(args)operator(\)) predefined_constant(#f)operator(\))operator(\))operator(\))
   ident(file-list)operator(\))
  operator(()keyword(if) operator(()ident(not) operator(()ident(=) ident(count) operator(()ident(length) ident(file-list)operator(\))operator(\))operator(\))
    operator(()ident(format) operator(()ident(current-error-port)operator(\)) string<delimiter(")content(could only delete ~A of ~A files)delimiter(")>
            ident(count) operator(()ident(length) ident(file-list)operator(\))operator(\))operator(\))operator(\))

comment(;; @@PLEAC@@_9.3)
comment(;; use builtin copy-file)
operator(()ident(copy-file) ident(oldfile) ident(newfile)operator(\))
operator(()ident(rename-file) ident(oldfile) ident(newfile)operator(\))

comment(;; or do it by hand (clumsy, error-prone\))
operator(()ident(use-modules) operator(()ident(ice-9) ident(rw)operator(\)) operator(()ident(ice-9) ident(posix)operator(\))operator(\))
operator(()ident(with-input-from-file) ident(oldfile)
  operator(()keyword(lambda) operator(()operator(\))
    operator(()ident(call-with-output-file) ident(newfile)
      operator(()keyword(lambda) operator(()ident(p)operator(\))
        operator(()keyword(let*) operator(()operator(()ident(inode) operator(()ident(stat) ident(oldfile)operator(\))operator(\))
               operator(()ident(blksize) operator(()keyword(if) ident(inode) operator(()ident(stat:size) ident(inode)operator(\)) integer(16384)operator(\))operator(\))
               operator(()ident(buf) operator(()ident(make-string) ident(blksize)operator(\))operator(\))operator(\))
          operator(()keyword(let) ident(loop) operator(()operator(()ident(len) operator(()ident(read-string!/partial) ident(buf)operator(\))operator(\))operator(\))
            operator(()keyword(cond) operator(()operator(()keyword(and) ident(len) operator(()ident(>) ident(len) integer(0)operator(\))operator(\))
                   operator(()ident(write-string/partial) ident(buf) ident(p) integer(0) ident(len)operator(\))
                   operator(()ident(loop) operator(()ident(read-string!/partial) ident(buf)operator(\))operator(\))operator(\))operator(\))operator(\))operator(\))operator(\))operator(\))operator(\))operator(\))

comment(;; or call out to the system (non-portable, insecure\))
operator(()ident(system) operator(()ident(string-append) string<delimiter(")content(cp )delimiter(")> ident(oldfile) string<delimiter(")content( )delimiter(")> ident(newfile)operator(\))operator(\))    comment(; unix)
operator(()ident(system) operator(()ident(string-append) string<delimiter(")content(copy )delimiter(")> ident(oldfile) string<delimiter(")content( )delimiter(")> ident(newfile)operator(\))operator(\))  comment(; dos, vms)

comment(;; @@PLEAC@@_9.4)
comment(;; use a hash lookup of inodes)
operator(()ident(use-modules) operator(()ident(ice-9) ident(posix)operator(\))operator(\))
operator(()keyword(let) operator(()operator(()ident(seen) operator(()ident(make-hash-table) integer(31)operator(\))operator(\))operator(\))
  operator(()ident(for-each)
   operator(()keyword(lambda) operator(()ident(file)operator(\))
     operator(()keyword(let*) operator(()operator(()ident(stats) operator(()ident(stat) ident(file)operator(\))operator(\))
            operator(()ident(key) operator(()keyword(cons) operator(()ident(stat:dev) ident(stats)operator(\)) operator(()ident(stat:ino) ident(stats)operator(\))operator(\))operator(\))
            operator(()ident(val) operator(()ident(hash-ref) ident(seen) ident(key) integer(0)operator(\))operator(\))operator(\))
       operator(()keyword(cond) operator(()operator(()ident(=) ident(val) integer(0)operator(\))
              comment(;; do something with new file)
              operator(\))operator(\))
       operator(()ident(hash-set!) ident(seen) ident(key) operator(()integer(1)ident(+) ident(val)operator(\))operator(\))operator(\))operator(\))
   ident(file-names)operator(\))operator(\))

operator(()keyword(let) operator(()operator(()ident(seen) operator(()ident(make-hash-table) integer(31)operator(\))operator(\))operator(\))
  operator(()ident(for-each)
   operator(()keyword(lambda) operator(()ident(file)operator(\))
     operator(()keyword(let*) operator(()operator(()ident(stats) operator(()ident(stat) ident(file)operator(\))operator(\))
            operator(()ident(key) operator(()keyword(cons) operator(()ident(stat:dev) ident(stats)operator(\)) operator(()ident(stat:ino) ident(stats)operator(\))operator(\))operator(\))
            operator(()ident(val) operator(()ident(hash-ref) ident(seen) ident(key) operator(')operator(()operator(\))operator(\))operator(\))operator(\))
       operator(()ident(hash-set!) ident(seen) ident(key) operator(()keyword(cons) ident(file) ident(val)operator(\))operator(\))operator(\))operator(\))
   ident(file-names)operator(\))
  operator(()ident(hash-fold)
   operator(()keyword(lambda) operator(()ident(key) ident(value) ident(prior)operator(\))
     comment(;; process key == (dev . inode\), value == list of filenames)
     operator(\))
   operator(')operator(()operator(\)) ident(seen)operator(\))operator(\))

comment(;; @@PLEAC@@_9.5)
comment(;; use opendir, readdir, closedir)
operator(()keyword(let) operator(()operator(()ident(p) operator(()ident(opendir) ident(dir)operator(\))operator(\))operator(\))
  operator(()keyword(let) ident(loop) operator(()operator(()ident(file) operator(()ident(readdir) ident(p)operator(\))operator(\))operator(\))
    operator(()keyword(if) operator(()ident(eof-object?) ident(file)operator(\))
      operator(()ident(close) ident(p)operator(\))
      comment(;; do something with file)
      operator(\))operator(\))operator(\))

comment(;; or define a utility function for this)
operator(()keyword(define) operator(()ident(directory-files) ident(dir)operator(\))
  operator(()keyword(if) operator(()ident(not) operator(()ident(access?) ident(dir) ident(R_OK)operator(\))operator(\))
    operator(')operator(()operator(\))
    operator(()keyword(let) operator(()operator(()ident(p) operator(()ident(opendir) ident(dir)operator(\))operator(\))operator(\))
      operator(()keyword(do) operator(()operator(()ident(file) operator(()ident(readdir) ident(p)operator(\)) operator(()ident(readdir) ident(p)operator(\))operator(\))
           operator(()ident(ls) operator(')operator(()operator(\))operator(\))operator(\))
          operator(()operator(()ident(eof-object?) ident(file)operator(\)) operator(()ident(closedir) ident(p)operator(\)) operator(()ident(reverse!) ident(ls)operator(\))operator(\))
        operator(()keyword(set!) ident(ls) operator(()keyword(cons) ident(file) ident(ls)operator(\))operator(\))operator(\))operator(\))operator(\))operator(\))

comment(;; to skip . and ..)
operator(()ident(cddr) operator(()ident(directory-files) ident(dir)operator(\))operator(\))

comment(;; probably better to implement full Emacs style directory-files)
operator(()ident(use-modules) operator(()ident(ice-9) ident(posix)operator(\))operator(\))
operator(()keyword(define) ident(plain-files)
  operator(()keyword(let) operator(()operator(()ident(rx) operator(()ident(make-regexp) string<delimiter(")content(^)content(\\\\)content(.)delimiter(")>operator(\))operator(\))operator(\))
    operator(()keyword(lambda) operator(()ident(dir)operator(\))
      operator(()ident(sort) operator(()ident(filter) operator(()keyword(lambda) operator(()ident(x)operator(\)) operator(()ident(eq?) operator(')ident(regular) operator(()ident(stat:type) operator(()ident(stat) ident(x)operator(\))operator(\))operator(\))operator(\))
                    operator(()ident(map) operator(()keyword(lambda) operator(()ident(x)operator(\)) operator(()ident(string-append) ident(dir) string<delimiter(")content(/)delimiter(")> ident(x)operator(\))operator(\))
                         operator(()ident(remove) operator(()keyword(lambda) operator(()ident(x)operator(\)) operator(()ident(regexp-exec) ident(rx) ident(x)operator(\))operator(\))
                                 operator(()ident(cddr) operator(()ident(directory-files) ident(dir)operator(\))operator(\))operator(\))operator(\))operator(\))
            ident(string<)operator(\))operator(\))operator(\))operator(\))

comment(;; @@PLEAC@@_9.6)
operator(()keyword(define) operator(()ident(glob->regexp) ident(pat)operator(\))
  operator(()keyword(let) operator(()operator(()ident(len) operator(()ident(string-length) ident(pat)operator(\))operator(\))
        operator(()ident(ls) operator(')operator(()string<delimiter(")content(^)delimiter(")>operator(\))operator(\))
        operator(()ident(in-brace?) predefined_constant(#f)operator(\))operator(\))
    operator(()keyword(do) operator(()operator(()ident(i) integer(0) operator(()integer(1)ident(+) ident(i)operator(\))operator(\))operator(\))
        operator(()operator(()ident(=) ident(i) ident(len)operator(\))operator(\))
      operator(()keyword(let) operator(()operator(()ident(char) operator(()ident(string-ref) ident(pat) ident(i)operator(\))operator(\))operator(\))
        operator(()keyword(case) ident(char)
          operator(()operator(()char(#\\*)operator(\)) operator(()keyword(set!) ident(ls) operator(()keyword(cons) string<delimiter(")content([^.]*)delimiter(")> ident(ls)operator(\))operator(\))operator(\))
          operator(()operator(()char(#\\?)operator(\)) operator(()keyword(set!) ident(ls) operator(()keyword(cons) string<delimiter(")content([^.])delimiter(")> ident(ls)operator(\))operator(\))operator(\))
          operator(()operator(()char(#\\[)operator(\)) operator(()keyword(set!) ident(ls) operator(()keyword(cons) string<delimiter(")content([)delimiter(")> ident(ls)operator(\))operator(\))operator(\))
          operator(()operator(()char(#\\])operator(\)) operator(()keyword(set!) ident(ls) operator(()keyword(cons) string<delimiter(")content(])delimiter(")> ident(ls)operator(\))operator(\))operator(\))
          operator(()operator(()char(#\\\\)operator(\))
           operator(()keyword(set!) ident(i) operator(()integer(1)ident(+) ident(i)operator(\))operator(\))
           operator(()keyword(set!) ident(ls) operator(()keyword(cons) operator(()ident(make-string) integer(1) operator(()ident(string-ref) ident(pat) ident(i)operator(\))operator(\)) ident(ls)operator(\))operator(\))
           operator(()keyword(set!) ident(ls) operator(()keyword(cons) string<delimiter(")content(\\\\)delimiter(")> ident(ls)operator(\))operator(\))operator(\))
          operator(()ident(else)
           operator(()keyword(set!) ident(ls) operator(()keyword(cons) operator(()ident(regexp-quote) operator(()ident(make-string) integer(1) ident(char)operator(\))operator(\)) ident(ls)operator(\))operator(\))operator(\))operator(\))operator(\))operator(\))
    operator(()ident(string-concatenate) operator(()ident(reverse) operator(()keyword(cons) string<delimiter(")content($)delimiter(")> ident(ls)operator(\))operator(\))operator(\))operator(\))operator(\))

operator(()keyword(define) operator(()ident(glob) ident(pat) ident(dir)operator(\))
  operator(()keyword(let) operator(()operator(()ident(rx) operator(()ident(make-regexp) operator(()ident(glob->regexp) ident(pat)operator(\))operator(\))operator(\))operator(\))
    operator(()ident(filter) operator(()keyword(lambda) operator(()ident(x)operator(\)) operator(()ident(regexp-exec) ident(rx) ident(x)operator(\))operator(\)) operator(()ident(directory-files) ident(dir)operator(\))operator(\))operator(\))operator(\))

operator(()keyword(define) ident(files) operator(()ident(glob) string<delimiter(")content(*.c)delimiter(")> string<delimiter(")content(.)delimiter(")>operator(\))operator(\))
operator(()keyword(define) ident(files) operator(()ident(glob) string<delimiter(")content(*.[ch])delimiter(")> string<delimiter(")content(.)delimiter(")>operator(\))operator(\))

comment(;; Not sure if the Schwartzian Transform would really be more)
comment(;; efficient here... perhaps with a much larger directory where very)
comment(;; few files matched.)
operator(()keyword(define) ident(dirs) operator(()ident(filter)
              operator(()keyword(lambda) operator(()ident(x)operator(\)) operator(()ident(eq?) operator(')ident(directory) operator(()ident(stat:type) operator(()ident(stat) ident(x)operator(\))operator(\))operator(\))operator(\))
              operator(()ident(map) operator(()keyword(lambda) operator(()ident(x)operator(\)) operator(()ident(string-append) ident(dir) string<delimiter(")content(/)delimiter(")> ident(x)operator(\))operator(\))
                   operator(()ident(sort) operator(()ident(filter) operator(()keyword(lambda) operator(()ident(x)operator(\)) operator(()ident(string-match) string<delimiter(")content(^[0-9]+$)delimiter(")> ident(x)operator(\))operator(\))
                                 operator(()ident(directory-files) ident(dir)operator(\))operator(\))
                         operator(()keyword(lambda) operator(()ident(a) ident(b)operator(\))
                           operator(()ident(<) operator(()ident(string->number) ident(a)operator(\)) operator(()ident(string->number) ident(b)operator(\))operator(\))operator(\))operator(\))operator(\))operator(\))operator(\))

comment(;; @@PLEAC@@_9.7)
operator(()keyword(define) operator(()ident(find) ident(proc) operator(.) ident(dirs)operator(\))
  operator(()keyword(cond) operator(()operator(()ident(pair?) ident(dirs)operator(\))
         operator(()ident(for-each) ident(proc) operator(()ident(map) operator(()keyword(lambda) operator(()ident(x)operator(\)) operator(()ident(string-append) operator(()ident(car) ident(dirs)operator(\)) string<delimiter(")content(/)delimiter(")> ident(x)operator(\))operator(\))
                             operator(()ident(directory-files) operator(()ident(car) ident(dirs)operator(\))operator(\))operator(\))operator(\))
         operator(()ident(apply) ident(find) ident(proc) operator(()ident(cdr) ident(dirs)operator(\))operator(\))operator(\))operator(\))operator(\))

operator(()ident(find) operator(()keyword(lambda) operator(()ident(x)operator(\)) operator(()ident(format) predefined_constant(#t) string<delimiter(")content(~A~A)content(\\n)delimiter(")> ident(x)
                          operator(()keyword(if) operator(()ident(equal?) operator(()ident(stat:type) operator(()ident(stat) ident(x)operator(\))operator(\)) operator(')ident(directory)operator(\))
                            string<delimiter(")content(/)delimiter(")> string<delimiter(")delimiter(")>operator(\))operator(\))operator(\)) string<delimiter(")content(.)delimiter(")>operator(\))

operator(()keyword(define) ident(saved-size) ident(-)integer(1)operator(\))
operator(()keyword(define) ident(saved-name) string<delimiter(")delimiter(")>operator(\))
operator(()keyword(define) operator(()ident(biggest) ident(file)operator(\))
  operator(()keyword(let) operator(()operator(()ident(stats) operator(()ident(stat) ident(file)operator(\))operator(\))operator(\))
    operator(()keyword(if) operator(()ident(eq?) operator(()ident(stat:type) ident(stats)operator(\)) operator(')ident(regular)operator(\))
      operator(()keyword(let) operator(()operator(()ident(size) operator(()ident(stat:size) operator(()ident(stat) ident(file)operator(\))operator(\))operator(\))operator(\))
        operator(()keyword(cond) operator(()operator(()ident(>) ident(size) ident(saved-size)operator(\))
               operator(()keyword(set!) ident(saved-size) ident(size)operator(\))
               operator(()keyword(set!) ident(saved-name) ident(file)operator(\))operator(\))operator(\))operator(\))operator(\))operator(\))operator(\))
operator(()ident(apply) ident(find) ident(biggest) operator(()ident(cdr) operator(()ident(command-line)operator(\))operator(\))operator(\))
operator(()ident(format) predefined_constant(#t) string<delimiter(")content(Biggest file ~A in ~A is ~A bytes long.)content(\\n)delimiter(")>
        ident(saved-name) operator(()ident(cdr) operator(()ident(command-line)operator(\))operator(\)) ident(saved-size)operator(\))

error(#)ident(!/usr/local/bin/guile) ident(-)ident(s)
ident(!)error(#)
comment(;; fdirs - find all directories)
operator(()keyword(define) operator(()ident(print-dirs) ident(f)operator(\))
  operator(()keyword(if) operator(()ident(eq?) operator(()ident(stat:type) operator(()ident(stat) ident(f)operator(\))operator(\)) operator(')ident(directory)operator(\))
    operator(()ident(write-line) ident(f)operator(\))operator(\))operator(\))
operator(()ident(apply) ident(find) ident(print-dirs) operator(()ident(cdr) operator(()ident(command-line)operator(\))operator(\))operator(\))

comment(;; @@PLEAC@@_9.8)
error(#)ident(!/usr/local/bin/guile) ident(-)ident(s)
ident(!)error(#)
comment(;; rmtree - remove whole directory trees like rm -f)
operator(()keyword(define) operator(()ident(finddepth) ident(proc) operator(.) ident(dirs)operator(\))
  operator(()keyword(cond) operator(()operator(()ident(pair?) ident(dirs)operator(\))
         operator(()ident(apply) ident(finddepth) ident(proc) operator(()ident(cdr) ident(dirs)operator(\))operator(\))
         operator(()ident(for-each) ident(proc) operator(()ident(map) operator(()keyword(lambda) operator(()ident(x)operator(\)) operator(()ident(string-append) operator(()ident(car) ident(dirs)operator(\)) string<delimiter(")content(/)delimiter(")> ident(x)operator(\))operator(\))
                             operator(()ident(directory-files) operator(()ident(car) ident(dirs)operator(\))operator(\))operator(\))operator(\))operator(\))operator(\))operator(\))
operator(()keyword(define) operator(()ident(zap) ident(f)operator(\))
  operator(()keyword(let) operator(()operator(()ident(rm) operator(()keyword(if) operator(()ident(eq?) operator(()ident(stat:type) operator(()ident(stat) ident(f)operator(\))operator(\)) operator(')ident(directory)operator(\)) ident(rmdir) ident(delete-file)operator(\))operator(\))operator(\))
    operator(()ident(format) predefined_constant(#t) string<delimiter(")content(deleting ~A)content(\\n)delimiter(")> ident(f)operator(\))
    operator(()ident(catch) predefined_constant(#t)
      operator(()keyword(lambda) operator(()operator(\)) operator(()ident(rm) ident(f)operator(\))operator(\))
      operator(()keyword(lambda) ident(args) operator(()ident(format) predefined_constant(#t) string<delimiter(")content(couldn't delete ~A)content(\\n)delimiter(")> ident(f)operator(\))operator(\))operator(\))operator(\))operator(\))
operator(()keyword(let) operator(()operator(()ident(args) operator(()ident(cdr) operator(()ident(command-line)operator(\))operator(\))operator(\))operator(\))
  operator(()keyword(if) operator(()ident(null?) ident(args)operator(\))
    operator(()ident(error) string<delimiter(")content(usage: rmtree dir ..)content(\\n)delimiter(")>operator(\))
    operator(()ident(apply) ident(finddepth) ident(zap) ident(args)operator(\))operator(\))operator(\))

comment(;; @@PLEAC@@_9.9)
operator(()ident(for-each)
 operator(()keyword(lambda) operator(()ident(file)operator(\))
   operator(()keyword(let) operator(()operator(()ident(newname) operator(()ident(function-of) ident(file)operator(\))operator(\))operator(\))
     operator(()ident(catch) predefined_constant(#t)
       operator(()keyword(lambda) operator(()operator(\)) operator(()ident(rename-file) ident(file) ident(newname)operator(\))operator(\))
       operator(()keyword(lambda) ident(args) operator(()ident(format) operator(()ident(current-error-port)operator(\))
                            string<delimiter(")content(couldn't rename ~A to ~A)content(\\n)delimiter(")> ident(file) ident(newname)operator(\))operator(\))operator(\))operator(\))operator(\))
 ident(names)operator(\))

error(#)ident(!/usr/local/bin/guile) ident(-)ident(s)
ident(!)error(#)
comment(;; rename - Guile's filename fixer)
operator(()ident(use-modules) operator(()ident(ice-9) ident(regex)operator(\))operator(\)) comment(; not needed, but often useful here)
operator(()keyword(define) ident(args) operator(()ident(cdr) operator(()ident(command-line)operator(\))operator(\))operator(\))
operator(()keyword(if) operator(()ident(null?) ident(args)operator(\)) operator(()ident(error) string<delimiter(")content(usage: rename expr [files])content(\\n)delimiter(")>operator(\))operator(\))
operator(()keyword(define) ident(proc) operator(()ident(eval-string) operator(()ident(car) ident(args)operator(\))operator(\))operator(\))
operator(()ident(for-each)
 operator(()keyword(lambda) operator(()ident(old)operator(\))
   operator(()keyword(let) operator(()operator(()ident(new) operator(()ident(proc) ident(old)operator(\))operator(\))operator(\))
     operator(()keyword(if) operator(()ident(not) operator(()ident(string=?) ident(old) ident(new)operator(\))operator(\))
       operator(()ident(catch) predefined_constant(#t)
         operator(()keyword(lambda) operator(()operator(\)) operator(()ident(rename-file) ident(old) ident(new)operator(\))operator(\))
         operator(()keyword(lambda) ident(args) operator(()ident(format) operator(()ident(current-error-port)operator(\))
                              string<delimiter(")content(couldn't rename ~A to ~A)content(\\n)delimiter(")> ident(old) ident(new)operator(\))operator(\))operator(\))operator(\))operator(\))operator(\))
 operator(()ident(cdr) ident(args)operator(\))operator(\))

comment(;; command-line examples:)
comment(;; rename '(lambda (x\) (regexp-substitute/global #f "\\\\.orig\\$" x (quote pre\)\)\)' *.orig)
comment(;; rename string-downcase *)
comment(;; rename '(lambda (x\) (if (string-match "^Make" x\) x (string-downcase x\)\)\)' *)
comment(;; rename '(lambda (x\) (string-append x ".bad"\)\)' *.pl)
comment(;; rename '(lambda (x\) (format #t "~a: "\) (read-line\)\)' *)

comment(;; @@PLEAC@@_9.10)
operator(()keyword(define) ident(base) operator(()ident(basename) ident(path)operator(\))operator(\))
operator(()keyword(define) ident(base) operator(()ident(dirname) ident(path) ident(ext)operator(\))operator(\))
operator(()keyword(define) ident(dir) operator(()ident(dirname) ident(path)operator(\))operator(\))

operator(()keyword(define) ident(path) string<delimiter(")content(/usr/lib/libc.a)delimiter(")>operator(\))
operator(()keyword(define) ident(file) operator(()ident(basename) ident(path)operator(\))operator(\))
operator(()keyword(define) ident(dir) operator(()ident(dirname) ident(path)operator(\))operator(\))

operator(()ident(format) predefined_constant(#t) string<delimiter(")content(dir is ~A, file is ~A)content(\\n)delimiter(")> ident(dir) ident(file)operator(\))

operator(()ident(basename) ident(path) string<delimiter(")content(.a)delimiter(")>operator(\)) comment(; libc)

operator(()ident(use-modules) operator(()ident(ice-9) ident(regex)operator(\))operator(\))
operator(()keyword(define) operator(()ident(file-parse) ident(path) operator(.) ident(args)operator(\))
  operator(()keyword(let*) operator(()operator(()ident(ext) operator(()keyword(if) operator(()ident(null?) ident(args)operator(\)) string<delimiter(")content(\\\\)content(..*)delimiter(")> operator(()ident(car) ident(args)operator(\))operator(\))operator(\))
         operator(()ident(rx1) operator(()ident(string-append) string<delimiter(")content(^((.*\)/\)?(.*\)?()delimiter(")> ident(ext) string<delimiter(")content(\)$)delimiter(")>operator(\))operator(\))
         operator(()ident(rx2) operator(()ident(string-append) string<delimiter(")content(^((.*\)/\)?(.*\)?(\)$)delimiter(")>operator(\))operator(\))operator(\))
    operator(()keyword(let) operator(()operator(()ident(m) operator(()keyword(or) operator(()ident(string-match) ident(rx1) ident(path)operator(\)) operator(()ident(string-match) ident(rx2) ident(path)operator(\))operator(\))operator(\))operator(\))
      operator(()ident(list) operator(()ident(match:substring) ident(m) integer(2)operator(\)) operator(()ident(match:substring) ident(m) integer(3)operator(\))
            operator(()ident(match:substring) ident(m) integer(4)operator(\))operator(\))operator(\))operator(\))operator(\))

operator(()keyword(define) operator(()ident(extension) ident(path) operator(.) ident(args)operator(\))
  operator(()ident(caddr) operator(()ident(apply) ident(file-parse) ident(path) ident(args)operator(\))operator(\))operator(\))

comment(;; @@PLEAC@@_10.0)
comment(; Note: Some of the examples will show code blocks in this style:)
comment(;)
comment(;  (define)
comment(;    ... code here ...)
comment(;  \))
comment(;)
comment(; This is not generally considered good style, and is not recommended;)
comment(; it is only used here to more clearly highlight block scope )

comment(; By convention a 'global variable' i.e. a variable that is defined at)
comment(; the top-level, and as such, visible within any scope, is named with)
comment(; beginning and ending asterisks [and one to be used as a constant)
comment(; with beginning and ending plus signs])

operator(()keyword(define) ident(*greeted*) integer(0)operator(\))

operator(()keyword(define) operator(()ident(hello)operator(\))
  operator(()keyword(set!) ident(*greeted*) operator(()ident(+) ident(*greeted*) integer(1)operator(\))operator(\))
  operator(()ident(print) string<delimiter(")content(hi there!, this procedure has been called)delimiter(")> ident(*greeted*) string<delimiter(")content(times)delimiter(")>operator(\))operator(\))

operator(()keyword(define) operator(()ident(how-many-greetings)operator(\)) ident(*greeted*)operator(\))

comment(;; ------------)

operator(()ident(hello)operator(\))

operator(()keyword(define) ident(*greetings*) operator(()ident(how-many-greetings)operator(\))operator(\))

operator(()ident(print) string<delimiter(")content(bye there!, there have been)delimiter(")> ident(*greetings*) string<delimiter(")content(greetings so far)delimiter(")>operator(\))

comment(;; @@PLEAC@@_10.1)
comment(; Subroutine parameters are named [whether directly, or indirectly in)
comment(; the case of variable arguments - see next example]; this is the only)
comment(; means of access [This contrasts with languages like Perl and REXX which)
comment(; allow access to arguments via array subscripting, and function calls,)
comment(; respectively])
operator(()keyword(define) operator(()ident(hypotenuse) ident(side1) ident(side2)operator(\))
  operator(()ident(sqrt) operator(()ident(sum) operator(()ident(*) ident(side1) ident(side1)operator(\)) operator(()ident(*) ident(side2) ident(side2)operator(\))operator(\))operator(\))operator(\))

operator(()keyword(define) ident(*diag*) operator(()ident(hypotenuse) integer(3) integer(4)operator(\))operator(\))

comment(;; ----)

comment(; 'other-sides' is the name of a list of containing any additional)
comment(; parameters. Note that a name is still used to access values)
operator(()keyword(define) operator(()ident(hypotenuse) ident(side1) operator(.) ident(other-sides)operator(\))
  operator(()keyword(let) operator(()operator(()ident(all-sides) operator(()keyword(cons) ident(side1) ident(other-sides)operator(\))operator(\))operator(\))
    operator(()ident(for-each)
      operator(()keyword(lambda) operator(()ident(side)operator(\)) ident(...)operator(\))
      ident(all-sides)operator(\))
  ident(...)operator(\))operator(\))

comment(;; ----)

operator(()keyword(define) ident(*diag*) operator(()ident(hypotenuse) integer(3) integer(4)operator(\))operator(\))

comment(;; ----)

comment(; Possible to pack parameters into a single structure [e.g. list or)
comment(; array], and access values contained therein)
operator(()keyword(define) operator(()ident(hypotenuse) ident(sides)operator(\))
  operator(()keyword(let) operator(()operator(()ident(side1) operator(()ident(car) ident(sides)operator(\))operator(\)) operator(()ident(side2) operator(()ident(caar) ident(sides)operator(\))operator(\))operator(\))
    operator(()ident(sqrt) operator(()ident(sum) operator(()ident(*) ident(side1) ident(side1)operator(\)) operator(()ident(*) ident(side2) ident(side2)operator(\))operator(\))operator(\))operator(\))operator(\))

comment(;; ----)

operator(()keyword(define) ident(*args*) operator(')operator(()integer(3) integer(4)operator(\))operator(\))
operator(()keyword(define) ident(*diag*) operator(()ident(hypotenuse) ident(*args*)operator(\))operator(\))

comment(;; ------------)

comment(; Parameters passed by reference, however, whether original object is)
comment(; modified depends on choice of functions used to manipulate them)
comment(; [most functions create copies and return these; mutating versions of)
comment(; same functions may also exist [see next example] )
operator(()keyword(define) ident(*nums*) operator(()ident(vector) integer(1.4) integer(3.5) integer(6.7)operator(\))operator(\))

operator(()keyword(define) operator(()ident(int-all) ident(vec)operator(\))
  operator(()ident(vector-map-in-order)
    operator(()keyword(lambda) operator(()ident(element)operator(\)) operator(()ident(inexact->exact) operator(()ident(round) ident(element)operator(\))operator(\))operator(\))
    ident(vec)operator(\))operator(\))

comment(; Copy created)
operator(()keyword(define) ident(*ints*) operator(()ident(int-all) ident(*nums*)operator(\))operator(\))

operator(()ident(print) ident(*nums*)operator(\))
operator(()ident(print) ident(*ints*)operator(\))

comment(;; ----)

operator(()keyword(define) ident(*nums*) operator(()ident(vector) integer(1.4) integer(3.5) integer(6.7)operator(\))operator(\))

operator(()keyword(define) operator(()ident(trunc-all) ident(vec)operator(\))
  operator(()ident(array-map-in-order!)
    operator(()keyword(lambda) operator(()ident(element)operator(\)) operator(()ident(inexact->exact) operator(()ident(round) ident(element)operator(\))operator(\))operator(\))
    ident(vec)operator(\))operator(\))

comment(; Original modified)
operator(()ident(trunc-all) ident(*nums*)operator(\))

comment(;; @@PLEAC@@_10.2)
comment(; Scheme is lexically-scoped; variables defined within a block are)
comment(; visible only within that block. Whilst nested / subordinate blocks)
comment(; have access to those variables, neither the caller, nor any called)
comment(; procedures have direct access to those same variables)

operator(()keyword(define) operator(()ident(some-func) ident(parm1) ident(parm2) ident(parm3)operator(\))
  ident(...) ident(paramaters) ident(visible) ident(here) ident(...)

  operator(()keyword(let) operator(()operator(()ident(var1) ident(...)operator(\)) operator(()ident(var2) ident(...)operator(\)) operator(()ident(var3) ident(...)operator(\)) ident(...)operator(\))
    ident(...) ident(parameters) ident(also) ident(visible) ident(here)error(,) ident(but) ident(variables)error(,) operator(')ident(var1)operator(') ident(etc)
        ident(only) ident(visible) ident(within) ident(this) ident(block) ident(...)
  operator(\))
  ident(...) ident(paramaters) ident(also) ident(visible) ident(here)error(,) ident(but) ident(still) ident(within) ident(procedure) ident(body) ident(...)
operator(\))

comment(;; ------------)

comment(; Top-level definitions - accessable globally )
operator(()keyword(define) ident(*name*) operator(()ident(caar) operator(()ident(command-line)operator(\))operator(\))operator(\))
operator(()keyword(define) ident(*age*) operator(()ident(cadr) operator(()ident(command-line)operator(\))operator(\))operator(\))

operator(()keyword(define) ident(*start*) operator(()ident(fetch-time)operator(\))operator(\))

comment(;; ----)

comment(; Lexical binding - accessable only within this block)
operator(()keyword(let) operator(()operator(()ident(name) operator(()ident(caar) operator(()ident(command-line)operator(\))operator(\))operator(\))
      operator(()ident(age) operator(()ident(cadr) operator(()ident(command-line)operator(\))operator(\))operator(\))
      operator(()ident(start) operator(()ident(fetch-time)operator(\))operator(\))operator(\))
   ident(...) ident(variables) ident(only) ident(visible) ident(here) ident(...)
operator(\))

comment(;; ------------)

operator(()keyword(define) ident(*pair*) operator(')operator(()integer(1) operator(.) integer(2)operator(\))operator(\))

comment(; 'a' and 'b' need to be dereferenced and separately defined [Also,)
comment(; since globally defined, should really be named, '*a*', '*b*', etc])
operator(()keyword(define) ident(a) operator(()ident(car) ident(*pair*)operator(\))operator(\))
operator(()keyword(define) ident(b) operator(()ident(cdr) ident(*pair*)operator(\))operator(\))
operator(()keyword(define) ident(c) operator(()ident(fetch-time)operator(\))operator(\))

operator(()keyword(define) operator(()ident(run-check)operator(\))
  ident(...) keyword(do) ident(something) ident(with) operator(')ident(a)operator(')error(,) operator(')ident(b)operator(')error(,) keyword(and) operator(')ident(c)operator(') ident(...)
operator(\))

operator(()keyword(define) operator(()ident(check-x) ident(x) ident(y)operator(\))
  operator(()keyword(if) operator(()ident(run-check)operator(\))
    operator(()ident(print) string<delimiter(")content(got)delimiter(")> ident(x)operator(\))operator(\))operator(\))

comment(; Calling 'check-x'; 'run-check' has access to 'a', 'b', and 'c')
operator(()ident(check-x) ident(...)operator(\))

comment(;; ----)

comment(; If defined within a block, variables 'a', 'b', and 'c' are no longer)
comment(; accessable anywhere except that scope. Therefore, 'run-check' as)
comment(; defined above can no longer access these variables [in fact, the code)
comment(; will fail because variables 'a', 'b', and 'c' do not exist when)
comment(; 'run-check' is defined])
operator(()keyword(let) operator(()operator(()ident(a) operator(()ident(car) ident(*pair*)operator(\))operator(\))
      operator(()ident(b) operator(()ident(cdr) ident(*pair*)operator(\))operator(\))
      operator(()ident(c) operator(()ident(fetch-time)operator(\))operator(\))operator(\))
   ident(...)
   operator(()ident(check-x) ident(...)operator(\))  
   ident(...)
operator(\))

comment(;; ----)

comment(; The procedures, 'run-check' and 'check-x' are defined within the)
comment(; same block as variables, 'a', 'b', and 'c', so have direct access to)
comment(; them)
operator(()keyword(let*) operator(()operator(()ident(a) operator(()ident(car) ident(*pair*)operator(\))operator(\))
       operator(()ident(b) operator(()ident(cdr) ident(*pair*)operator(\))operator(\))
       operator(()ident(c) operator(()ident(fetch-time)operator(\))operator(\))

       operator(()ident(run-check)
         operator(()keyword(lambda) operator(()operator(\)) ident(...) keyword(do) ident(something) ident(with) operator(')ident(a)operator(')error(,) operator(')ident(b)operator(')error(,) keyword(and) operator(')ident(c)operator(') ident(...)operator(\))operator(\))

       operator(()ident(check-x)
         operator(()keyword(lambda) operator(()ident(x) ident(y)operator(\))
           operator(()keyword(if) operator(()ident(run-check)operator(\))
             operator(()ident(print) string<delimiter(")content(got)delimiter(")> ident(x)operator(\))operator(\))operator(\))operator(\)) operator(\))
   ident(...)
   operator(()ident(check-x) ident(...)operator(\))  
   ident(...)
operator(\))

comment(;; @@PLEAC@@_10.3)
comment(; Ordinarily, a variable must be initialised when it is defined,)
comment(; whether at the top-level: )
operator(()keyword(define) ident(*variable*) integer(1)operator(\))

comment(; ... or within a 'let' binding)
operator(()keyword(let*) operator(()operator(()ident(variable) integer(1)operator(\))
       operator(()ident(mysub)
         operator(()keyword(lambda) operator(()operator(\)) ident(...) ident(accessing) operator(')ident(variable)operator(') ident(...)operator(\))operator(\))operator(\))
  ident(...) keyword(do) ident(stuff) ident(...)
operator(\))

comment(; However, since Scheme allows syntactic extensions via 'macros' [of)
comment(; which there are two varieties: hygenic and LISP-based], it is)
comment(; possible to create new forms which alter this behaviour. For example,)
comment(; in this tutorial: http://home.comcast.net/~prunesquallor/macro.txt)
comment(; there is a macro implementation equivalent to 'let, 'called,)
comment(; 'bind-values', which allows variables to be defined without initial)
comment(; values; an example follows:)

comment(; Initialisation values for 'a' and 'b' not specified)
operator(()ident(bind-values) operator(()operator(()ident(a)operator(\)) ident(b) operator(()ident(c) operator(()ident(+) ident(*global*) integer(5)operator(\))operator(\))operator(\))
  ident(...) keyword(do) ident(stuff) ident(...)
operator(\))

comment(; In Scheme many things are possible, but not all those things are)
comment(; offered as standard features :\) !)

comment(;; ------------)

operator(()keyword(let*) operator(()operator(()ident(counter) integer(42)operator(\))
       operator(()ident(next-counter)
         operator(()keyword(lambda) operator(()operator(\)) operator(()keyword(set!) ident(counter) operator(()ident(+) ident(counter) integer(1)operator(\))operator(\)) ident(counter)operator(\))operator(\))
       operator(()ident(prev-counter)
         operator(()keyword(lambda) operator(()operator(\)) operator(()keyword(set!) ident(counter) operator(()ident(-) ident(counter) integer(1)operator(\))operator(\)) ident(counter)operator(\))operator(\))operator(\))

  ident(...) keyword(do) ident(stuff) ident(with) operator(')ident(next-counter)operator(') keyword(and) operator(')ident(prev-counter)operator(') ident(...)
operator(\))

comment(;; ----)

comment(; A more complete, and practical, variation of the above code:)

comment(; 'counter' constructor)
operator(()keyword(define) operator(()ident(make-counter) ident(start)operator(\))
  operator(()keyword(let*) operator(()operator(()ident(counter) integer(42)operator(\))
         operator(()ident(next-counter)
           operator(()keyword(lambda) operator(()operator(\)) operator(()keyword(set!) ident(counter) operator(()ident(+) ident(counter) integer(1)operator(\))operator(\)) ident(counter)operator(\))operator(\))
         operator(()ident(prev-counter)
           operator(()keyword(lambda) operator(()operator(\)) operator(()keyword(set!) ident(counter) operator(()ident(-) ident(counter) integer(1)operator(\))operator(\)) ident(counter)operator(\))operator(\))operator(\))
  operator(()keyword(lambda) operator(()ident(op)operator(\))
    operator(()keyword(cond)
      operator(()operator(()ident(eq?) ident(op) operator(')ident(prev)operator(\)) ident(prev-counter)operator(\))
      operator(()operator(()ident(eq?) ident(op) operator(')ident(next)operator(\)) ident(next-counter)operator(\))
      operator(()ident(else) operator(()keyword(lambda) operator(()operator(\)) operator(()ident(display) string<delimiter(")content(error:counter)delimiter(")>operator(\))operator(\))operator(\)) operator(\))operator(\))operator(\))operator(\))

comment(; Interface functions to 'counter' functionality)
operator(()keyword(define) operator(()ident(prev-counter) ident(counter)operator(\)) operator(()ident(apply) operator(()ident(counter) operator(')ident(prev)operator(\)) operator(')operator(()operator(\))operator(\))operator(\))
operator(()keyword(define) operator(()ident(next-counter) ident(counter)operator(\)) operator(()ident(apply) operator(()ident(counter) operator(')ident(next)operator(\)) operator(')operator(()operator(\))operator(\))operator(\))

comment(; Create a 'counter')
operator(()keyword(define) ident(*counter*) operator(()ident(make-counter) integer(42)operator(\))operator(\))

comment(; Use the 'counter' ...)
operator(()ident(print) operator(()ident(prev-counter) ident(*counter*)operator(\))operator(\))
operator(()ident(print) operator(()ident(prev-counter) ident(*counter*)operator(\))operator(\))
operator(()ident(print) operator(()ident(next-counter) ident(*counter*)operator(\))operator(\))

comment(;; @@PLEAC@@_10.4)
comment(; Scheme interpreters generally provide a rich collection of procedure)
comment(; metadata, as well as easy access to a program's current 'execution)
comment(; state'. Put simply, provision of a powerful, highly customisable)
comment(; debugging / tracing facility is almost taken for granted. However, using)
comment(; it to perform as trivial a task as obtaining the current function name)
comment(; is less than trivial [at least it seems so in Guile] as it appears to)
comment(; require quite some setup work. Additionally, the documentation talks)
comment(; about facilities e.g. trap installation, that don't appear to be)
comment(; available [at least, I couldn't find them].)
comment(;)
comment(; Example below uses in-built debugging facilities to dump a backtrace)
comment(; to a string port and extract the caller's name from the resulting)
comment(; string. Not exactly elegant ...)

comment(; Execute using: guile --debug ... else no useful output seen)
operator(()ident(use-modules) operator(()ident(ice-9) ident(debug)operator(\))operator(\))

operator(()keyword(define) operator(()ident(child) ident(num)operator(\))
  comment(; Create stack [i.e. activation record] object, discarding)
  comment(; irrelevant frames)
  operator(()keyword(let) operator(()operator(()ident(s) operator(()ident(make-stack) predefined_constant(#t) integer(3) integer(1)operator(\))operator(\))
        operator(()ident(trace-string-port) operator(()ident(open-output-string)operator(\))operator(\))
        operator(()ident(parent-name) string<delimiter(")delimiter(")>operator(\))operator(\))

    comment(; Dump backtrace to string port)
    operator(()ident(display-backtrace) ident(s) ident(trace-string-port)operator(\))

    comment(; Extract caller's name from backtrace data)
    comment(; [shamefully crude - don't do this at home !])
    operator(()keyword(set!) ident(parent-name)
      operator(()ident(caddr) operator(()ident(string-tokenize)
               operator(()ident(cadr) operator(()ident(string-split)
                       operator(()ident(get-output-string) ident(trace-string-port)operator(\))
                       char(#\\newline)operator(\))operator(\))
               ident(char-set:graphic)operator(\))operator(\))operator(\))

    comment(; Who's your daddy ?)
    operator(()ident(print) ident(parent-name)operator(\))operator(\))operator(\))

comment(; Each invocation of 'child' should see 'parent' displayed as)
comment(; the caller)
operator(()keyword(define) operator(()ident(parent)operator(\))
  operator(()ident(child) integer(1)operator(\))
  operator(()ident(child) integer(2)operator(\))
  operator(()ident(child) integer(3)operator(\))operator(\))

operator(()ident(parent)operator(\)) 

comment(;; @@PLEAC@@_10.5)
comment(; Procedure parameters are references to entities, so there is no special)
comment(; treatment required. If an argument represents a mutable object such)
comment(; as an array, then care should be taken to not mutate the object within)
comment(; the procedure, or a copy of the object be made and used)

operator(()ident(array-diff) ident(*array1*) ident(*array2*)operator(\))

comment(;; ------------)

operator(()keyword(define) operator(()ident(add-vector-pair) ident(x) ident(y)operator(\))
  operator(()keyword(let*) operator(()operator(()ident(vector-length) operator(()ident(vector-length) ident(x)operator(\))operator(\))
         operator(()ident(new-vec) operator(()ident(make-vector) ident(vector-length)operator(\))operator(\))operator(\))
    operator(()keyword(let) ident(loop) operator(()operator(()ident(i) integer(0)operator(\))operator(\))
      operator(()keyword(cond) 
        operator(()operator(()ident(=) ident(i) ident(vector-length)operator(\)) ident(new-vec)operator(\))
        operator(()ident(else)
          operator(()ident(vector-set!) ident(new-vec) ident(i) operator(()ident(+) operator(()ident(vector-ref) ident(x) ident(i)operator(\)) operator(()ident(vector-ref) ident(y) ident(i)operator(\))operator(\))operator(\))
          operator(()ident(loop) operator(()ident(+) ident(i) integer(1)operator(\))operator(\)) operator(\))operator(\))operator(\)) operator(\))operator(\))

comment(;; ----)

operator(()keyword(define) ident(*a*) operator(')operator(#()integer(1) integer(2)operator(\))operator(\))
operator(()keyword(define) ident(*b*) operator(')operator(#()integer(5) integer(8)operator(\))operator(\))

operator(()keyword(define) ident(*c*) operator(()ident(add-vector-pair) ident(*a*) ident(*b*)operator(\))operator(\))

operator(()ident(print) ident(*c*)operator(\))

comment(;; ----)

  ident(...)

  operator(()keyword(if) operator(()keyword(and) operator(()ident(vector?) ident(a1)operator(\)) operator(()ident(vector?) ident(a2)operator(\))operator(\))
    operator(()ident(print) operator(()ident(add-vector-pair) ident(a1) ident(a2)operator(\))operator(\))
  comment(;else)
    operator(()ident(print) string<delimiter(")content(usage: add-vector-pair a1 a2)delimiter(")>operator(\))operator(\))

  ident(...)

comment(;; @@PLEAC@@_10.6)
comment(; AFAIK there is no Scheme equivalent to Perl's 'return context' where)
comment(; it is possible to use language primitives [e.g. 'wantarray'] to )
comment(; dynamically specify the return type of a procedure. It is, however,)
comment(; possible to:)
comment(; * Return one of several types from a procedure, whether based on )
comment(;   processing results [e.g. 'false' on error, numeric on success], or)
comment(;   perhaps specified via control argument)
comment(; * Check procedure return type and take appropriate action)

operator(()keyword(define) operator(()ident(my-sub)operator(\))
  operator(()keyword(let*) operator(()operator(()ident(datatype) operator(()ident(vector) operator(')operator(()operator(\)) integer(7) operator(')operator(()integer(1) integer(2) integer(3)operator(\)) string<delimiter(")content(abc)delimiter(")> operator(')ident(sym)operator(\))operator(\))operator(\))
    operator(()ident(vector-ref) ident(datatype) operator(()ident(random) operator(()ident(vector-length) ident(datatype)operator(\))operator(\))operator(\)) operator(\))operator(\))

comment(;; ----)

comment(; '*result*' is bound to a randomly chosen datatype)
operator(()keyword(define) ident(*result*) operator(()ident(my-sub)operator(\))operator(\))

operator(()keyword(cond)
  comment(; It is common to return an empty list to represent 'void')
  operator(()operator(()ident(null?) ident(*result*)operator(\)) operator(()ident(print) string<delimiter(")content(void context)delimiter(")>operator(\))operator(\))

  operator(()operator(()ident(list?) ident(*result*)operator(\)) operator(()ident(print) string<delimiter(")content(list context)delimiter(")>operator(\))operator(\))
  operator(()operator(()ident(number?) ident(*result*)operator(\)) operator(()ident(print) string<delimiter(")content(scalar context)delimiter(")>operator(\))operator(\))
  operator(()operator(()ident(string?) ident(*result*)operator(\)) operator(()ident(print) string<delimiter(")content(string context)delimiter(")>operator(\))operator(\))
  operator(()operator(()ident(symbol?) ident(*result*)operator(\)) operator(()ident(print) string<delimiter(")content(atom context)delimiter(")>operator(\))operator(\))
  operator(()ident(else) operator(()ident(print) string<delimiter(")content(Unknown type)delimiter(")>operator(\))operator(\))operator(\))

comment(;; @@PLEAC@@_10.7)
comment(; Keyword parameters are fully supported. Note that pairs have)
comment(; replaced Perl strings in the examples since they are easier to)
comment(; manipulate)

operator(()ident(use-modules) operator(()ident(ice-9) ident(optargs)operator(\))operator(\))

operator(()ident(define*) operator(()ident(the-func) error(#)ident(:key) operator(()ident(increment) operator(()keyword(cons) integer(10) operator(')ident(s)operator(\))operator(\))
                         operator(()ident(finish) operator(()keyword(cons) integer(0) operator(')ident(m)operator(\))operator(\))
                         operator(()ident(start) operator(()keyword(cons) integer(0) operator(')ident(m)operator(\))operator(\))operator(\))
  operator(()ident(print) ident(increment)operator(\))
  operator(()ident(print) ident(finish)operator(\))
  operator(()ident(print) ident(start)operator(\))operator(\))

operator(()ident(the-func)operator(\))
operator(()ident(the-func) error(#)ident(:increment) operator(()keyword(cons) integer(20) operator(')ident(s)operator(\)) error(#)ident(:start) operator(()keyword(cons) integer(5) operator(')ident(m)operator(\)) error(#)ident(:finish) operator(()keyword(cons) integer(30) operator(')ident(m)operator(\))operator(\))
operator(()ident(the-func) error(#)ident(:start) operator(()keyword(cons) integer(5) operator(')ident(m)operator(\)) error(#)ident(:finish) operator(()keyword(cons) integer(30) operator(')ident(m)operator(\))operator(\))
operator(()ident(the-func) error(#)ident(:finish) operator(()keyword(cons) integer(30) operator(')ident(m)operator(\))operator(\))
operator(()ident(the-func) error(#)ident(:start) operator(()keyword(cons) integer(5) operator(')ident(m)operator(\)) error(#)ident(:increment) operator(()keyword(cons) integer(20) operator(')ident(s)operator(\))operator(\))

comment(;; @@PLEAC@@_10.8)
comment(;; @@INCOMPLETE@@)
comment(;; @@INCOMPLETE@@)

comment(;; @@PLEAC@@_10.9)
comment(; The return of multiple values, whether arrays or other items, may be )
comment(; achieved via:)
comment(; * Packaging return items as a single list, structure or array, an)
comment(;   approach which is usable across many languages, though can be)
comment(;   clunky because the procedure caller must manually extract all)
comment(;   items)
comment(; * The 'values' procedure, a more Schemish idiom, is usually used in)
comment(;   conjunction with the 'call-with-values' procedure [the former combines)
comment(;   multiple values, the latter captures and cleanly extracts them]. It)
comment(;   comes into its own, however, when used to create a 'macro' [an)
comment(;   extension to the Scheme language] like 'let-values', a variation of)
comment(;   the 'let' form that allows multiple return values to be placed directly)
comment(;   into separate variables. Implementation shown here is from 'The)
comment(;   Scheme Programming Language, 3rd Edition' by R. Kent Dybvig, though)
comment(;   there exists a more standard implementation in SRFI-11. There is also)
comment(;   the 'receive' functionality accessable via: (use-modules (ice-9 receive\)\))

comment(; [1] Implementation of 'somefunc' returning muliple values via packaging)
comment(; items within a list that is returned)
operator(()keyword(define) operator(()ident(somefunc)operator(\))
  operator(()keyword(let) operator(()operator(()ident(a) operator(()ident(make-vector) integer(5)operator(\))operator(\))
        operator(()ident(h) operator(()ident(make-hash-table) integer(5)operator(\))operator(\))operator(\))
    operator(()ident(list) ident(a) ident(h)operator(\)) operator(\))operator(\))

comment(; Retrieving procedure values requires that the return list be captured)
comment(; and each contained item separately extracted ['let*' used in place of)
comment(; 'let' to ensure correct retrieval order])
operator(()keyword(let*) operator(()operator(()ident(return-list) operator(()ident(somefunc)operator(\))operator(\))
       operator(()ident(a) operator(()ident(car) ident(return-list)operator(\))operator(\))
       operator(()ident(b) operator(()ident(cadr) ident(return-list)operator(\))operator(\))operator(\))

  ident(...) keyword(do) ident(something) ident(with) operator(')ident(a)operator(') keyword(and) operator(')ident(b)operator(') ident(...)operator(\))

comment(;; ----------------------------)

comment(; [2] Implementation of 'somefunc' returning muliple values using the)
comment(; 'values' procedure )

operator(()ident(use-syntax) operator(()ident(ice-9) ident(syncase)operator(\))operator(\)) 

comment(; 'let-values' from: http://www.scheme.com/tspl3/syntax.html#fullletvalues)
operator(()keyword(define-syntax) ident(let-values)
  operator(()ident(syntax-rules) operator(()operator(\))
    operator(()operator(()ident(_) operator(()operator(\)) ident(f1) ident(f2) ident(...)operator(\)) operator(()keyword(let) operator(()operator(\)) ident(f1) ident(f2) ident(...)operator(\))operator(\))
    operator(()operator(()ident(_) operator(()operator(()ident(fmls1) ident(expr1)operator(\)) operator(()ident(fmls2) ident(expr2)operator(\)) ident(...)operator(\)) ident(f1) ident(f2) ident(...)operator(\))
     operator(()ident(lvhelp) ident(fmls1) operator(()operator(\)) operator(()operator(\)) ident(expr1) operator(()operator(()ident(fmls2) ident(expr2)operator(\)) ident(...)operator(\)) operator(()ident(f1) ident(f2) ident(...)operator(\))operator(\))operator(\))operator(\))operator(\)) 

operator(()keyword(define-syntax) ident(lvhelp)
  operator(()ident(syntax-rules) operator(()operator(\))
    operator(()operator(()ident(_) operator(()ident(x1) operator(.) ident(fmls)operator(\)) operator(()ident(x) ident(...)operator(\)) operator(()ident(t) ident(...)operator(\)) ident(e) ident(m) ident(b)operator(\))
     operator(()ident(lvhelp) ident(fmls) operator(()ident(x) ident(...) ident(x1)operator(\)) operator(()ident(t) ident(...) ident(tmp)operator(\)) ident(e) ident(m) ident(b)operator(\))operator(\))
    operator(()operator(()ident(_) operator(()operator(\)) operator(()ident(x) ident(...)operator(\)) operator(()ident(t) ident(...)operator(\)) ident(e) ident(m) ident(b)operator(\))
     operator(()ident(call-with-values)
       operator(()keyword(lambda) operator(()operator(\)) ident(e)operator(\))
       operator(()keyword(lambda) operator(()ident(t) ident(...)operator(\))
         operator(()ident(let-values) ident(m) operator(()keyword(let) operator(()operator(()ident(x) ident(t)operator(\)) ident(...)operator(\)) operator(.) ident(b)operator(\))operator(\))operator(\))operator(\))operator(\))
    operator(()operator(()ident(_) ident(xr) operator(()ident(x) ident(...)operator(\)) operator(()ident(t) ident(...)operator(\)) ident(e) ident(m) ident(b)operator(\))
     operator(()ident(call-with-values)
       operator(()keyword(lambda) operator(()operator(\)) ident(e)operator(\))
       operator(()keyword(lambda) operator(()ident(t) ident(...) operator(.) ident(tmpr)operator(\))
         operator(()ident(let-values) ident(m) operator(()keyword(let) operator(()operator(()ident(x) ident(t)operator(\)) ident(...) operator(()ident(xr) ident(tmpr)operator(\))operator(\)) operator(.) ident(b)operator(\))operator(\))operator(\))operator(\))operator(\))operator(\))operator(\)) 

comment(;; ------------)

operator(()keyword(define) operator(()ident(somefunc)operator(\))
  operator(()keyword(let) operator(()operator(()ident(a) operator(()ident(make-vector) integer(5)operator(\))operator(\))
        operator(()ident(h) operator(()ident(make-hash-table) integer(5)operator(\))operator(\))operator(\))
    operator(()ident(values) ident(a) ident(h)operator(\)) operator(\))operator(\))

comment(; Multiple return items placed directly into separate variables)
operator(()ident(let-values) operator(() operator(()operator(()ident(a) ident(h)operator(\)) operator(()ident(somefunc)operator(\))operator(\)) operator(\))
  operator(()ident(print) operator(()ident(array?) ident(a)operator(\))operator(\))
  operator(()ident(print) operator(()ident(hash-table?) ident(h)operator(\))operator(\))operator(\))

comment(;; @@PLEAC@@_10.10)
comment(; Like most modern languages, Scheme supports exceptions for handling)
comment(; failure, something that will be illustrated in another section. However,)
comment(; conventions exist as to the choice of value used to indicate failure:)
comment(; * Empty list i.e. '(\) is often used for this task, as is it's string)
comment(;   counterpart, "", the empty string)
comment(; * Return false i.e. #f to indicate failed / not found etc, and a valid)
comment(;   value otherwise [e.g. testing set membership: if not a member, return)
comment(;   #f, but if a member, return the item itself rather than #t])

comment(; Return empty list as indicating 'failure')
operator(()keyword(define) operator(()ident(sub-failed)operator(\)) operator(')operator(()operator(\))operator(\))

comment(;; ------------)

operator(()keyword(define) operator(()ident(look-for-something)operator(\))
  ident(...)
  operator(()keyword(if) operator(()ident(something-found)operator(\))
    comment(; Item found, return the item)
    ident(something)
  comment(;else)
    comment(; Not found, indicate failure)
    predefined_constant(#f)
  operator(\))operator(\))

comment(;; ----)

operator(()keyword(if) operator(()ident(not) operator(()ident(look-for-something)operator(\))operator(\))
  operator(()ident(print) string<delimiter(")content(Item could not be found ...)delimiter(")>operator(\))
comment(;else)
  comment(; do something with item ...)
  ident(...)

comment(;; ------------)

comment(; An interesting variation on returning #f as a failure indicator is)
comment(; in using the, 'false-if-exception' procedure whereby a procedure is)
comment(; executed, any exceptions it may throw caught, and handled by simply)
comment(; returning #f. See example in section on Exception Handling below.)

comment(;; ------------)

operator(()keyword(define) operator(()ident(ioctl)operator(\)) ident(...) predefined_constant(#f)operator(\))

operator(()keyword(or) operator(()ident(ioctl)operator(\)) operator(()keyword(begin) operator(()ident(print) string<delimiter(")content(can't ioctl)delimiter(")>operator(\)) operator(()ident(exit) integer(1)operator(\))operator(\))operator(\))

comment(;; @@PLEAC@@_10.11)
comment(; Whether Scheme is seen to support prototyping depends on the definition)
comment(; of this term used:)
comment(; * Prototyping along the lines used in Ada, Modula X, and even C / C++,)
comment(;   in which a procedure's interface is declared separately from its)
comment(;   implementation, is *not* supported)
comment(; * Prototyping in which, as part of the procedure definition, parameter )
comment(;   information must be supplied. This is a requirement in Scheme in that)
comment(;   parameter number and names must be given, though there is no need to)
comment(;   supply type information [optional and keyword parameters muddy the)
comment(;   waters somewhat, but the general principle applies])

operator(()keyword(define) operator(()ident(func-with-no-arg)operator(\)) ident(...)operator(\))
operator(()keyword(define) operator(()ident(func-with-one-arg) ident(arg1)operator(\)) ident(...)operator(\))
operator(()keyword(define) operator(()ident(func-with-two-arg) ident(arg1) ident(arg2)operator(\)) ident(...)operator(\))
operator(()keyword(define) operator(()ident(func-with-three-arg) ident(arg1) ident(arg2) ident(arg3)operator(\)) ident(...)operator(\))

comment(;; @@PLEAC@@_10.12)
comment(; Not exactly like the Perl example, but a way of immediately)
comment(; exiting from an application)
operator(()keyword(define) operator(()ident(die) ident(msg) operator(.) ident(error-code)operator(\))
  operator(()ident(display) operator(()ident(string-append) ident(msg) string<delimiter(")content(\\n)delimiter(")>operator(\)) operator(()ident(current-error-port)operator(\))operator(\))
  operator(()ident(exit) operator(()keyword(if) operator(()ident(null?) ident(error-code)operator(\)) integer(1) operator(()ident(car) ident(error-code)operator(\))operator(\))operator(\))operator(\))

comment(;; ----)

operator(()ident(die) string<delimiter(")content(some message)delimiter(")>operator(\))

comment(;; ------------)

comment(; An exception is thrown via 'throw'; argument must be a symbol)
operator(()ident(throw) operator(')ident(some-exception)operator(\))

comment(; Invalid attempts - these, themselves force a 'wrong-type-arg)
comment(; exception to be thrown)
operator(()ident(throw) predefined_constant(#t)operator(\))
operator(()ident(throw) string<delimiter(")content(my message)delimiter(")>operator(\))
operator(()ident(throw) integer(1)operator(\))

comment(;; ------------)

comment(; Example of a 'catch all' handler - 'proc' is executed, and any)
comment(; exception thrown is handled, in this case by simply returning false)
operator(()keyword(define) operator(()ident(false-if-exception) ident(proc)operator(\))
  operator(()ident(catch) predefined_constant(#t)
    ident(proc)
    operator(()keyword(lambda) operator(()ident(key) operator(.) ident(args)operator(\)) predefined_constant(#f)operator(\))operator(\))operator(\))

operator(()keyword(define) operator(()ident(func)operator(\))
  operator(()ident(print) string<delimiter(")content(Starting 'func' ...)delimiter(")>operator(\))
  operator(()ident(throw) operator(')ident(myexception) integer(1)operator(\))
  operator(()ident(print) string<delimiter(")content(Leaving 'func' ...)delimiter(")>operator(\))operator(\))

comment(;; ----)

operator(()keyword(if) operator(()ident(not) operator(()ident(false-if-exception) ident(main)operator(\))operator(\))
  operator(()ident(print) string<delimiter(")content('func' raised an exception)delimiter(")>operator(\))
  operator(()ident(print) string<delimiter(")content('func' executed normally)delimiter(")>operator(\))operator(\))

comment(;; ------------)

comment(; More typical exception handling example in which:)
comment(; * 'func' is executed)
comment(; * 'catch' either:)
comment(;   - returns return value of 'func' [if successful])
comment(;   - executes handler(s\))

operator(()keyword(define) operator(()ident(full-moon-exception-handler) ident(key) operator(.) ident(args)operator(\))
  operator(()ident(print) string<delimiter(")content(I'm executing after stack unwound !)delimiter(")>operator(\))operator(\))

operator(()keyword(define) operator(()ident(full-moon-exception-prewind-handler) ident(key) operator(.) ident(args)operator(\))
  operator(()ident(print) string<delimiter(")content(I'm executing with the stack still intact !)delimiter(")>operator(\))operator(\))

operator(()keyword(define) operator(()ident(func)operator(\))
  operator(()ident(print) string<delimiter(")content(Starting 'func' ...)delimiter(")>operator(\))
  operator(()ident(throw) operator(')ident(full-moon-exception) integer(1)operator(\))
  operator(()ident(print) string<delimiter(")content(Leaving 'func' ...)delimiter(")>operator(\))operator(\))

operator(()ident(catch) operator(')ident(full-moon-exception)
   ident(func)
   ident(full-moon-exception-handler)
   ident(full-moon-exception-prewind-handler)operator(\))

comment(;; @@PLEAC@@_10.13)
comment(; Scheme is lexically-scoped, so same-name, higher-level variables)
comment(; are merely shadowed in lower-level blocks. Upon exit from those)
comment(; blocks the higher-level values are again available. Therefore, the)
comment(; saving of global variables, as required by Perl, is not necessary)

comment(; Global variable)
operator(()keyword(define) ident(age) integer(18)operator(\))

comment(; Procedure definition creates a closure - it captures the earlier)
comment(; version of, age', and will retain it)
operator(()keyword(define) operator(()ident(func)operator(\))
  operator(()ident(print) ident(age)operator(\))operator(\))

operator(()keyword(if) operator(()ident(condition)operator(\))
  comment(; New 'local' variable created which acts to shadow the global)
  comment(; version)
  operator(()keyword(let) operator(()operator(()ident(age) integer(23)operator(\))operator(\))

    comment(; Prints 23 because the global variable is shadowed within )
    comment(; this block )
    operator(()ident(print) ident(age)operator(\))

    comment(; However, lexical-scoping ensures 'func' still accesses the)
    comment(; 'age' which was active when it was defined)
    operator(()ident(func)operator(\)) operator(\))operator(\))

comment(; The use of 'fluid-let' allows for similar behaviour to Perl's i.e.)
comment(; it mimics dynamic scope, but it does so cleanly in that once its)
comment(; scope ends any affected global variables are restored to previous)
comment(; values)
operator(()keyword(if) operator(()ident(condition)operator(\))

  comment(; This does not create a new 'local' variables but temporarily)
  comment(; sets the global variable, 'age' to 23)
  operator(()ident(fluid-let) operator(()operator(()ident(age) integer(23)operator(\))operator(\))

    comment(; Prints 23 because it is accessing the global version of 'age')
    operator(()ident(print) ident(age)operator(\))

    comment(; Prints 23 because it is its lexically-scoped version of 'age')
    comment(; that has its value altered, albeit temporarily)
    operator(()ident(func)operator(\)) operator(\))operator(\))

comment(;; @@PLEAC@@_10.14)
comment(; Define two procedures, bind them to identifiers)
operator(()keyword(define) operator(()ident(grow)operator(\)) operator(()ident(print) string<delimiter(")content(grow)delimiter(")>operator(\))operator(\))
operator(()keyword(define) operator(()ident(shrink)operator(\)) operator(()ident(print) string<delimiter(")content(shrink)delimiter(")>operator(\))operator(\))

comment(; Separate procedures executed)
operator(()ident(grow)operator(\))
operator(()ident(shrink)operator(\))

comment(; Rebind identifier; now acts as alias for latter)
operator(()keyword(define) ident(grow) ident(shrink)operator(\))

comment(; Same procedure executed in both cases)
operator(()ident(grow)operator(\))
operator(()ident(shrink)operator(\))

comment(;; ------------)

comment(; As for previous except that rebinding is localised and)
comment(; ends once local scope exited)
operator(()keyword(let) operator(()operator(()ident(grow) ident(shrink)operator(\))operator(\))
  operator(()ident(grow)operator(\))
  operator(()ident(shrink)operator(\))operator(\))

comment(;; ----------------------------)

comment(; Example of dynamically creating [from text data] and binding)
comment(; procedures. The example here is conceptually similar to the Perl)
comment(; example in that it makes use of an 'eval' type of facility to)
comment(; generate code from text. In Scheme such tasks are generally better)
comment(; dealt with using macros )

comment(; List of procedure name / first argument pairs)
operator(()keyword(define) ident(*colours*)
  operator(()ident(list)
    operator(')operator(()string<delimiter(")content(red)delimiter(")> operator(.) string<delimiter(")content(baron)delimiter(")>operator(\))
    operator(')operator(()string<delimiter(")content(blue)delimiter(")> operator(.) string<delimiter(")content(zephyr)delimiter(")>operator(\))
    operator(')operator(()string<delimiter(")content(green)delimiter(")> operator(.) string<delimiter(")content(beret)delimiter(")>operator(\))
    operator(')operator(()string<delimiter(")content(yellow)delimiter(")> operator(.) string<delimiter(")content(ribbon)delimiter(")>operator(\))
    operator(')operator(()string<delimiter(")content(orange)delimiter(")> operator(.) string<delimiter(")content(county)delimiter(")>operator(\))
    operator(')operator(()string<delimiter(")content(purple)delimiter(")> operator(.) string<delimiter(")content(haze)delimiter(")>operator(\))
    operator(')operator(()string<delimiter(")content(violet)delimiter(")> operator(.) string<delimiter(")content(temper)delimiter(")>operator(\)) operator(\))operator(\))

comment(; Build a series of procedures dynamically by traversing the)
comment(; *colours* list and obtaining:)
comment(; * Procedure name from first item of pair)
comment(; * Procedure argument from second item of pair)
operator(()ident(for-each)
  operator(()keyword(lambda) operator(()ident(colour)operator(\))
    operator(()keyword(let) operator(()operator(()ident(proc-string)
            operator(()ident(string-append)
              string<delimiter(")content((define )delimiter(")> operator(()ident(car) ident(colour)operator(\)) string<delimiter(")content( (lambda (\) )delimiter(")>
              string<delimiter(")content(\\")content(<FONT COLOR=)delimiter(")> operator(()ident(car) ident(colour)operator(\)) string<delimiter(")content(>)delimiter(")> operator(()ident(cdr) ident(colour)operator(\))
              string<delimiter(")content(</FONT>)content(\\")content(\)\))delimiter(")> operator(\))operator(\))operator(\))
      operator(()ident(eval-string) ident(proc-string)operator(\))operator(\))operator(\))
   ident(*colours*)operator(\))

comment(; Apply each of the dynamically-built procedures)
operator(()ident(for-each)
  operator(()keyword(lambda) operator(()ident(colour)operator(\))
    operator(()ident(print) operator(()ident(apply) operator(()ident(string->procedure) operator(()ident(car) ident(colour)operator(\))operator(\)) operator(')operator(()operator(\))operator(\))operator(\))operator(\))
  ident(*colours*)operator(\))

comment(;; @@PLEAC@@_10.15)
comment(; AFAICT Guile doesn't implement an AUTOLOAD facility in which a)
comment(; 'replacement' function is available should another one fail to)
comment(; load [though there is an autoload feature available with modules)
comment(; which is a load-on-demand facility aimed at conserving memory and)
comment(; speeding up initial program load time].)
comment(;)
comment(; One might think it would be feasable, however, to use exception)
comment(; handling to provide roughly similar functionality:)

comment(; Catch all exceptions)
operator(()ident(catch) predefined_constant(#t)
  comment(; Undefined procedure, 'x')
  ident(x)
  comment(; Exception handler could load missing code ?)
  operator(()keyword(lambda) operator(()ident(key) operator(.) ident(args)operator(\)) ident(...) operator(\))operator(\))

comment(; However, an undefined function call is reported as:)
comment(;)
comment(;    ERROR: Unbound variable: ...)
comment(;)
comment(; and this situation doesn't appear to be user-trappable. )
comment(;)

comment(;; @@PLEAC@@_10.16)
comment(; Both implementations below  are correct, and exhibit identical)
comment(; behaviour )

operator(()keyword(define) operator(()ident(outer) ident(arg)operator(\))
  operator(()keyword(let*) operator(()operator(()ident(x) operator(()ident(+) ident(arg) integer(35)operator(\))operator(\))
         operator(()ident(inner) operator(()keyword(lambda) operator(()operator(\)) operator(()ident(*) ident(x) integer(19)operator(\))operator(\))operator(\))operator(\))
    operator(()ident(+) ident(x) operator(()ident(inner)operator(\))operator(\))operator(\))operator(\))

comment(;; ----------------------------)

operator(()keyword(define) operator(()ident(outer) ident(arg)operator(\))
  operator(()keyword(let) operator(()operator(()ident(x) operator(()ident(+) ident(arg) integer(35)operator(\))operator(\))operator(\))
    operator(()keyword(define) operator(()ident(inner)operator(\)) operator(()ident(*) ident(x) integer(19)operator(\))operator(\))
    operator(()ident(+) ident(x) operator(()ident(inner)operator(\))operator(\))operator(\))operator(\))

comment(;; @@PLEAC@@_10.17)
comment(;; @@INCOMPLETE@@)
comment(;; @@INCOMPLETE@@)

comment(;; @@PLEAC@@_13.0)
comment(;; Guile OOP is in the (oop goops\) module (based on CLOS\).  All)
comment(;; following sections assume you have (oop goops loaded\).)
operator(()ident(use-modules) operator(()ident(oop) ident(goops)operator(\))operator(\))
operator(()ident(define-class) ident(<data-encoder>) operator(()operator(\))operator(\))
operator(()keyword(define) ident(obj) operator(()ident(make) ident(<data-encoder>)operator(\))operator(\))

operator(()keyword(define) ident(obj) operator(#()integer(3) integer(5)operator(\))operator(\))
operator(()ident(format) predefined_constant(#t) string<delimiter(")content(~A ~A)content(\\n)delimiter(")> operator(()ident(class-of) ident(obj)operator(\)) operator(()ident(array-ref) ident(obj) integer(1)operator(\))operator(\))
operator(()ident(change-class) ident(v) ident(<human-cannibal>)operator(\)) comment(; has to be defined)
operator(()ident(format) predefined_constant(#t) string<delimiter(")content(~A ~A)content(\\n)delimiter(")> operator(()ident(slot-ref) ident(obj) ident(stomach)operator(\)) operator(()ident(slot-ref) ident(obj) ident(name)operator(\))operator(\))

operator(()ident(slot-ref) ident(obj) operator(')ident(stomach)operator(\))
operator(()ident(slot-set!) ident(obj) operator(')ident(stomach) string<delimiter(")content(Empty)delimiter(")>operator(\))
operator(()ident(name) ident(obj)operator(\))
operator(()keyword(set!) operator(()ident(name) ident(obj)operator(\)) string<delimiter(")content(Thag)delimiter(")>operator(\))

comment(;; inheritance)
operator(()ident(define-class) ident(<lawyer>) operator(()ident(<human-cannibal>)operator(\))operator(\))

operator(()keyword(define) ident(lector) operator(()ident(make) ident(<human-cannibal>)operator(\))operator(\))
operator(()ident(feed) ident(lector) string<delimiter(")content(Zak)delimiter(")>operator(\))
operator(()ident(move) ident(lector) string<delimiter(")content(New York)delimiter(")>operator(\))

comment(;; @@PLEAC@@_13.1)
operator(()ident(define-class) ident(<my-class>) operator(()operator(\))
  operator(()ident(start) error(#)ident(:init-form) operator(()ident(current-time)operator(\))operator(\))
  operator(()ident(age) error(#)ident(:init-value) integer(0)operator(\))operator(\))

comment(;; classes must have predefined slots, but you could use one as a)
comment(;; dictionary:)
operator(()ident(define-class) ident(<my-class>) operator(()operator(\))
  operator(()ident(start) error(#)ident(:init-form) operator(()ident(current-time)operator(\))operator(\))
  operator(()ident(age) error(#)ident(:init-value) integer(0)operator(\))
  operator(()ident(properties) error(#)ident(:init-value) operator(')operator(()operator(\))operator(\))operator(\))
operator(()keyword(define) operator(()ident(initialize) operator(()ident(m) ident(<my-class>)operator(\)) ident(initargs)operator(\))
  operator(()ident(and-let*) operator(()operator(()ident(extra) operator(()ident(memq) error(#)ident(:extra) ident(initargs)operator(\))operator(\))operator(\))
    operator(()ident(slot-set!) ident(m) operator(')ident(properties) operator(()ident(cdr) ident(extra)operator(\))operator(\))operator(\))operator(\))

comment(;; @@PLEAC@@_13.2)
comment(;; For smobs (external C objects\), you can specify a callback to be)
comment(;; performed when the object is garbage collected with the C API)
comment(;; function `scm_set_smob_free'.  This solves the problem of cleaning up)
comment(;; after external objects and connections.  Guile doesn't use reference)
comment(;; count garbage collection, so circular data structures aren't a)
comment(;; problem.)

comment(;; @@PLEAC@@_13.3)
comment(;; either use slot-ref/set!)
operator(()ident(slot-ref) ident(obj) operator(')ident(name)operator(\))
operator(()ident(slot-set!) ident(obj) operator(')ident(name) ident(value)operator(\))

comment(;; or define the class with accessors)
operator(()ident(define-class) ident(<my-class>) operator(()operator(\))
  operator(()ident(name) error(#)ident(:accessor) ident(name)operator(\))operator(\))
operator(()ident(name) ident(obj)operator(\))
operator(()keyword(set!) operator(()ident(name) ident(obj)operator(\)) ident(value)operator(\))

comment(;; or use getters/setters to implement read/write-only slots)
operator(()ident(define-class) ident(<my-class>) operator(()operator(\))
  operator(()ident(name) error(#)ident(:getter) ident(name)operator(\))
  operator(()ident(age) error(#)ident(:setter) ident(age)operator(\))operator(\))
operator(()ident(name) ident(obj)operator(\))
operator(()keyword(set!) operator(()ident(age) ident(obj)operator(\)) ident(value)operator(\))

comment(;; or implement getters/setters manually)
operator(()ident(define-method) operator(()operator(()ident(setter) ident(name)operator(\)) operator(()ident(obj) ident(<my-class>)operator(\)) ident(value)operator(\))
  operator(()keyword(cond) operator(()operator(()ident(string-match) string<delimiter(")content([^-)content(\\\\)content(w0-9'])delimiter(")> ident(value)operator(\))
         operator(()ident(warn) string<delimiter(")content(funny characters in name)delimiter(")>operator(\))operator(\))
        operator(()operator(()ident(string-match) string<delimiter(")content([0-9])delimiter(")> ident(value)operator(\))
         operator(()ident(warn) string<delimiter(")content(numbers in name)delimiter(")>operator(\))operator(\))
        operator(()operator(()ident(not) operator(()ident(string-match) string<delimiter(")content(\\\\)content(w+)content(\\\\)content(W+)content(\\\\)content(w+)delimiter(")> ident(value)operator(\))operator(\))
         operator(()ident(warn) string<delimiter(")content(prefer multiword names)delimiter(")>operator(\))operator(\))
        operator(()operator(()ident(not) operator(()ident(string-match) string<delimiter(")content(\\\\)content(w)delimiter(")> ident(value)operator(\))operator(\))
         operator(()ident(warn) string<delimiter(")content(name is blank)delimiter(")>operator(\))operator(\))operator(\))
  operator(()ident(slot-set!) ident(obj) operator(')ident(name) operator(()ident(string-downcase) ident(value)operator(\))operator(\))operator(\))

comment(;; @@PLEAC@@_13.4)
comment(;; override the initialize method)
operator(()keyword(define) ident(body-count) integer(0)operator(\))

operator(()ident(define-method) operator(()ident(initialize) operator(()ident(obj) ident(<person>)operator(\)) ident(initargs)operator(\))
  operator(()keyword(set!) ident(body-count) operator(()integer(1)ident(+) ident(body-count)operator(\))operator(\))
  operator(()ident(next-method)operator(\))operator(\))

operator(()keyword(define) ident(people) operator(')operator(()operator(\))operator(\))
operator(()keyword(do) operator(()operator(()ident(i) integer(1) operator(()integer(1)ident(+) ident(i)operator(\))operator(\))operator(\))
    operator(()operator(()ident(>) ident(i) integer(10)operator(\))operator(\))
  operator(()keyword(set!) ident(people) operator(()keyword(cons) operator(()ident(make) ident(<person>)operator(\)) ident(people)operator(\))operator(\))operator(\))

operator(()ident(format) predefined_constant(#t) string<delimiter(")content(There are ~A people alive.)content(\\n)delimiter(")> ident(body-count)operator(\))

operator(()keyword(define) ident(him) operator(()ident(make) ident(<person>)operator(\))operator(\))
operator(()ident(slot-set!) ident(him) operator(')ident(gender) string<delimiter(")content(male)delimiter(")>operator(\))

operator(()keyword(define) ident(her) operator(()ident(make) ident(<person>)operator(\))operator(\))
operator(()ident(slot-set!) ident(her) operator(')ident(gender) string<delimiter(")content(female)delimiter(")>operator(\))

comment(;; use the :class allocation method)
operator(()ident(slot-set!) operator(()ident(make) ident(<fixed-array>)operator(\)) operator(')ident(max-bounds) integer(100)operator(\)) comment(; set for whole class)
operator(()keyword(define) ident(alpha) operator(()ident(make) ident(<fixed-array>)operator(\))operator(\))
operator(()ident(format) predefined_constant(#t) string<delimiter(")content(Bound on alpha is ~D)content(\\n)delimiter(")> operator(()ident(slot-ref) ident(alpha) operator(')ident(max-bounds)operator(\))operator(\))
comment(;; 100)

operator(()keyword(define) ident(beta) operator(()ident(make) ident(<fixed-array>)operator(\))operator(\))
operator(()ident(slot-set!) ident(beta) operator(')ident(max-bounds) integer(50)operator(\))          comment(; still sets for whole class)
operator(()ident(format) predefined_constant(#t) string<delimiter(")content(Bound on alpha is ~D)content(\\n)delimiter(")> operator(()ident(slot-ref) ident(alpha) operator(')ident(max-bounds)operator(\))operator(\))
comment(;; 50)

comment(;; defined simply as)
operator(()ident(define-class) ident(<fixed-array>) operator(()operator(\))
  operator(()ident(max-bounds) error(#)ident(:init-value) integer(7) error(#)ident(:allocation) error(#)ident(:class)operator(\))operator(\))

comment(;; @@PLEAC@@_13.5)
comment(;; Guile classes are basically structs by definition.  If you don't care)
comment(;; about OO programming at all, you can use records, which are portable)
comment(;; across most Schemes.  This is, however, an OO chapter so I'll stick)
comment(;; to classes.)
operator(()ident(define-class) ident(<person>) operator(()operator(\)) ident(name) ident(age) ident(peers)operator(\))

operator(()keyword(define) ident(p) operator(()ident(make) ident(<person>)operator(\))operator(\))
operator(()ident(slot-set!) ident(p) operator(')ident(name) string<delimiter(")content(Jason Smythe)delimiter(")>operator(\))
operator(()ident(slot-set!) ident(p) operator(')ident(age) integer(13)operator(\))
operator(()ident(slot-set!) ident(p) operator(')ident(peers) operator(')operator(()string<delimiter(")content(Wilbur)delimiter(")> string<delimiter(")content(Ralph)delimiter(")> string<delimiter(")content(Fred)delimiter(")>operator(\))operator(\))
operator(()ident(format) predefined_constant(#t) string<delimiter(")content(At age ~D, ~A's first friend is ~A.)content(\\n)delimiter(")>
        operator(()ident(slot-ref) ident(p) operator(')ident(age)operator(\)) operator(()ident(slot-ref) ident(p) operator(')ident(name)operator(\)) operator(()ident(car) operator(()ident(slot-ref) ident(p) operator(')ident(peers)operator(\))operator(\))operator(\))

comment(;; For type-checking and field validation, define the setters)
comment(;; accordingly.)
operator(()ident(define-class) ident(<person>) operator(()operator(\))
  operator(()ident(name) error(#)ident(:accessor) ident(name)operator(\))
  operator(()ident(age) error(#)ident(:accessor) ident(age)operator(\))operator(\))

operator(()ident(define-method) operator(()operator(()ident(setter) ident(age)operator(\)) operator(()ident(p) ident(<person>)operator(\)) ident(a)operator(\))
  operator(()keyword(cond) operator(()operator(()ident(not) operator(()ident(number?) ident(a)operator(\))operator(\))
         operator(()ident(warn) string<delimiter(")content(age)delimiter(")> ident(a) string<delimiter(")content(isn't numeric)delimiter(")>operator(\))operator(\))
        operator(()operator(()ident(>) ident(a) integer(150)operator(\))
         operator(()ident(warn) string<delimiter(")content(age)delimiter(")> ident(a) string<delimiter(")content(is unreasonable)delimiter(")>operator(\))operator(\))operator(\))
  operator(()ident(slot-set!) ident(p) operator(')ident(age) ident(a)operator(\))operator(\))

operator(()ident(define-class) ident(<family>) operator(()operator(\))
  operator(()ident(head) error(#)ident(:init-form) operator(()ident(make) ident(<person>)operator(\)) error(#)ident(:accessor) ident(head)operator(\))
  operator(()ident(address) error(#)ident(:init-value) string<delimiter(")delimiter(")> error(#)ident(:accessor) ident(address)operator(\))
  operator(()ident(members) error(#)ident(:init-value) operator(')operator(()operator(\)) error(#)ident(:accessor) ident(members)operator(\))operator(\))

operator(()keyword(define) ident(folks) operator(()ident(make) ident(<family>)operator(\))operator(\))

operator(()keyword(define) ident(dad) operator(()ident(head) ident(folks)operator(\))operator(\))
operator(()keyword(set!) operator(()ident(name) ident(dad)operator(\)) string<delimiter(")content(John)delimiter(")>operator(\))
operator(()keyword(set!) operator(()ident(age) ident(dad)operator(\)) integer(34)operator(\))

operator(()ident(format) predefined_constant(#t) string<delimiter(")content(~A's age is ~D)content(\\n)delimiter(")> operator(()ident(name) ident(dad)operator(\)) operator(()ident(age) ident(dad)operator(\))operator(\))

comment(;; Macros are the usual way to add syntactic sugar)

comment(;; For all fields of the same type, let's use _ to mean the slot name in)
comment(;; the options expansion.)
operator(()ident(define-macro) operator(()ident(define-uniform-class) ident(name) ident(supers) ident(slots) operator(.) ident(options)operator(\))
  error(`)operator(()ident(define-class) error(,)ident(name) error(,)ident(supers)
     error(,)ident(@)operator(()ident(map) operator(()keyword(lambda) operator(()ident(s)operator(\)) operator(()keyword(cons) ident(s) operator(()ident(map) operator(()keyword(lambda) operator(()ident(o)operator(\)) operator(()keyword(if) operator(()ident(eq?) ident(o) operator(')ident(_)operator(\)) ident(s) ident(o)operator(\))operator(\)) ident(options)operator(\))operator(\))operator(\))
            ident(slots)operator(\))operator(\))operator(\))

operator(()ident(define-uniform-class) ident(<card>) operator(()ident(name) ident(color) ident(cost) ident(type) ident(release) ident(text)operator(\))
  error(#)ident(:accessor) ident(_) error(#)ident(:init-value) string<delimiter(")delimiter(")>operator(\))

comment(;; If you *really* wanted to enforce slot types you could use something)
comment(;; like the above with the custom setter.  To illustrate reversing)
comment(;; normal slot definition args, we'll reverse an init-value:)
operator(()ident(define-macro) operator(()ident(define-default-class) ident(name) ident(supers) operator(.) ident(default&slots)operator(\))
  error(`)operator(()ident(define-class) error(,)ident(name) error(,)ident(supers)
     error(,)ident(@)operator(()ident(map) operator(()keyword(lambda) operator(()ident(d&s)operator(\)) operator(()ident(list) operator(()ident(cadr) ident(d&s)operator(\))
                                error(#)ident(:init-value) operator(()ident(car) ident(d&s)operator(\))
                                error(#)ident(:accessor) operator(()ident(cadr) ident(d&s)operator(\))operator(\))operator(\))
            ident(default&slots)operator(\))operator(\))operator(\))

operator(()ident(define-default-class) ident(hostent) operator(()operator(\))
  operator(()string<delimiter(")delimiter(")> ident(name)operator(\))
  operator(()operator(')operator(()operator(\)) ident(aliases)operator(\))
  operator(()string<delimiter(")delimiter(")> ident(addrtype)operator(\))
  operator(()integer(0)  ident(length)operator(\))
  operator(()operator(')operator(()operator(\)) ident(addr-list)operator(\))operator(\))

comment(;; Nothing special needed for Aliases - all names are equal)
operator(()keyword(define) ident(type) ident(addrtype)operator(\))
operator(()ident(define-method) operator(()ident(addr) operator(()ident(h) ident(<hostent>)operator(\))operator(\))
  operator(()ident(car) operator(()ident(addr-list) ident(h)operator(\))operator(\))operator(\))

comment(;; @@PLEAC@@_13.6)
comment(;; A little more clear than the Perl, but not very useful.)
operator(()keyword(define) ident(obj1) operator(()ident(make) ident(<some-class>)operator(\))operator(\))
operator(()keyword(define) ident(obj2) operator(()ident(make) operator(()ident(class-of) ident(obj1)operator(\))operator(\))operator(\))

comment(;; Use the shallow-clone or deep-clone methods to initialize from)
comment(;; another instance.)
operator(()keyword(define) ident(obj1) operator(()ident(make) ident(<widget>)operator(\))operator(\))
operator(()keyword(define) ident(obj2) operator(()ident(deep-clone) ident(obj1)operator(\))operator(\))

comment(;; @@PLEAC@@_13.7)
comment(;; Use eval or a variant to convert from a symbol or string to the)
comment(;; actual method.  As shown in 13.5 above, methods are first class and)
comment(;; you'd be more likely to store the actual method than the name in a)
comment(;; real Scheme program.)
operator(()keyword(define) ident(methname) string<delimiter(")content(flicker)delimiter(")>operator(\))
operator(()ident(apply-generic) operator(()ident(eval-string) ident(methname)operator(\)) ident(obj) integer(10)operator(\))

operator(()ident(for-each) operator(()keyword(lambda) operator(()ident(m)operator(\)) operator(()ident(apply-generic) ident(obj) operator(()ident(eval-string) ident(m)operator(\))operator(\))operator(\))
          operator(')operator(()string<delimiter(")content(start)delimiter(")> string<delimiter(")content(run)delimiter(")> string<delimiter(")content(stop)delimiter(")>operator(\))operator(\))

comment(;; really, don't do this...)
operator(()keyword(define) ident(methods) operator(')operator(()string<delimiter(")content(name)delimiter(")> string<delimiter(")content(rank)delimiter(")> string<delimiter(")content(serno)delimiter(")>operator(\))operator(\))
operator(()keyword(define) ident(his-info)
  operator(()ident(map) operator(()keyword(lambda) operator(()ident(m)operator(\)) operator(()keyword(cons) ident(m) operator(()ident(apply-generic) operator(()ident(eval-string) ident(m)operator(\)) ident(obj)operator(\))operator(\))operator(\))
       ident(methods)operator(\))operator(\))

comment(;; same as this:)
operator(()keyword(define) ident(his-info) operator(()ident(list) operator(()keyword(cons) string<delimiter(")content(name)delimiter(")> operator(()ident(name) ident(obj)operator(\))operator(\))
                       operator(()keyword(cons) string<delimiter(")content(rank)delimiter(")> operator(()ident(rank) ident(obj)operator(\))operator(\))
                       operator(()keyword(cons) string<delimiter(")content(serno)delimiter(")> operator(()ident(serno) ident(obj)operator(\))operator(\))operator(\))operator(\))

comment(;; a closure works)
operator(()keyword(define) ident(fnref) operator(()keyword(lambda) ident(args) operator(()ident(method) ident(obj) ident(args)operator(\))operator(\))operator(\))
operator(()ident(fnref) integer(10) string<delimiter(")content(fred)delimiter(")>operator(\))
operator(()ident(method) ident(obj) integer(10) ident(fred)operator(\))

comment(;; @@PLEAC@@_13.8)
comment(;; use is-a?)
operator(()ident(is-a?) ident(obj) ident(<http-message>)operator(\))
operator(()ident(is-a?) ident(<http-response>) ident(<http-message>)operator(\))