head[head(Index: )plain(lib/coderay/token_classes.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay/token_classes.rb)plain(	(revision 0\))]
head[head(+++ )filename(lib/coderay/token_classes.rb)plain(	(revision 250\))]
change[change(@@)plain( -0,0 +1,71 )change(@@)]
insert[insert(+)keyword(module) class(CodeRay)]
insert[insert(+)  keyword(class) class(Tokens)]
insert[insert(+)    constant(ClassOfKind) operator(=) constant(Hash)operator(.)ident(new) keyword(do) operator(|)ident(h)operator(,) ident(k)operator(|)]
insert[insert(+)      ident(h)operator([)ident(k)operator(]) operator(=) ident(k)operator(.)ident(to_s)]
insert[insert(+)    keyword(end)]
insert[insert(+)    constant(ClassOfKind)operator(.)ident(update) ident(with) operator(=) operator({)]
insert[insert(+)      symbol(:attribute_name) operator(=)operator(>) string<delimiter(')content(an)delimiter(')>operator(,)]
insert[insert(+)      symbol(:attribute_name_fat) operator(=)operator(>) string<delimiter(')content(af)delimiter(')>operator(,)]
insert[insert(+)      symbol(:attribute_value) operator(=)operator(>) string<delimiter(')content(av)delimiter(')>operator(,)]
insert[insert(+)      symbol(:attribute_value_fat) operator(=)operator(>) string<delimiter(')content(aw)delimiter(')>operator(,)]
insert[insert(+)      symbol(:bin) operator(=)operator(>) string<delimiter(')content(bi)delimiter(')>operator(,)]
insert[insert(+)      symbol(:char) operator(=)operator(>) string<delimiter(')content(ch)delimiter(')>operator(,)]
insert[insert(+)      symbol(:class) operator(=)operator(>) string<delimiter(')content(cl)delimiter(')>operator(,)]
insert[insert(+)      symbol(:class_variable) operator(=)operator(>) string<delimiter(')content(cv)delimiter(')>operator(,)]
insert[insert(+)      symbol(:color) operator(=)operator(>) string<delimiter(')content(cr)delimiter(')>operator(,)]
insert[insert(+)      symbol(:comment) operator(=)operator(>) string<delimiter(')content(c)delimiter(')>operator(,)]
insert[insert(+)      symbol(:constant) operator(=)operator(>) string<delimiter(')content(co)delimiter(')>operator(,)]
insert[insert(+)      symbol(:content) operator(=)operator(>) string<delimiter(')content(k)delimiter(')>operator(,)]
insert[insert(+)      symbol(:definition) operator(=)operator(>) string<delimiter(')content(df)delimiter(')>operator(,)]
insert[insert(+)      symbol(:delimiter) operator(=)operator(>) string<delimiter(')content(dl)delimiter(')>operator(,)]
insert[insert(+)      symbol(:directive) operator(=)operator(>) string<delimiter(')content(di)delimiter(')>operator(,)]
insert[insert(+)      symbol(:doc) operator(=)operator(>) string<delimiter(')content(do)delimiter(')>operator(,)]
insert[insert(+)      symbol(:doc_string) operator(=)operator(>) string<delimiter(')content(ds)delimiter(')>operator(,)]
insert[insert(+)      symbol(:entity) operator(=)operator(>) string<delimiter(')content(en)delimiter(')>operator(,)]
insert[insert(+)      symbol(:error) operator(=)operator(>) string<delimiter(')content(er)delimiter(')>operator(,)]
insert[insert(+)      symbol(:escape) operator(=)operator(>) string<delimiter(')content(e)delimiter(')>operator(,)]
insert[insert(+)      symbol(:exception) operator(=)operator(>) string<delimiter(')content(ex)delimiter(')>operator(,)]
insert[insert(+)      symbol(:float) operator(=)operator(>) string<delimiter(')content(fl)delimiter(')>operator(,)]
insert[insert(+)      symbol(:function) operator(=)operator(>) string<delimiter(')content(fu)delimiter(')>operator(,)]
insert[insert(+)      symbol(:global_variable) operator(=)operator(>) string<delimiter(')content(gv)delimiter(')>operator(,)]
insert[insert(+)      symbol(:hex) operator(=)operator(>) string<delimiter(')content(hx)delimiter(')>operator(,)]
insert[insert(+)      symbol(:include) operator(=)operator(>) string<delimiter(')content(ic)delimiter(')>operator(,)]
insert[insert(+)      symbol(:inline) operator(=)operator(>) string<delimiter(')content(il)delimiter(')>operator(,)]
insert[insert(+)      symbol(:inline_delimiter) operator(=)operator(>) string<delimiter(')content(idl)delimiter(')>operator(,)]
insert[insert(+)      symbol(:instance_variable) operator(=)operator(>) string<delimiter(')content(iv)delimiter(')>operator(,)]
insert[insert(+)      symbol(:integer) operator(=)operator(>) string<delimiter(')content(i)delimiter(')>operator(,)]
insert[insert(+)      symbol(:interpreted) operator(=)operator(>) string<delimiter(')content(in)delimiter(')>operator(,)]
insert[insert(+)      symbol(:label) operator(=)operator(>) string<delimiter(')content(la)delimiter(')>operator(,)]
insert[insert(+)      symbol(:local_variable) operator(=)operator(>) string<delimiter(')content(lv)delimiter(')>operator(,)]
insert[insert(+)      symbol(:modifier) operator(=)operator(>) string<delimiter(')content(mod)delimiter(')>operator(,)]
insert[insert(+)      symbol(:oct) operator(=)operator(>) string<delimiter(')content(oc)delimiter(')>operator(,)]
insert[insert(+)      symbol(:operator_fat) operator(=)operator(>) string<delimiter(')content(of)delimiter(')>operator(,)]
insert[insert(+)      symbol(:pre_constant) operator(=)operator(>) string<delimiter(')content(pc)delimiter(')>operator(,)]
insert[insert(+)      symbol(:pre_type) operator(=)operator(>) string<delimiter(')content(pt)delimiter(')>operator(,)]
insert[insert(+)      symbol(:predefined) operator(=)operator(>) string<delimiter(')content(pd)delimiter(')>operator(,)]
insert[insert(+)      symbol(:preprocessor) operator(=)operator(>) string<delimiter(')content(pp)delimiter(')>operator(,)]
insert[insert(+)      symbol(:regexp) operator(=)operator(>) string<delimiter(')content(rx)delimiter(')>operator(,)]
insert[insert(+)      symbol(:reserved) operator(=)operator(>) string<delimiter(')content(r)delimiter(')>operator(,)]
insert[insert(+)      symbol(:shell) operator(=)operator(>) string<delimiter(')content(sh)delimiter(')>operator(,)]
insert[insert(+)      symbol(:string) operator(=)operator(>) string<delimiter(')content(s)delimiter(')>operator(,)]
insert[insert(+)      symbol(:symbol) operator(=)operator(>) string<delimiter(')content(sy)delimiter(')>operator(,)]
insert[insert(+)      symbol(:tag) operator(=)operator(>) string<delimiter(')content(ta)delimiter(')>operator(,)]
insert[insert(+)      symbol(:tag_fat) operator(=)operator(>) string<delimiter(')content(tf)delimiter(')>operator(,)]
insert[insert(+)      symbol(:tag_special) operator(=)operator(>) string<delimiter(')content(ts)delimiter(')>operator(,)]
insert[insert(+)      symbol(:type) operator(=)operator(>) string<delimiter(')content(ty)delimiter(')>operator(,)]
insert[insert(+)      symbol(:variable) operator(=)operator(>) string<delimiter(')content(v)delimiter(')>operator(,)]
insert[insert(+)      symbol(:xml_text) operator(=)operator(>) string<delimiter(')content(xt)delimiter(')>operator(,)]
insert[insert(+)]
insert[insert(+)      symbol(:ident) operator(=)operator(>) symbol(:NO_HIGHLIGHT)operator(,) comment(# 'id')]
insert[insert(+)      comment(#:operator => 'op',)]
insert[insert(+)      symbol(:operator) operator(=)operator(>) symbol(:NO_HIGHLIGHT)operator(,)  comment(# 'op')]
insert[insert(+)      symbol(:space) operator(=)operator(>) symbol(:NO_HIGHLIGHT)operator(,)  comment(# 'sp')]
insert[insert(+)      symbol(:plain) operator(=)operator(>) symbol(:NO_HIGHLIGHT)operator(,)]
insert[insert(+)    operator(})]
insert[insert(+)    constant(ClassOfKind)operator([)symbol(:procedure)operator(]) operator(=) constant(ClassOfKind)operator([)symbol(:method)operator(]) operator(=) constant(ClassOfKind)operator([)symbol(:function)operator(])]
insert[insert(+)    constant(ClassOfKind)operator([)symbol(:open)operator(]) operator(=) constant(ClassOfKind)operator([)symbol(:close)operator(]) operator(=) constant(ClassOfKind)operator([)symbol(:delimiter)operator(])]
insert[insert(+)    constant(ClassOfKind)operator([)symbol(:nesting_delimiter)operator(]) operator(=) constant(ClassOfKind)operator([)symbol(:delimiter)operator(])]
insert[insert(+)    constant(ClassOfKind)operator([)symbol(:escape)operator(]) operator(=) constant(ClassOfKind)operator([)symbol(:delimiter)operator(])]
insert[insert(+)    comment(#ClassOfKind.default = ClassOfKind[:error] or raise 'no class found for :error!')]
insert[insert(+)  keyword(end)]
insert[insert(+)keyword(end)]
comment(\\ No newline at end of file)

head[head(Property changes on: )plain(lib/coderay/token_classes.rb)]
head[head(___________________________________________________________________)]
head[head(Added: )plain(svn:executable)]
insert[insert(   +)plain( *)]

head[head(Index: )plain(lib/coderay/encoder.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay/encoder.rb)plain(	(revision 200\))]
head[head(+++ )filename(lib/coderay/encoder.rb)plain(	(revision 250\))]
change[change(@@)plain( -1,3 +1,5 )change(@@)]
insert[insert(+)ident(require) string<delimiter(")content(stringio)delimiter(")>]
insert[insert(+)]
 keyword(module) class(CodeRay)
 
   comment(# This module holds the Encoder class and its subclasses.)
change[change(@@)plain( -40,7 +42,7 )change(@@)]
         comment(# downcase class name instead.)
         keyword(def) method(const_missing) ident(sym)
           keyword(if) ident(sym) operator(==) symbol(:FILE_EXTENSION)
delete[delete(-)            eyecatcher<ident(sym)operator(.)ident(to_s)operator(.)ident(downcase)>]
insert[insert(+)            eyecatcher<ident(plugin_id)>]
           keyword(else)
             keyword(super)
           keyword(end)
change[change(@@)plain( -130,13 +132,15 )change(@@)]
       comment(# By default, it calls text_token or block_token, depending on)
       comment(# whether +text+ is a String.)
       keyword(def) method(token) ident(text)operator(,) ident(kind)
delete[delete(-)        keyword(if) ident(text)operator(.)ident(instance_of?) operator(::)constant(String)  comment(# Ruby 1.9: :open.is_a? String)]
delete[delete(-)          ident(text_token) ident(text)operator(,) ident(kind)]
delete[delete(-)        keyword(elsif) ident(text)operator(.)ident(is_a?) operator(::)constant(Symbol)]
delete[delete(-)          ident(block_token) ident(text)operator(,) ident(kind)]
delete[delete(-)        keyword(else)]
delete[delete(-)          ident(raise) string<delimiter(')content(Unknown token text type: %p)delimiter(')> operator(%) ident(text)]
delete[delete(-)        keyword(end)]
insert[insert(+)        ident(out) operator(=)]
insert[insert(+)          keyword(if) ident(text)operator(.)ident(is_a?) operator(::)constant(String)  comment(# Ruby 1.9: :open.is_a? String)]
insert[insert(+)            ident(text_token) ident(text)operator(,) ident(kind)]
insert[insert(+)          keyword(elsif) ident(text)operator(.)ident(is_a?) operator(::)constant(Symbol)]
insert[insert(+)            ident(block_token) ident(text)operator(,) ident(kind)]
insert[insert(+)          keyword(else)]
insert[insert(+)            ident(raise) string<delimiter(')content(Unknown token text type: %p)delimiter(')> operator(%) ident(text)]
insert[insert(+)          keyword(end)]
insert[insert(+)        instance_variable(@out) operator(<<) ident(out) keyword(if) keyword(defined?)operator(()instance_variable(@out)operator(\)) operator(&&) instance_variable(@out)]
       keyword(end)
 
       keyword(def) method(text_token) ident(text)operator(,) ident(kind)
change[change(@@)plain( -164,7 +168,8 )change(@@)]
       comment(# The already created +tokens+ object must be used; it can be a)
       comment(# TokenStream or a Tokens object.)
       keyword(def) method(compile) ident(tokens)operator(,) ident(options)
delete[delete(-)        ident(tokens)operator(.)ident(each)operator(()operator(&)predefined_constant(self)operator(\))]
insert[insert(+)        ident(tokens)operator(.)ident(each) operator({) operator(|)ident(text)operator(,) ident(kind)operator(|) ident(token) ident(text)operator(,) ident(kind) operator(})  comment(# FIXME for Ruby 1.9?)]
insert[insert(+)        comment(#tokens.each(&self\))]
       keyword(end)
 
     keyword(end)
head[head(Index: )plain(lib/coderay/encoders/xml.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay/encoders/xml.rb)plain(	(revision 200\))]
head[head(+++ )filename(lib/coderay/encoders/xml.rb)plain(	(revision 250\))]
change[change(@@)plain( -22,7 +22,6 )change(@@)]
   ident(protected)
 
     keyword(def) method(setup) ident(options)
delete[delete(-)      instance_variable(@out) operator(=) string<delimiter(')delimiter(')>]
       instance_variable(@doc) operator(=) constant(REXML)operator(::)constant(Document)operator(.)ident(new)
       instance_variable(@doc) operator(<<) constant(REXML)operator(::)constant(XMLDecl)operator(.)ident(new)
       instance_variable(@tab_width) operator(=) ident(options)operator([)symbol(:tab_width)operator(])
change[change(@@)plain( -33,7 +32,7 )change(@@)]
       instance_variable(@doc)operator(.)ident(write) instance_variable(@out)operator(,) ident(options)operator([)symbol(:pretty)operator(])operator(,) ident(options)operator([)symbol(:transitive)operator(])operator(,) predefined_constant(true)
       instance_variable(@out)
     keyword(end)
delete[delete(-)]
insert[insert(+)eyecatcher<    >]
     keyword(def) method(text_token) ident(text)operator(,) ident(kind)
       keyword(if) ident(kind) operator(==) symbol(:space)
         ident(token) operator(=) instance_variable(@node)
head[head(Index: )plain(lib/coderay/encoders/html/classes.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay/encoders/html/classes.rb)plain(	(revision 200\))]
head[head(+++ )filename(lib/coderay/encoders/html/classes.rb)plain(	(revision 250\))]
change[change(@@)plain( -1,77 +0,0 )change(@@)]
delete[delete(-)keyword(module) class(CodeRay)]
delete[delete(-)keyword(module) class(Encoders)]
delete[delete(-)]
delete[delete(-)  keyword(class) class(HTML)]
delete[delete(-)]
delete[delete(-)    constant(ClassOfKind) operator(=) constant(Hash)operator(.)ident(new) keyword(do) operator(|)ident(h)operator(,) ident(k)operator(|)]
delete[delete(-)      ident(h)operator([)ident(k)operator(]) operator(=) ident(k)operator(.)ident(to_s)]
delete[delete(-)    keyword(end)]
delete[delete(-)    constant(ClassOfKind)operator(.)ident(update) ident(with) operator(=) operator({)]
delete[delete(-)      symbol(:attribute_name) operator(=)operator(>) string<delimiter(')content(an)delimiter(')>operator(,)]
delete[delete(-)      symbol(:attribute_name_fat) operator(=)operator(>) string<delimiter(')content(af)delimiter(')>operator(,)]
delete[delete(-)      symbol(:attribute_value) operator(=)operator(>) string<delimiter(')content(av)delimiter(')>operator(,)]
delete[delete(-)      symbol(:attribute_value_fat) operator(=)operator(>) string<delimiter(')content(aw)delimiter(')>operator(,)]
delete[delete(-)      symbol(:bin) operator(=)operator(>) string<delimiter(')content(bi)delimiter(')>operator(,)]
delete[delete(-)      symbol(:char) operator(=)operator(>) string<delimiter(')content(ch)delimiter(')>operator(,)]
delete[delete(-)      symbol(:class) operator(=)operator(>) string<delimiter(')content(cl)delimiter(')>operator(,)]
delete[delete(-)      symbol(:class_variable) operator(=)operator(>) string<delimiter(')content(cv)delimiter(')>operator(,)]
delete[delete(-)      symbol(:color) operator(=)operator(>) string<delimiter(')content(cr)delimiter(')>operator(,)]
delete[delete(-)      symbol(:comment) operator(=)operator(>) string<delimiter(')content(c)delimiter(')>operator(,)]
delete[delete(-)      symbol(:constant) operator(=)operator(>) string<delimiter(')content(co)delimiter(')>operator(,)]
delete[delete(-)      symbol(:content) operator(=)operator(>) string<delimiter(')content(k)delimiter(')>operator(,)]
delete[delete(-)      symbol(:definition) operator(=)operator(>) string<delimiter(')content(df)delimiter(')>operator(,)]
delete[delete(-)      symbol(:delimiter) operator(=)operator(>) string<delimiter(')content(dl)delimiter(')>operator(,)]
delete[delete(-)      symbol(:directive) operator(=)operator(>) string<delimiter(')content(di)delimiter(')>operator(,)]
delete[delete(-)      symbol(:doc) operator(=)operator(>) string<delimiter(')content(do)delimiter(')>operator(,)]
delete[delete(-)      symbol(:doc_string) operator(=)operator(>) string<delimiter(')content(ds)delimiter(')>operator(,)]
delete[delete(-)      symbol(:entity) operator(=)operator(>) string<delimiter(')content(en)delimiter(')>operator(,)]
delete[delete(-)      symbol(:error) operator(=)operator(>) string<delimiter(')content(er)delimiter(')>operator(,)]
delete[delete(-)      symbol(:escape) operator(=)operator(>) string<delimiter(')content(e)delimiter(')>operator(,)]
delete[delete(-)      symbol(:exception) operator(=)operator(>) string<delimiter(')content(ex)delimiter(')>operator(,)]
delete[delete(-)      symbol(:float) operator(=)operator(>) string<delimiter(')content(fl)delimiter(')>operator(,)]
delete[delete(-)      symbol(:function) operator(=)operator(>) string<delimiter(')content(fu)delimiter(')>operator(,)]
delete[delete(-)      symbol(:global_variable) operator(=)operator(>) string<delimiter(')content(gv)delimiter(')>operator(,)]
delete[delete(-)      symbol(:hex) operator(=)operator(>) string<delimiter(')content(hx)delimiter(')>operator(,)]
delete[delete(-)      symbol(:include) operator(=)operator(>) string<delimiter(')content(ic)delimiter(')>operator(,)]
delete[delete(-)      symbol(:inline) operator(=)operator(>) string<delimiter(')content(il)delimiter(')>operator(,)]
delete[delete(-)      symbol(:inline_delimiter) operator(=)operator(>) string<delimiter(')content(idl)delimiter(')>operator(,)]
delete[delete(-)      symbol(:instance_variable) operator(=)operator(>) string<delimiter(')content(iv)delimiter(')>operator(,)]
delete[delete(-)      symbol(:integer) operator(=)operator(>) string<delimiter(')content(i)delimiter(')>operator(,)]
delete[delete(-)      symbol(:interpreted) operator(=)operator(>) string<delimiter(')content(in)delimiter(')>operator(,)]
delete[delete(-)      symbol(:label) operator(=)operator(>) string<delimiter(')content(la)delimiter(')>operator(,)]
delete[delete(-)      symbol(:local_variable) operator(=)operator(>) string<delimiter(')content(lv)delimiter(')>operator(,)]
delete[delete(-)      symbol(:modifier) operator(=)operator(>) string<delimiter(')content(mod)delimiter(')>operator(,)]
delete[delete(-)      symbol(:oct) operator(=)operator(>) string<delimiter(')content(oc)delimiter(')>operator(,)]
delete[delete(-)      symbol(:operator_name) operator(=)operator(>) string<delimiter(')content(on)delimiter(')>operator(,)]
delete[delete(-)      symbol(:pre_constant) operator(=)operator(>) string<delimiter(')content(pc)delimiter(')>operator(,)]
delete[delete(-)      symbol(:pre_type) operator(=)operator(>) string<delimiter(')content(pt)delimiter(')>operator(,)]
delete[delete(-)      symbol(:predefined) operator(=)operator(>) string<delimiter(')content(pd)delimiter(')>operator(,)]
delete[delete(-)      symbol(:preprocessor) operator(=)operator(>) string<delimiter(')content(pp)delimiter(')>operator(,)]
delete[delete(-)      symbol(:regexp) operator(=)operator(>) string<delimiter(')content(rx)delimiter(')>operator(,)]
delete[delete(-)      symbol(:reserved) operator(=)operator(>) string<delimiter(')content(r)delimiter(')>operator(,)]
delete[delete(-)      symbol(:shell) operator(=)operator(>) string<delimiter(')content(sh)delimiter(')>operator(,)]
delete[delete(-)      symbol(:string) operator(=)operator(>) string<delimiter(')content(s)delimiter(')>operator(,)]
delete[delete(-)      symbol(:symbol) operator(=)operator(>) string<delimiter(')content(sy)delimiter(')>operator(,)]
delete[delete(-)      symbol(:tag) operator(=)operator(>) string<delimiter(')content(ta)delimiter(')>operator(,)]
delete[delete(-)      symbol(:tag_fat) operator(=)operator(>) string<delimiter(')content(tf)delimiter(')>operator(,)]
delete[delete(-)      symbol(:tag_special) operator(=)operator(>) string<delimiter(')content(ts)delimiter(')>operator(,)]
delete[delete(-)      symbol(:type) operator(=)operator(>) string<delimiter(')content(ty)delimiter(')>operator(,)]
delete[delete(-)      symbol(:variable) operator(=)operator(>) string<delimiter(')content(v)delimiter(')>operator(,)]
delete[delete(-)      symbol(:xml_text) operator(=)operator(>) string<delimiter(')content(xt)delimiter(')>operator(,)]
delete[delete(-)]
delete[delete(-)      symbol(:ident) operator(=)operator(>) symbol(:NO_HIGHLIGHT)operator(,) comment(# 'id')]
delete[delete(-)      comment(#:operator => 'op',)]
delete[delete(-)      symbol(:operator) operator(=)operator(>) symbol(:NO_HIGHLIGHT)operator(,)  comment(# 'op')]
delete[delete(-)      symbol(:space) operator(=)operator(>) symbol(:NO_HIGHLIGHT)operator(,)  comment(# 'sp')]
delete[delete(-)      symbol(:plain) operator(=)operator(>) symbol(:NO_HIGHLIGHT)operator(,)]
delete[delete(-)    operator(})]
delete[delete(-)    constant(ClassOfKind)operator([)symbol(:procedure)operator(]) operator(=) constant(ClassOfKind)operator([)symbol(:method)operator(]) operator(=) constant(ClassOfKind)operator([)symbol(:function)operator(])]
delete[delete(-)    constant(ClassOfKind)operator([)symbol(:open)operator(]) operator(=) constant(ClassOfKind)operator([)symbol(:close)operator(]) operator(=) constant(ClassOfKind)operator([)symbol(:delimiter)operator(])]
delete[delete(-)    constant(ClassOfKind)operator([)symbol(:nesting_delimiter)operator(]) operator(=) constant(ClassOfKind)operator([)symbol(:delimiter)operator(])]
delete[delete(-)    constant(ClassOfKind)operator([)symbol(:escape)operator(]) operator(=) constant(ClassOfKind)operator([)symbol(:delimiter)operator(])]
delete[delete(-)    comment(#ClassOfKind.default = ClassOfKind[:error] or raise 'no class found for :error!')]
delete[delete(-)]
delete[delete(-)  keyword(end)]
delete[delete(-)]
delete[delete(-)keyword(end)]
delete[delete(-)keyword(end)]
head[head(Index: )plain(lib/coderay/encoders/html/numerization.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay/encoders/html/numerization.rb)plain(	(revision 200\))]
head[head(+++ )filename(lib/coderay/encoders/html/numerization.rb)plain(	(revision 250\))]
change[change(@@)plain( -51,12 +51,12 )change(@@)]
         keyword(case) ident(mode)
         keyword(when) symbol(:inline)
           ident(max_width) operator(=) operator(()ident(start) operator(+) ident(line_count)operator(\))operator(.)ident(to_s)operator(.)ident(size)
delete[delete(-)          ident(line) operator(=) ident(start)]
insert[insert(+)          ident(line)eyecatcher<ident(_number)> operator(=) ident(start)]
           ident(gsub!)operator(()regexp<delimiter(/)content(^)delimiter(/)>operator(\)) keyword(do)
delete[delete(-)            ident(line_number)eyecatcher< operator(=) ident(bolding)operator(.)ident(call) ident(line)>]
delete[delete(-)            ident(indent) operator(=) string<delimiter(')content( )delimiter(')> operator(*) operator(()ident(max_width) operator(-) ident(line)eyecatcher<operator(.)ident(to_s)operator(.)ident(size)>operator(\))]
delete[delete(-)            ident(res) operator(=) string<delimiter(")content(<span class=)char(\\")content(no)char(\\")content(>)inline<inline_delimiter(#{)ident(indent)inline_delimiter(})>inline<inline_delimiter(#{)ident(line_number)>>string<inline<inline_delimiter(})>content(</span> )delimiter(")>]
delete[delete(-)            ident(line) operator(+=) integer(1)]
insert[insert(+)            ident(line_number)eyecatcher<ident(_text) operator(=) ident(bolding)operator(.)ident(call) ident(line_number)>]
insert[insert(+)            ident(indent) operator(=) string<delimiter(')content( )delimiter(')> operator(*) operator(()ident(max_width) operator(-) ident(line)eyecatcher<ident(_number)operator(.)ident(to_s)operator(.)ident(size)operator(\))  comment(# TODO: Optimize (10^x)>comment(\))]
insert[insert(+)            ident(res) operator(=) string<delimiter(")content(<span class=)char(\\")content(no)char(\\")content(>)inline<inline_delimiter(#{)ident(indent)inline_delimiter(})>inline<inline_delimiter(#{)ident(line_number)>>eyecatcher<string<inline<ident(_text)>>>string<inline<inline_delimiter(})>content(</span> )delimiter(")>]
insert[insert(+)            ident(line)eyecatcher<ident(_number)> operator(+=) integer(1)]
             ident(res)
           keyword(end)
 
head[head(Index: )plain(lib/coderay/encoders/tokens.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay/encoders/tokens.rb)plain(	(revision 200\))]
head[head(+++ )filename(lib/coderay/encoders/tokens.rb)plain(	(revision 250\))]
change[change(@@)plain( -33,9 +33,9 )change(@@)]
 
     constant(FILE_EXTENSION) operator(=) string<delimiter(')content(tok)delimiter(')>
 
delete[delete(-)  eyecatcher<  >ident(protected)]
delete[delete(-)    keyword(def) method(token) eyecatcher<operator(*)ident(args)>]
delete[delete(-)      instance_variable(@out) operator(<<) constant(CodeRay)operator(::)constant(Tokens)operator(.)ident(write_token)operator(()eyecatcher<operator(*)ident(args)>operator(\))]
insert[insert(+)  ident(protected)]
insert[insert(+)    keyword(def) method(token) eyecatcher<ident(text)operator(,) ident(kind)>]
insert[insert(+)      instance_variable(@out) operator(<<) constant(CodeRay)operator(::)constant(Tokens)operator(.)ident(write_token)operator(()eyecatcher<ident(text)operator(,) ident(kind)>operator(\))]
     keyword(end)
 
   keyword(end)
head[head(Index: )plain(lib/coderay/encoders/html.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay/encoders/html.rb)plain(	(revision 200\))]
head[head(+++ )filename(lib/coderay/encoders/html.rb)plain(	(revision 250\))]
change[change(@@)plain( -1,3 +1,5 )change(@@)]
insert[insert(+)ident(require) string<delimiter(")content(set)delimiter(")>]
insert[insert(+)]
 keyword(module) class(CodeRay)
 keyword(module) class(Encoders)
 
change[change(@@)plain( -10,7 +12,8 )change(@@)]
   comment(#)
   comment(#  require 'coderay')
   comment(#  puts CodeRay.scan('Some /code/', :ruby\).html  #-> a HTML page)
delete[delete(-)  comment(#  puts CodeRay.scan('Some /code/', :ruby\).html(:wrap => :span\) #-> <span class="CodeRay"><span class="co">Some</span> /code/</span>)]
insert[insert(+)  comment(#  puts CodeRay.scan('Some /code/', :ruby\).html(:wrap => :span\))]
insert[insert(+)  comment(#  #-> <span class="CodeRay"><span class="co">Some</span> /code/</span>)]
   comment(#  puts CodeRay.scan('Some /code/', :ruby\).span  #-> the same)
   comment(#  )
   comment(#  puts CodeRay.scan('Some code', :ruby\).html()
change[change(@@)plain( -55,7 +58,8 )change(@@)]
   comment(#)
   comment(# === :hint)
   comment(# Include some information into the output using the title attribute.)
delete[delete(-)  comment(# Can be :info (show token type on mouse-over\), :info_long (with full path\) or :debug (via inspect\).)]
insert[insert(+)  comment(# Can be :info (show token type on mouse-over\), :info_long (with full path\))]
insert[insert(+)  comment(# or :debug (via inspect\).)]
   comment(#)
   comment(# Default: false)
   keyword(class) class(HTML) operator(<) constant(Encoder)
change[change(@@)plain( -82,7 +86,7 )change(@@)]
       symbol(:hint) operator(=)operator(>) predefined_constant(false)operator(,)
     operator(})
 
delete[delete(-)    ident(helper) symbol(:)eyecatcher<symbol(classes)operator(,) symbol(:)>symbol(output)operator(,) symbol(:css)]
insert[insert(+)    ident(helper) symbol(:)symbol(output)operator(,) symbol(:css)]
 
     ident(attr_reader) symbol(:css)
 
change[change(@@)plain( -115,11 +119,14 )change(@@)]
         keyword(end)
     operator(})
 
insert[insert(+)    constant(TRANSPARENT_TOKEN_KINDS) operator(=) operator([)]
insert[insert(+)      symbol(:delimiter)operator(,) symbol(:modifier)operator(,) symbol(:content)operator(,) symbol(:escape)operator(,) symbol(:inline_delimiter)operator(,)]
insert[insert(+)    operator(])operator(.)ident(to_set)]
insert[insert(+)]
     comment(# Generate a hint about the given +classes+ in a +hint+ style.)
     comment(#)
     comment(# +hint+ may be :info, :info_long or :debug.)
     keyword(def) predefined_constant(self)operator(.)method(token_path_to_hint) ident(hint)operator(,) ident(classes)
delete[delete(-)      keyword(return) string<delimiter(')delimiter(')> keyword(unless) ident(hint)]
       ident(title) operator(=)
         keyword(case) ident(hint)
         keyword(when) symbol(:info)
change[change(@@)plain( -129,7 +136,7 )change(@@)]
         keyword(when) symbol(:debug)
           ident(classes)operator(.)ident(inspect)
         keyword(end)
delete[delete(-)      string<>eyecatcher<string<delimiter(")content( title=)char(\\")inline<inline_delimiter(#{)ident(title)inline_delimiter(})>char(\\")delimiter(")>>]
insert[insert(+)      eyecatcher<ident(title) operator(?) string<delimiter(")content( title=)char(\\")inline<inline_delimiter(#{)ident(title)inline_delimiter(})>char(\\")delimiter(")> operator(:) string<delimiter(')delimiter(')>>]
     keyword(end)
 
     keyword(def) method(setup) ident(options)
change[change(@@)plain( -143,42 +150,45 )change(@@)]
 
       ident(hint) operator(=) ident(options)operator([)symbol(:hint)operator(])
       keyword(if) ident(hint) keyword(and) keyword(not) operator([)symbol(:debug)operator(,) symbol(:info)operator(,) symbol(:info_long)operator(])operator(.)ident(include?) ident(hint)
delete[delete(-)        ident(raise) constant(ArgumentError)operator(,) string<delimiter(")content(Unknown value %p for :hint; expected :info, :debug, false or nil.)delimiter(")> operator(%) ident(hint)]
insert[insert(+)        ident(raise) constant(ArgumentError)operator(,) string<delimiter(")content(Unknown value %p for :hint; )error(\\)>]
insert[insert(+)string<content(          expected :info, :debug, false, or nil.)delimiter(")> operator(%) ident(hint)]
       keyword(end)
 
       keyword(case) ident(options)operator([)symbol(:css)operator(])
 
       keyword(when) symbol(:class)
         instance_variable(@css_style) operator(=) constant(Hash)operator(.)ident(new) keyword(do) operator(|)ident(h)operator(,) ident(k)operator(|)
delete[delete(-)          keyword(if) ident(k)operator(.)ident(is_a?) constant(Array)]
delete[delete(-)            ident(type) operator(=) ident(k)operator(.)ident(first)]
delete[delete(-)          keyword(else)]
delete[delete(-)            ident(type) operator(=) ident(k)]
delete[delete(-)          keyword(end)]
delete[delete(-)          ident(c) operator(=) constant(ClassOfKind)operator([)ident(type)operator(])]
insert[insert(+)          ident(c) operator(=) constant(CodeRay)operator(::)constant(Tokens)operator(::)constant(ClassOfKind)operator([)ident(k)operator(.)ident(first)operator(])]
           keyword(if) ident(c) operator(==) symbol(:NO_HIGHLIGHT) keyword(and) keyword(not) ident(hint)
delete[delete(-)            ident(h)operator([)ident(k)operator(]) operator(=) predefined_constant(false)]
insert[insert(+)            ident(h)operator([)ident(k)eyecatcher<operator(.)ident(dup)>operator(]) operator(=) predefined_constant(false)]
           keyword(else)
delete[delete(-)            ident(title) operator(=) constant(HTML)operator(.)ident(token_path_to_hint) ident(hint)operator(,) operator(()ident(k)operator([)integer(1)operator(..)integer(-1)operator(]) operator(<<) ident(k)operator(.)ident(first)operator(\))]
delete[delete(-)            ident(h)operator([)ident(k)operator(]) operator(=) string<delimiter(')content(<span%s class="%s">)delimiter(')> operator(%) operator([)ident(title)operator(,) ident(c)operator(])]
insert[insert(+)            ident(title) operator(=) keyword(if) ident(hint)]
insert[insert(+)              constant(HTML)operator(.)ident(token_path_to_hint)operator(()ident(hint)operator(,) ident(k)operator([)integer(1)operator(..)integer(-1)operator(]) operator(<<) ident(k)operator(.)ident(first)operator(\))]
insert[insert(+)            keyword(else)]
insert[insert(+)              string<delimiter(')delimiter(')>]
insert[insert(+)            keyword(end)]
insert[insert(+)            keyword(if) ident(c) operator(==) symbol(:NO_HIGHLIGHT)]
insert[insert(+)              ident(h)operator([)ident(k)operator(.)ident(dup)operator(]) operator(=) string<delimiter(')content(<span%s>)delimiter(')> operator(%) operator([)ident(title)operator(])]
insert[insert(+)            keyword(else)]
insert[insert(+)              ident(h)operator([)ident(k)operator(.)ident(dup)operator(]) operator(=) string<delimiter(')content(<span%s class="%s">)delimiter(')> operator(%) operator([)ident(title)operator(,) ident(c)operator(])]
insert[insert(+)            keyword(end)]
           keyword(end)
         keyword(end)
 
       keyword(when) symbol(:style)
         instance_variable(@css_style) operator(=) constant(Hash)operator(.)ident(new) keyword(do) operator(|)ident(h)operator(,) ident(k)operator(|)
delete[delete(-)          keyword(if) ident(k)operator(.)ident(is_a?) constant(Array)]
insert[insert(+)          keyword(if) ident(k)operator(.)ident(is_a?) eyecatcher<operator(::)>constant(Array)]
             ident(styles) operator(=) ident(k)operator(.)ident(dup)
           keyword(else)
             ident(styles) operator(=) operator([)ident(k)operator(])
           keyword(end)
           ident(type) operator(=) ident(styles)operator(.)ident(first)
delete[delete(-)          ident(classes) operator(=) ident(styles)operator(.)ident(map) operator({) operator(|)ident(c)operator(|) constant(ClassOfKind)operator([)ident(c)operator(]) operator(})]
insert[insert(+)          ident(classes) operator(=) ident(styles)operator(.)ident(map) operator({) operator(|)ident(c)operator(|) eyecatcher<constant(Tokens)operator(::)>constant(ClassOfKind)operator([)ident(c)operator(]) operator(})]
           keyword(if) ident(classes)operator(.)ident(first) operator(==) symbol(:NO_HIGHLIGHT) keyword(and) keyword(not) ident(hint)
             ident(h)operator([)ident(k)operator(]) operator(=) predefined_constant(false)
           keyword(else)
delete[delete(-)            ident(styles)operator(.)ident(shift) keyword(if) eyecatcher<operator([)symbol(:delimiter)operator(,) symbol(:modifier)operator(,) symbol(:content)operator(,) symbol(:escape)operator(])>operator(.)ident(include?) ident(styles)operator(.)ident(first)]
insert[insert(+)            ident(styles)operator(.)ident(shift) keyword(if) eyecatcher<constant(TRANSPARENT_TOKEN_KINDS)>operator(.)ident(include?) ident(styles)operator(.)ident(first)]
             ident(title) operator(=) constant(HTML)operator(.)ident(token_path_to_hint) ident(hint)operator(,) ident(styles)
delete[delete(-)            ident(classes)operator(.)ident(delete) string<delimiter(')content(il)delimiter(')>]
             ident(style) operator(=) instance_variable(@css)operator([)operator(*)ident(classes)operator(])
             ident(h)operator([)ident(k)operator(]) operator(=)
               keyword(if) ident(style)
change[change(@@)plain( -198,7 +208,9 )change(@@)]
     keyword(def) method(finish) ident(options)
       ident(not_needed) operator(=) instance_variable(@opened)operator(.)ident(shift)
       instance_variable(@out) operator(<<) string<delimiter(')content(</span>)delimiter(')> operator(*) instance_variable(@opened)operator(.)ident(size)
delete[delete(-)      ident(warn) string<delimiter(')content(%d tokens still open: %p)delimiter(')> operator(%) operator([)instance_variable(@opened)operator(.)ident(size)operator(,) instance_variable(@opened)operator(]) keyword(unless) instance_variable(@opened)operator(.)ident(empty?)]
insert[insert(+)      keyword(unless) instance_variable(@opened)operator(.)ident(empty?)]
insert[insert(+)        ident(warn) string<delimiter(')content(%d tokens still open: %p)delimiter(')> operator(%) operator([)instance_variable(@opened)operator(.)ident(size)operator(,) instance_variable(@opened)operator(])]
insert[insert(+)      keyword(end)]
 
       instance_variable(@out)operator(.)ident(extend) constant(Output)
       instance_variable(@out)operator(.)ident(css) operator(=) instance_variable(@css)
change[change(@@)plain( -229,8 +241,9 )change(@@)]
           keyword(if) instance_variable(@opened)operator(.)ident(empty?)
             comment(# nothing to close)
           keyword(else)
delete[delete(-)            keyword(if) instance_variable(@opened)operator(.)ident(size) operator(==) integer(1) keyword(or) instance_variable(@opened)operator(.)ident(last) operator(!=) ident(type)]
delete[delete(-)              ident(raise) string<delimiter(')content(Malformed token stream: Trying to close a token (%p\) that is not open. Open are: %p.)delimiter(')> operator(%) operator([)ident(type)operator(,) instance_variable(@opened)operator([)integer(1)operator(..)integer(-1)operator(])operator(]) keyword(if) global_variable($DEBUG)]
insert[insert(+)            keyword(if) global_variable($DEBUG) keyword(and) operator(()instance_variable(@opened)operator(.)ident(size) operator(==) integer(1) keyword(or) instance_variable(@opened)operator(.)ident(last) operator(!=) ident(type)operator(\))]
insert[insert(+)              ident(raise) string<delimiter(')content(Malformed token stream: Trying to close a token (%p\) )content(\\)>]
insert[insert(+)string<content(                that is not open. Open are: %p.)delimiter(')> operator(%) operator([)ident(type)operator(,) instance_variable(@opened)operator([)integer(1)operator(..)integer(-1)operator(])operator(])]
             keyword(end)
             instance_variable(@out) operator(<<) string<delimiter(')content(</span>)delimiter(')>
             instance_variable(@opened)operator(.)ident(pop)
head[head(Index: )plain(lib/coderay/encoders/text.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay/encoders/text.rb)plain(	(revision 200\))]
head[head(+++ )filename(lib/coderay/encoders/text.rb)plain(	(revision 250\))]
change[change(@@)plain( -14,13 +14,12 )change(@@)]
 
   ident(protected)
     keyword(def) method(setup) ident(options)
delete[delete(-)      eyecatcher<keyword(super)>]
insert[insert(+)      eyecatcher<instance_variable(@out) operator(=) string<delimiter(')delimiter(')>>]
       instance_variable(@sep) operator(=) ident(options)operator([)symbol(:separator)operator(])
     keyword(end)
 
     keyword(def) method(token) ident(text)operator(,) ident(kind)
delete[delete(-)      keyword(return) keyword(unless) ident(text)operator(.)ident(respond_to?) symbol(:to_str)]
delete[delete(-)      instance_variable(@out) operator(<<) ident(text) operator(+) instance_variable(@sep)]
insert[insert(+)      instance_variable(@out) operator(<<) ident(text) operator(+) instance_variable(@sep) keyword(if) ident(text)operator(.)ident(is_a?) operator(::)constant(String)]
     keyword(end)
 
     keyword(def) method(finish) ident(options)
head[head(Index: )plain(lib/coderay/encoders/debug.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay/encoders/debug.rb)plain(	(revision 200\))]
head[head(+++ )filename(lib/coderay/encoders/debug.rb)plain(	(revision 250\))]
change[change(@@)plain( -19,19 +19,14 )change(@@)]
 
   ident(protected)
     keyword(def) method(text_token) ident(text)operator(,) ident(kind)
delete[delete(-)      instance_variable(@out) operator(<<)]
delete[delete(-)        keyword(if) ident(kind) operator(==) symbol(:space)]
delete[delete(-)          ident(text)]
delete[delete(-)        keyword(else)]
delete[delete(-)          ident(text) operator(=) ident(text)operator(.)ident(gsub)operator(()regexp<delimiter(/)content([\))char(\\\\)content(])delimiter(/)>operator(,) string<delimiter(')char(\\\\)char(\\\\)content(\\0)delimiter(')>operator(\))]
delete[delete(-)          string<delimiter(")inline<inline_delimiter(#{)ident(kind)inline_delimiter(})>content(()inline<inline_delimiter(#{)ident(text)inline_delimiter(})>content(\))delimiter(")>]
delete[delete(-)        keyword(end)]
insert[insert(+)      keyword(if) ident(kind) operator(==) symbol(:space)]
insert[insert(+)        ident(text)]
insert[insert(+)      keyword(else)]
insert[insert(+)        ident(text) operator(=) ident(text)operator(.)ident(gsub)operator(()regexp<delimiter(/)content([\))char(\\\\)content(])delimiter(/)>operator(,) string<delimiter(')char(\\\\)char(\\\\)content(\\0)delimiter(')>operator(\))  comment(# escape \) and \\)]
insert[insert(+)        string<delimiter(")inline<inline_delimiter(#{)ident(kind)inline_delimiter(})>content(()inline<inline_delimiter(#{)ident(text)inline_delimiter(})>content(\))delimiter(")>]
insert[insert(+)      keyword(end)]
     keyword(end)
 
delete[delete(-)    keyword(def) method(block_token) ident(action)operator(,) ident(kind)]
delete[delete(-)      instance_variable(@out) operator(<<) keyword(super)]
delete[delete(-)    keyword(end)]
delete[delete(-)]
     keyword(def) method(open_token) ident(kind)
       string<delimiter(")inline<inline_delimiter(#{)ident(kind)inline_delimiter(})>content(<)delimiter(")>
     keyword(end)
head[head(Index: )plain(lib/coderay/encoders/statistic.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay/encoders/statistic.rb)plain(	(revision 200\))]
head[head(+++ )filename(lib/coderay/encoders/statistic.rb)plain(	(revision 250\))]
change[change(@@)plain( -28,19 +28,15 )change(@@)]
       instance_variable(@type_stats)operator([)ident(kind)operator(])operator(.)ident(count) operator(+=) integer(1)
       instance_variable(@type_stats)operator([)ident(kind)operator(])operator(.)ident(size) operator(+=) ident(text)operator(.)ident(size)
       instance_variable(@type_stats)operator([)string<delimiter(')content(TOTAL)delimiter(')>operator(])operator(.)ident(size) operator(+=) ident(text)operator(.)ident(size)
insert[insert(+)      instance_variable(@type_stats)operator([)string<delimiter(')content(TOTAL)delimiter(')>operator(])operator(.)ident(count) operator(+=) integer(1)]
     keyword(end)
 
     comment(# TODO Hierarchy handling)
     keyword(def) method(block_token) ident(action)operator(,) ident(kind)
delete[delete(-)      eyecatcher<comment(#@content_type = kind)>]
insert[insert(+)      eyecatcher<instance_variable(@type_stats)operator([)string<delimiter(')content(TOTAL)delimiter(')>operator(])operator(.)ident(count) operator(+=) integer(1)>]
       instance_variable(@type_stats)operator([)string<delimiter(')content(open/close)delimiter(')>operator(])operator(.)ident(count) operator(+=) integer(1)
     keyword(end)
 
delete[delete(-)    keyword(def) method(token) ident(text)operator(,) ident(kind)]
delete[delete(-)      keyword(super)]
delete[delete(-)      instance_variable(@type_stats)operator([)string<delimiter(')content(TOTAL)delimiter(')>operator(])operator(.)ident(count) operator(+=) integer(1)]
delete[delete(-)    keyword(end)]
delete[delete(-)]
     constant(STATS) operator(=) string<delimiter(<<-STATS)>
string<content( )>
string<content( Code Statistics)>
head[head(Index: )plain(lib/coderay/encoders/_map.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay/encoders/_map.rb)plain(	(revision 200\))]
head[head(+++ )filename(lib/coderay/encoders/_map.rb)plain(	(revision 250\))]
change[change(@@)plain( -2,7 +2,8 )change(@@)]
 keyword(module) class(Encoders)
 
   ident(map) symbol(:stats) operator(=)operator(>) symbol(:statistic)operator(,)
delete[delete(-)    symbol(:plain) operator(=)operator(>) symbol(:text)]
insert[insert(+)    symbol(:plain) operator(=)operator(>) symbol(:text)operator(,)]
insert[insert(+)    symbol(:tex) operator(=)operator(>) symbol(:latex)]
 
 keyword(end)
 keyword(end)
head[head(Index: )plain(lib/coderay/helpers/filetype.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay/helpers/filetype.rb)plain(	(revision 200\))]
head[head(+++ )filename(lib/coderay/helpers/filetype.rb)plain(	(revision 250\))]
change[change(@@)plain( -1,180 +0,0 )change(@@)]
delete[delete(-)comment(# =FileType)]
delete[delete(-)comment(#)]
delete[delete(-)comment(# A simple filetype recognizer)]
delete[delete(-)comment(#)]
delete[delete(-)comment(# Author: murphy (mail to murphy cYcnus de\))]
delete[delete(-)comment(#)]
delete[delete(-)comment(# Version: 0.1 (2005.september.1\))]
delete[delete(-)comment(#)]
delete[delete(-)comment(# == Documentation)]
delete[delete(-)comment(#)]
delete[delete(-)comment(#  # determine the type of the given)]
delete[delete(-)comment(#   lang = FileType[ARGV.first])]
delete[delete(-)comment(#  )]
delete[delete(-)comment(#   # return :plaintext if the file type is unknown)]
delete[delete(-)comment(#   lang = FileType.fetch ARGV.first, :plaintext)]
delete[delete(-)comment(#  )]
delete[delete(-)comment(#   # try the shebang line, too)]
delete[delete(-)comment(#   lang = FileType.fetch ARGV.first, :plaintext, true)]
delete[delete(-)keyword(module) class(FileType)]
delete[delete(-)]
delete[delete(-)  constant(UnknownFileType) operator(=) constant(Class)operator(.)ident(new) constant(Exception)]
delete[delete(-)]
delete[delete(-)  keyword(class) operator(<<) class(self)]
delete[delete(-)]
delete[delete(-)    comment(# Try to determine the file type of the file.)]
delete[delete(-)    comment(#)]
delete[delete(-)    comment(# +filename+ is a relative or absolute path to a file.)]
delete[delete(-)    comment(#)]
delete[delete(-)    comment(# The file itself is only accessed when +read_shebang+ is set to true.)]
delete[delete(-)    comment(# That means you can get filetypes from files that don't exist.)]
delete[delete(-)    keyword(def) method([]) ident(filename)operator(,) ident(read_shebang) operator(=) predefined_constant(false)]
delete[delete(-)      ident(name) operator(=) constant(File)operator(.)ident(basename) ident(filename)]
delete[delete(-)      ident(ext) operator(=) constant(File)operator(.)ident(extname) ident(name)]
delete[delete(-)      ident(ext)operator(.)ident(sub!)operator(()regexp<delimiter(/)content(^)char(\\.)delimiter(/)>operator(,) string<delimiter(')delimiter(')>operator(\))  comment(# delete the leading dot)]
delete[delete(-)]
delete[delete(-)      ident(type) operator(=)]
delete[delete(-)        constant(TypeFromExt)operator([)ident(ext)operator(]) operator(||)]
delete[delete(-)        constant(TypeFromExt)operator([)ident(ext)operator(.)ident(downcase)operator(]) operator(||)]
delete[delete(-)        constant(TypeFromName)operator([)ident(name)operator(]) operator(||)]
delete[delete(-)        constant(TypeFromName)operator([)ident(name)operator(.)ident(downcase)operator(])]
delete[delete(-)      ident(type) operator(||=) ident(shebang)operator(()ident(filename)operator(\)) keyword(if) ident(read_shebang)]
delete[delete(-)]
delete[delete(-)      ident(type)]
delete[delete(-)    keyword(end)]
delete[delete(-)]
delete[delete(-)    keyword(def) method(shebang) ident(filename)]
delete[delete(-)      keyword(begin)]
delete[delete(-)        constant(File)operator(.)ident(open) ident(filename)operator(,) string<delimiter(')content(r)delimiter(')> keyword(do) operator(|)ident(f)operator(|)]
delete[delete(-)          ident(first_line) operator(=) ident(f)operator(.)ident(gets)]
delete[delete(-)          ident(first_line)operator([)constant(TypeFromShebang)operator(])]
delete[delete(-)        keyword(end)]
delete[delete(-)      keyword(rescue) constant(IOError)]
delete[delete(-)        predefined_constant(nil)]
delete[delete(-)      keyword(end)]
delete[delete(-)    keyword(end)]
delete[delete(-)]
delete[delete(-)    comment(# This works like Hash#fetch.)]
delete[delete(-)    comment(#)]
delete[delete(-)    comment(# If the filetype cannot be found, the +default+ value)]
delete[delete(-)    comment(# is returned.)]
delete[delete(-)    keyword(def) method(fetch) ident(filename)operator(,) ident(default) operator(=) predefined_constant(nil)operator(,) ident(read_shebang) operator(=) predefined_constant(false)]
delete[delete(-)      keyword(if) ident(default) keyword(and) ident(block_given?)]
delete[delete(-)        ident(warn) string<delimiter(')content(block supersedes default value argument)delimiter(')>]
delete[delete(-)      keyword(end)]
delete[delete(-)]
delete[delete(-)      keyword(unless) ident(type) operator(=) predefined_constant(self)operator([)ident(filename)operator(,) ident(read_shebang)operator(])]
delete[delete(-)        keyword(return) keyword(yield) keyword(if) ident(block_given?)]
delete[delete(-)        keyword(return) ident(default) keyword(if) ident(default)]
delete[delete(-)        ident(raise) constant(UnknownFileType)operator(,) string<delimiter(')content(Could not determine type of %p.)delimiter(')> operator(%) ident(filename)]
delete[delete(-)      keyword(end)]
delete[delete(-)      ident(type)]
delete[delete(-)    keyword(end)]
delete[delete(-)]
delete[delete(-)  keyword(end)]
delete[delete(-)]
delete[delete(-)  constant(TypeFromExt) operator(=) operator({)]
delete[delete(-)    string<delimiter(')content(rb)delimiter(')> operator(=)operator(>) symbol(:ruby)operator(,)]
delete[delete(-)    string<delimiter(')content(rbw)delimiter(')> operator(=)operator(>) symbol(:ruby)operator(,)]
delete[delete(-)    string<delimiter(')content(rake)delimiter(')> operator(=)operator(>) symbol(:ruby)operator(,)]
delete[delete(-)    string<delimiter(')content(cpp)delimiter(')> operator(=)operator(>) symbol(:c)operator(,)]
delete[delete(-)    string<delimiter(')content(c)delimiter(')> operator(=)operator(>) symbol(:c)operator(,)]
delete[delete(-)    string<delimiter(')content(h)delimiter(')> operator(=)operator(>) symbol(:c)operator(,)]
delete[delete(-)    string<delimiter(')content(xml)delimiter(')> operator(=)operator(>) symbol(:xml)operator(,)]
delete[delete(-)    string<delimiter(')content(htm)delimiter(')> operator(=)operator(>) symbol(:html)operator(,)]
delete[delete(-)    string<delimiter(')content(html)delimiter(')> operator(=)operator(>) symbol(:html)operator(,)]
delete[delete(-)    string<delimiter(')content(xhtml)delimiter(')> operator(=)operator(>) symbol(:xhtml)operator(,)]
delete[delete(-)    string<delimiter(')content(rhtml)delimiter(')> operator(=)operator(>) symbol(:rhtml)operator(,)]
delete[delete(-)    string<delimiter(')content(yaml)delimiter(')> operator(=)operator(>) symbol(:yaml)operator(,)]
delete[delete(-)    string<delimiter(')content(yml)delimiter(')> operator(=)operator(>) symbol(:yaml)operator(,)]
delete[delete(-)  operator(})]
delete[delete(-)]
delete[delete(-)  constant(TypeFromShebang) operator(=) regexp<delimiter(/)char(\\b)content((?:ruby|perl|python|sh\))char(\\b)delimiter(/)>]
delete[delete(-)]
delete[delete(-)  constant(TypeFromName) operator(=) operator({)]
delete[delete(-)    string<delimiter(')content(Rakefile)delimiter(')> operator(=)operator(>) symbol(:ruby)operator(,)]
delete[delete(-)    string<delimiter(')content(Rantfile)delimiter(')> operator(=)operator(>) symbol(:ruby)operator(,)]
delete[delete(-)  operator(})]
delete[delete(-)]
delete[delete(-)keyword(end)]
delete[delete(-)]
delete[delete(-)keyword(if) global_variable($0) operator(==) predefined_constant(__FILE__)]
delete[delete(-)  global_variable($VERBOSE) operator(=) predefined_constant(true)]
delete[delete(-)  ident(eval) predefined_constant(DATA)operator(.)ident(read)operator(,) predefined_constant(nil)operator(,) global_variable($0)operator(,) predefined_constant(__LINE__)operator(+)integer(4)]
delete[delete(-)keyword(end)]
delete[delete(-)]
delete[delete(-)comment(__END__)]
delete[delete(-)]
delete[delete(-)ident(require) string<delimiter(')content(test/unit)delimiter(')>]
delete[delete(-)]
delete[delete(-)keyword(class) class(TC_FileType) operator(<) constant(Test)operator(::)constant(Unit)operator(::)constant(TestCase)]
delete[delete(-)]
delete[delete(-)  keyword(def) method(test_fetch)]
delete[delete(-)    ident(assert_raise) constant(FileType)operator(::)constant(UnknownFileType) keyword(do)]
delete[delete(-)      constant(FileType)operator(.)ident(fetch) string<delimiter(')delimiter(')>]
delete[delete(-)    keyword(end)]
delete[delete(-)]
delete[delete(-)    ident(assert_throws) symbol(:not_found) keyword(do)]
delete[delete(-)      constant(FileType)operator(.)ident(fetch) string<delimiter(')content(.)delimiter(')> keyword(do)]
delete[delete(-)        ident(throw) symbol(:not_found)]
delete[delete(-)      keyword(end)]
delete[delete(-)    keyword(end)]
delete[delete(-)]
delete[delete(-)    ident(assert_equal) symbol(:default)operator(,) constant(FileType)operator(.)ident(fetch)operator(()string<delimiter(')content(c)delimiter(')>operator(,) symbol(:default)operator(\))]
delete[delete(-)]
delete[delete(-)    ident(stderr)operator(,) ident(fake_stderr) operator(=) global_variable($stderr)operator(,) constant(Object)operator(.)ident(new)]
delete[delete(-)    global_variable($err) operator(=) string<delimiter(')delimiter(')>]
delete[delete(-)    keyword(def) ident(fake_stderr)operator(.)method(write) ident(x)]
delete[delete(-)      global_variable($err) operator(<<) ident(x)]
delete[delete(-)    keyword(end)]
delete[delete(-)    global_variable($stderr) operator(=) ident(fake_stderr)]
delete[delete(-)    constant(FileType)operator(.)ident(fetch)operator(()string<delimiter(')content(c)delimiter(')>operator(,) symbol(:default)operator(\)) operator({) operator(})]
delete[delete(-)    ident(assert_equal) string<delimiter(")content(block supersedes default value argument)char(\\n)delimiter(")>operator(,) global_variable($err)]
delete[delete(-)    global_variable($stderr) operator(=) ident(stderr)]
delete[delete(-)  keyword(end)]
delete[delete(-)]
delete[delete(-)  keyword(def) method(test_ruby)]
delete[delete(-)    ident(assert_equal) symbol(:ruby)operator(,) constant(FileType)operator([)string<delimiter(')content(test.rb)delimiter(')>operator(])]
delete[delete(-)    ident(assert_equal) symbol(:ruby)operator(,) constant(FileType)operator([)string<delimiter(')content(C:)char(\\\\)content(Program Files)char(\\\\)content(x)char(\\\\)content(y)char(\\\\)content(c)char(\\\\)content(test.rbw)delimiter(')>operator(])]
delete[delete(-)    ident(assert_equal) symbol(:ruby)operator(,) constant(FileType)operator([)string<delimiter(')content(/usr/bin/something/Rakefile)delimiter(')>operator(])]
delete[delete(-)    ident(assert_equal) symbol(:ruby)operator(,) constant(FileType)operator([)string<delimiter(')content(~/myapp/gem/Rantfile)delimiter(')>operator(])]
delete[delete(-)    ident(assert_equal) symbol(:ruby)operator(,) constant(FileType)operator([)string<delimiter(')content(./lib/tasks)content(\\r)content(epository.rake)delimiter(')>operator(])]
delete[delete(-)    ident(assert_not_equal) symbol(:ruby)operator(,) constant(FileType)operator([)string<delimiter(')content(test_rb)delimiter(')>operator(])]
delete[delete(-)    ident(assert_not_equal) symbol(:ruby)operator(,) constant(FileType)operator([)string<delimiter(')content(Makefile)delimiter(')>operator(])]
delete[delete(-)    ident(assert_not_equal) symbol(:ruby)operator(,) constant(FileType)operator([)string<delimiter(')content(set.rb/set)delimiter(')>operator(])]
delete[delete(-)    ident(assert_not_equal) symbol(:ruby)operator(,) constant(FileType)operator([)string<delimiter(')content(~/projects/blabla/rb)delimiter(')>operator(])]
delete[delete(-)  keyword(end)]
delete[delete(-)]
delete[delete(-)  keyword(def) method(test_c)]
delete[delete(-)    ident(assert_equal) symbol(:c)operator(,) constant(FileType)operator([)string<delimiter(')content(test.c)delimiter(')>operator(])]
delete[delete(-)    ident(assert_equal) symbol(:c)operator(,) constant(FileType)operator([)string<delimiter(')content(C:)char(\\\\)content(Program Files)char(\\\\)content(x)char(\\\\)content(y)char(\\\\)content(c)char(\\\\)content(test.h)delimiter(')>operator(])]
delete[delete(-)    ident(assert_not_equal) symbol(:c)operator(,) constant(FileType)operator([)string<delimiter(')content(test_c)delimiter(')>operator(])]
delete[delete(-)    ident(assert_not_equal) symbol(:c)operator(,) constant(FileType)operator([)string<delimiter(')content(Makefile)delimiter(')>operator(])]
delete[delete(-)    ident(assert_not_equal) symbol(:c)operator(,) constant(FileType)operator([)string<delimiter(')content(set.h/set)delimiter(')>operator(])]
delete[delete(-)    ident(assert_not_equal) symbol(:c)operator(,) constant(FileType)operator([)string<delimiter(')content(~/projects/blabla/c)delimiter(')>operator(])]
delete[delete(-)  keyword(end)]
delete[delete(-)]
delete[delete(-)  keyword(def) method(test_html)]
delete[delete(-)    ident(assert_equal) symbol(:html)operator(,) constant(FileType)operator([)string<delimiter(')content(test.htm)delimiter(')>operator(])]
delete[delete(-)    ident(assert_equal) symbol(:xhtml)operator(,) constant(FileType)operator([)string<delimiter(')content(test.xhtml)delimiter(')>operator(])]
delete[delete(-)    ident(assert_equal) symbol(:xhtml)operator(,) constant(FileType)operator([)string<delimiter(')content(test.html.xhtml)delimiter(')>operator(])]
delete[delete(-)    ident(assert_equal) symbol(:rhtml)operator(,) constant(FileType)operator([)string<delimiter(')content(_form.rhtml)delimiter(')>operator(])]
delete[delete(-)  keyword(end)]
delete[delete(-)]
delete[delete(-)  keyword(def) method(test_yaml)]
delete[delete(-)    ident(assert_equal) symbol(:yaml)operator(,) constant(FileType)operator([)string<delimiter(')content(test.yml)delimiter(')>operator(])]
delete[delete(-)    ident(assert_equal) symbol(:yaml)operator(,) constant(FileType)operator([)string<delimiter(')content(test.yaml)delimiter(')>operator(])]
delete[delete(-)    ident(assert_equal) symbol(:yaml)operator(,) constant(FileType)operator([)string<delimiter(')content(my.html.yaml)delimiter(')>operator(])]
delete[delete(-)    ident(assert_not_equal) symbol(:yaml)operator(,) constant(FileType)operator([)string<delimiter(')content(YAML)delimiter(')>operator(])]
delete[delete(-)  keyword(end)]
delete[delete(-)]
delete[delete(-)  keyword(def) method(test_shebang)]
delete[delete(-)    ident(dir) operator(=) string<delimiter(')content(./test)delimiter(')>]
delete[delete(-)    keyword(if) constant(File)operator(.)ident(directory?) ident(dir)]
delete[delete(-)      constant(Dir)operator(.)ident(chdir) ident(dir) keyword(do)]
delete[delete(-)        ident(assert_equal) symbol(:c)operator(,) constant(FileType)operator([)string<delimiter(')content(test.c)delimiter(')>operator(])]
delete[delete(-)      keyword(end)]
delete[delete(-)    keyword(end)]
delete[delete(-)  keyword(end)]
delete[delete(-)]
delete[delete(-)keyword(end)]
head[head(Index: )plain(lib/coderay/helpers/plugin.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay/helpers/plugin.rb)plain(	(revision 200\))]
head[head(+++ )filename(lib/coderay/helpers/plugin.rb)plain(	(revision 250\))]
change[change(@@)plain( -1,3 +1,5 )change(@@)]
insert[insert(+)keyword(module) class(CodeRay)]
insert[insert(+)  ]
 comment(# = PluginHost)
 comment(#)
 comment(# $Id$)
change[change(@@)plain( -20,7 +22,7 )change(@@)]
 comment(#)
 comment(#    Generators[:fancy]  #-> FancyGenerator)
 comment(#    # or)
delete[delete(-)comment(#    )comment(require_plugin 'Generators/fancy')]
insert[insert(+)comment(#    )eyecatcher<comment(CodeRay.)>comment(require_plugin 'Generators/fancy')]
 keyword(module) class(PluginHost)
 
   comment(# Raised if Encoders::[] fails because:)
change[change(@@)plain( -310,17 +312,18 )change(@@)]
 
 keyword(end)
 
delete[delete(-)]
 comment(# Convenience method for plugin loading.)
 comment(# The syntax used is:)
 comment(#)
delete[delete(-)comment(#  )comment(require_plugin '<Host ID>/<Plugin ID>')]
insert[insert(+)comment(#  )eyecatcher<comment(CodeRay.)>comment(require_plugin '<Host ID>/<Plugin ID>')]
 comment(#)
 comment(# Returns the loaded plugin.)
delete[delete(-)keyword(def) method(require_plugin) ident(path)]
insert[insert(+)keyword(def) eyecatcher<predefined_constant(self)operator(.)>method(require_plugin) ident(path)]
   ident(host_id)operator(,) ident(plugin_id) operator(=) ident(path)operator(.)ident(split) string<delimiter(')content(/)delimiter(')>operator(,) integer(2)
   ident(host) operator(=) constant(PluginHost)operator(.)ident(host_by_id)operator(()ident(host_id)operator(\))
   ident(raise) constant(PluginHost)operator(::)constant(HostNotFound)operator(,)
     string<delimiter(")content(No host for )inline<inline_delimiter(#{)ident(host_id)operator(.)ident(inspect)inline_delimiter(})>content( found.)delimiter(")> keyword(unless) ident(host)
   ident(host)operator(.)ident(load) ident(plugin_id)
 keyword(end)
insert[insert(+)]
insert[insert(+)keyword(end)]
comment(\\ No newline at end of file)
head[head(Index: )plain(lib/coderay/helpers/file_type.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay/helpers/file_type.rb)plain(	(revision 0\))]
head[head(+++ )filename(lib/coderay/helpers/file_type.rb)plain(	(revision 250\))]
change[change(@@)plain( -0,0 +1,210 )change(@@)]
insert[insert(+)doctype(#!/usr/bin/env ruby)]
insert[insert(+)keyword(module) class(CodeRay)]
insert[insert(+)]
insert[insert(+)comment(# = FileType)]
insert[insert(+)comment(#)]
insert[insert(+)comment(# A simple filetype recognizer.)]
insert[insert(+)comment(#)]
insert[insert(+)comment(# Copyright (c\) 2006 by murphy (Kornelius Kalnbach\) <murphy rubychan de>)]
insert[insert(+)comment(#)]
insert[insert(+)comment(# License:: LGPL / ask the author)]
insert[insert(+)comment(# Version:: 0.1 (2005-09-01\))]
insert[insert(+)comment(#)]
insert[insert(+)comment(# == Documentation)]
insert[insert(+)comment(#)]
insert[insert(+)comment(#  # determine the type of the given)]
insert[insert(+)comment(#   lang = FileType[ARGV.first])]
insert[insert(+)comment(#  )]
insert[insert(+)comment(#   # return :plaintext if the file type is unknown)]
insert[insert(+)comment(#   lang = FileType.fetch ARGV.first, :plaintext)]
insert[insert(+)comment(#  )]
insert[insert(+)comment(#   # try the shebang line, too)]
insert[insert(+)comment(#   lang = FileType.fetch ARGV.first, :plaintext, true)]
insert[insert(+)keyword(module) class(FileType)]
insert[insert(+)]
insert[insert(+)  constant(UnknownFileType) operator(=) constant(Class)operator(.)ident(new) constant(Exception)]
insert[insert(+)]
insert[insert(+)  keyword(class) operator(<<) class(self)]
insert[insert(+)]
insert[insert(+)    comment(# Try to determine the file type of the file.)]
insert[insert(+)    comment(#)]
insert[insert(+)    comment(# +filename+ is a relative or absolute path to a file.)]
insert[insert(+)    comment(#)]
insert[insert(+)    comment(# The file itself is only accessed when +read_shebang+ is set to true.)]
insert[insert(+)    comment(# That means you can get filetypes from files that don't exist.)]
insert[insert(+)    keyword(def) method([]) ident(filename)operator(,) ident(read_shebang) operator(=) predefined_constant(false)]
insert[insert(+)      ident(name) operator(=) constant(File)operator(.)ident(basename) ident(filename)]
insert[insert(+)      ident(ext) operator(=) constant(File)operator(.)ident(extname)operator(()ident(name)operator(\))operator(.)ident(sub)operator(()regexp<delimiter(/)content(^)char(\\.)delimiter(/)>operator(,) string<delimiter(')delimiter(')>operator(\))  comment(# from last dot, delete the leading dot)]
insert[insert(+)      ident(ext2) operator(=) ident(filename)operator([)regexp<delimiter(/)char(\\.)content((.*\))delimiter(/)>operator(,) integer(1)operator(])  comment(# from first dot)]
insert[insert(+)]
insert[insert(+)      ident(type) operator(=)]
insert[insert(+)        constant(TypeFromExt)operator([)ident(ext)operator(.)ident(downcase)operator(]) operator(||)]
insert[insert(+)        operator(()constant(TypeFromExt)operator([)ident(ext2)operator(.)ident(downcase)operator(]) keyword(if) ident(ext2)operator(\)) operator(||)]
insert[insert(+)        constant(TypeFromName)operator([)ident(name)operator(]) operator(||)]
insert[insert(+)        constant(TypeFromName)operator([)ident(name)operator(.)ident(downcase)operator(])]
insert[insert(+)      ident(type) operator(||=) ident(shebang)operator(()ident(filename)operator(\)) keyword(if) ident(read_shebang)]
insert[insert(+)]
insert[insert(+)      ident(type)]
insert[insert(+)    keyword(end)]
insert[insert(+)]
insert[insert(+)    keyword(def) method(shebang) ident(filename)]
insert[insert(+)      keyword(begin)]
insert[insert(+)        constant(File)operator(.)ident(open) ident(filename)operator(,) string<delimiter(')content(r)delimiter(')> keyword(do) operator(|)ident(f)operator(|)]
insert[insert(+)          keyword(if) ident(first_line) operator(=) ident(f)operator(.)ident(gets)]
insert[insert(+)            keyword(if) ident(type) operator(=) ident(first_line)operator([)constant(TypeFromShebang)operator(])]
insert[insert(+)              ident(type)operator(.)ident(to_sym)]
insert[insert(+)            keyword(end)]
insert[insert(+)          keyword(end)]
insert[insert(+)        keyword(end)]
insert[insert(+)      keyword(rescue) constant(IOError)]
insert[insert(+)        predefined_constant(nil)]
insert[insert(+)      keyword(end)]
insert[insert(+)    keyword(end)]
insert[insert(+)]
insert[insert(+)    comment(# This works like Hash#fetch.)]
insert[insert(+)    comment(#)]
insert[insert(+)    comment(# If the filetype cannot be found, the +default+ value)]
insert[insert(+)    comment(# is returned.)]
insert[insert(+)    keyword(def) method(fetch) ident(filename)operator(,) ident(default) operator(=) predefined_constant(nil)operator(,) ident(read_shebang) operator(=) predefined_constant(false)]
insert[insert(+)      keyword(if) ident(default) keyword(and) ident(block_given?)]
insert[insert(+)        ident(warn) string<delimiter(')content(block supersedes default value argument)delimiter(')>]
insert[insert(+)      keyword(end)]
insert[insert(+)]
insert[insert(+)      keyword(unless) ident(type) operator(=) predefined_constant(self)operator([)ident(filename)operator(,) ident(read_shebang)operator(])]
insert[insert(+)        keyword(return) keyword(yield) keyword(if) ident(block_given?)]
insert[insert(+)        keyword(return) ident(default) keyword(if) ident(default)]
insert[insert(+)        ident(raise) constant(UnknownFileType)operator(,) string<delimiter(')content(Could not determine type of %p.)delimiter(')> operator(%) ident(filename)]
insert[insert(+)      keyword(end)]
insert[insert(+)      ident(type)]
insert[insert(+)    keyword(end)]
insert[insert(+)]
insert[insert(+)  keyword(end)]
insert[insert(+)]
insert[insert(+)  constant(TypeFromExt) operator(=) operator({)]
insert[insert(+)    string<delimiter(')content(rb)delimiter(')> operator(=)operator(>) symbol(:ruby)operator(,)]
insert[insert(+)    string<delimiter(')content(rbw)delimiter(')> operator(=)operator(>) symbol(:ruby)operator(,)]
insert[insert(+)    string<delimiter(')content(rake)delimiter(')> operator(=)operator(>) symbol(:ruby)operator(,)]
insert[insert(+)    string<delimiter(')content(mab)delimiter(')> operator(=)operator(>) symbol(:ruby)operator(,)]
insert[insert(+)    string<delimiter(')content(cpp)delimiter(')> operator(=)operator(>) symbol(:c)operator(,)]
insert[insert(+)    string<delimiter(')content(c)delimiter(')> operator(=)operator(>) symbol(:c)operator(,)]
insert[insert(+)    string<delimiter(')content(h)delimiter(')> operator(=)operator(>) symbol(:c)operator(,)]
insert[insert(+)    string<delimiter(')content(xml)delimiter(')> operator(=)operator(>) symbol(:xml)operator(,)]
insert[insert(+)    string<delimiter(')content(htm)delimiter(')> operator(=)operator(>) symbol(:html)operator(,)]
insert[insert(+)    string<delimiter(')content(html)delimiter(')> operator(=)operator(>) symbol(:html)operator(,)]
insert[insert(+)    string<delimiter(')content(xhtml)delimiter(')> operator(=)operator(>) symbol(:xhtml)operator(,)]
insert[insert(+)    string<delimiter(')content(raydebug)delimiter(')> operator(=)operator(>) symbol(:debug)operator(,)]
insert[insert(+)    string<delimiter(')content(rhtml)delimiter(')> operator(=)operator(>) symbol(:rhtml)operator(,)]
insert[insert(+)    string<delimiter(')content(html.erb)delimiter(')> operator(=)operator(>) symbol(:rhtml)operator(,)]
insert[insert(+)    string<delimiter(')content(ss)delimiter(')> operator(=)operator(>) symbol(:scheme)operator(,)]
insert[insert(+)    string<delimiter(')content(sch)delimiter(')> operator(=)operator(>) symbol(:scheme)operator(,)]
insert[insert(+)    string<delimiter(')content(yaml)delimiter(')> operator(=)operator(>) symbol(:yaml)operator(,)]
insert[insert(+)    string<delimiter(')content(yml)delimiter(')> operator(=)operator(>) symbol(:yaml)operator(,)]
insert[insert(+)  operator(})]
insert[insert(+)]
insert[insert(+)  constant(TypeFromShebang) operator(=) regexp<delimiter(/)char(\\b)content((?:ruby|perl|python|sh\))char(\\b)delimiter(/)>]
insert[insert(+)]
insert[insert(+)  constant(TypeFromName) operator(=) operator({)]
insert[insert(+)    string<delimiter(')content(Rakefile)delimiter(')> operator(=)operator(>) symbol(:ruby)operator(,)]
insert[insert(+)    string<delimiter(')content(Rantfile)delimiter(')> operator(=)operator(>) symbol(:ruby)operator(,)]
insert[insert(+)  operator(})]
insert[insert(+)]
insert[insert(+)keyword(end)]
insert[insert(+)]
insert[insert(+)keyword(end)]
insert[insert(+)]
insert[insert(+)keyword(if) global_variable($0) operator(==) predefined_constant(__FILE__)]
insert[insert(+)  global_variable($VERBOSE) operator(=) predefined_constant(true)]
insert[insert(+)  ident(eval) predefined_constant(DATA)operator(.)ident(read)operator(,) predefined_constant(nil)operator(,) global_variable($0)operator(,) predefined_constant(__LINE__)operator(+)integer(4)]
insert[insert(+)keyword(end)]
insert[insert(+)]
insert[insert(+)comment(__END__)]
insert[insert(+)ident(require) string<delimiter(')content(test/unit)delimiter(')>]
insert[insert(+)]
insert[insert(+)keyword(class) class(TC_FileType) operator(<) constant(Test)operator(::)constant(Unit)operator(::)constant(TestCase)]
insert[insert(+)  ]
insert[insert(+)  ident(include) constant(CodeRay)]
insert[insert(+)  ]
insert[insert(+)  keyword(def) method(test_fetch)]
insert[insert(+)    ident(assert_raise) constant(FileType)operator(::)constant(UnknownFileType) keyword(do)]
insert[insert(+)      constant(FileType)operator(.)ident(fetch) string<delimiter(')delimiter(')>]
insert[insert(+)    keyword(end)]
insert[insert(+)]
insert[insert(+)    ident(assert_throws) symbol(:not_found) keyword(do)]
insert[insert(+)      constant(FileType)operator(.)ident(fetch) string<delimiter(')content(.)delimiter(')> keyword(do)]
insert[insert(+)        ident(throw) symbol(:not_found)]
insert[insert(+)      keyword(end)]
insert[insert(+)    keyword(end)]
insert[insert(+)]
insert[insert(+)    ident(assert_equal) symbol(:default)operator(,) constant(FileType)operator(.)ident(fetch)operator(()string<delimiter(')content(c)delimiter(')>operator(,) symbol(:default)operator(\))]
insert[insert(+)]
insert[insert(+)    ident(stderr)operator(,) ident(fake_stderr) operator(=) global_variable($stderr)operator(,) constant(Object)operator(.)ident(new)]
insert[insert(+)    global_variable($err) operator(=) string<delimiter(')delimiter(')>]
insert[insert(+)    keyword(def) ident(fake_stderr)operator(.)method(write) ident(x)]
insert[insert(+)      global_variable($err) operator(<<) ident(x)]
insert[insert(+)    keyword(end)]
insert[insert(+)    global_variable($stderr) operator(=) ident(fake_stderr)]
insert[insert(+)    constant(FileType)operator(.)ident(fetch)operator(()string<delimiter(')content(c)delimiter(')>operator(,) symbol(:default)operator(\)) operator({) operator(})]
insert[insert(+)    ident(assert_equal) string<delimiter(")content(block supersedes default value argument)char(\\n)delimiter(")>operator(,) global_variable($err)]
insert[insert(+)    global_variable($stderr) operator(=) ident(stderr)]
insert[insert(+)  keyword(end)]
insert[insert(+)]
insert[insert(+)  keyword(def) method(test_ruby)]
insert[insert(+)    ident(assert_equal) symbol(:ruby)operator(,) constant(FileType)operator([)string<delimiter(')content(test.rb)delimiter(')>operator(])]
insert[insert(+)    ident(assert_equal) symbol(:ruby)operator(,) constant(FileType)operator([)string<delimiter(')content(C:)char(\\\\)content(Program Files)char(\\\\)content(x)char(\\\\)content(y)char(\\\\)content(c)char(\\\\)content(test.rbw)delimiter(')>operator(])]
insert[insert(+)    ident(assert_equal) symbol(:ruby)operator(,) constant(FileType)operator([)string<delimiter(')content(/usr/bin/something/Rakefile)delimiter(')>operator(])]
insert[insert(+)    ident(assert_equal) symbol(:ruby)operator(,) constant(FileType)operator([)string<delimiter(')content(~/myapp/gem/Rantfile)delimiter(')>operator(])]
insert[insert(+)    ident(assert_equal) symbol(:ruby)operator(,) constant(FileType)operator([)string<delimiter(')content(./lib/tasks)content(\\r)content(epository.rake)delimiter(')>operator(])]
insert[insert(+)    ident(assert_not_equal) symbol(:ruby)operator(,) constant(FileType)operator([)string<delimiter(')content(test_rb)delimiter(')>operator(])]
insert[insert(+)    ident(assert_not_equal) symbol(:ruby)operator(,) constant(FileType)operator([)string<delimiter(')content(Makefile)delimiter(')>operator(])]
insert[insert(+)    ident(assert_not_equal) symbol(:ruby)operator(,) constant(FileType)operator([)string<delimiter(')content(set.rb/set)delimiter(')>operator(])]
insert[insert(+)    ident(assert_not_equal) symbol(:ruby)operator(,) constant(FileType)operator([)string<delimiter(')content(~/projects/blabla/rb)delimiter(')>operator(])]
insert[insert(+)  keyword(end)]
insert[insert(+)]
insert[insert(+)  keyword(def) method(test_c)]
insert[insert(+)    ident(assert_equal) symbol(:c)operator(,) constant(FileType)operator([)string<delimiter(')content(test.c)delimiter(')>operator(])]
insert[insert(+)    ident(assert_equal) symbol(:c)operator(,) constant(FileType)operator([)string<delimiter(')content(C:)char(\\\\)content(Program Files)char(\\\\)content(x)char(\\\\)content(y)char(\\\\)content(c)char(\\\\)content(test.h)delimiter(')>operator(])]
insert[insert(+)    ident(assert_not_equal) symbol(:c)operator(,) constant(FileType)operator([)string<delimiter(')content(test_c)delimiter(')>operator(])]
insert[insert(+)    ident(assert_not_equal) symbol(:c)operator(,) constant(FileType)operator([)string<delimiter(')content(Makefile)delimiter(')>operator(])]
insert[insert(+)    ident(assert_not_equal) symbol(:c)operator(,) constant(FileType)operator([)string<delimiter(')content(set.h/set)delimiter(')>operator(])]
insert[insert(+)    ident(assert_not_equal) symbol(:c)operator(,) constant(FileType)operator([)string<delimiter(')content(~/projects/blabla/c)delimiter(')>operator(])]
insert[insert(+)  keyword(end)]
insert[insert(+)]
insert[insert(+)  keyword(def) method(test_html)]
insert[insert(+)    ident(assert_equal) symbol(:html)operator(,) constant(FileType)operator([)string<delimiter(')content(test.htm)delimiter(')>operator(])]
insert[insert(+)    ident(assert_equal) symbol(:xhtml)operator(,) constant(FileType)operator([)string<delimiter(')content(test.xhtml)delimiter(')>operator(])]
insert[insert(+)    ident(assert_equal) symbol(:xhtml)operator(,) constant(FileType)operator([)string<delimiter(')content(test.html.xhtml)delimiter(')>operator(])]
insert[insert(+)    ident(assert_equal) symbol(:rhtml)operator(,) constant(FileType)operator([)string<delimiter(')content(_form.rhtml)delimiter(')>operator(])]
insert[insert(+)    ident(assert_equal) symbol(:rhtml)operator(,) constant(FileType)operator([)string<delimiter(')content(_form.html.erb)delimiter(')>operator(])]
insert[insert(+)  keyword(end)]
insert[insert(+)]
insert[insert(+)  keyword(def) method(test_yaml)]
insert[insert(+)    ident(assert_equal) symbol(:yaml)operator(,) constant(FileType)operator([)string<delimiter(')content(test.yml)delimiter(')>operator(])]
insert[insert(+)    ident(assert_equal) symbol(:yaml)operator(,) constant(FileType)operator([)string<delimiter(')content(test.yaml)delimiter(')>operator(])]
insert[insert(+)    ident(assert_equal) symbol(:yaml)operator(,) constant(FileType)operator([)string<delimiter(')content(my.html.yaml)delimiter(')>operator(])]
insert[insert(+)    ident(assert_not_equal) symbol(:yaml)operator(,) constant(FileType)operator([)string<delimiter(')content(YAML)delimiter(')>operator(])]
insert[insert(+)  keyword(end)]
insert[insert(+)]
insert[insert(+)  keyword(def) method(test_no_shebang)]
insert[insert(+)    ident(dir) operator(=) string<delimiter(')content(./test)delimiter(')>]
insert[insert(+)    keyword(if) constant(File)operator(.)ident(directory?) ident(dir)]
insert[insert(+)      constant(Dir)operator(.)ident(chdir) ident(dir) keyword(do)]
insert[insert(+)        ident(assert_equal) symbol(:c)operator(,) constant(FileType)operator([)string<delimiter(')content(test.c)delimiter(')>operator(])]
insert[insert(+)      keyword(end)]
insert[insert(+)    keyword(end)]
insert[insert(+)  keyword(end)]
insert[insert(+)  ]
insert[insert(+)  keyword(def) method(test_shebang_empty_file)]
insert[insert(+)    ident(require) string<delimiter(')content(tmpdir)delimiter(')>]
insert[insert(+)    ident(tmpfile) operator(=) constant(File)operator(.)ident(join)operator(()constant(Dir)operator(.)ident(tmpdir)operator(,) string<delimiter(')content(bla)delimiter(')>operator(\))]
insert[insert(+)    constant(File)operator(.)ident(open)operator(()ident(tmpfile)operator(,) string<delimiter(')content(w)delimiter(')>operator(\)) operator({) operator(})  comment(# touch)]
insert[insert(+)    ident(assert_equal) predefined_constant(nil)operator(,) constant(FileType)operator([)ident(tmpfile)operator(])]
insert[insert(+)  keyword(end)]
insert[insert(+)  ]
insert[insert(+)  keyword(def) method(test_shebang)]
insert[insert(+)    ident(require) string<delimiter(')content(tmpdir)delimiter(')>]
insert[insert(+)    ident(tmpfile) operator(=) constant(File)operator(.)ident(join)operator(()constant(Dir)operator(.)ident(tmpdir)operator(,) string<delimiter(')content(bla)delimiter(')>operator(\))]
insert[insert(+)    constant(File)operator(.)ident(open)operator(()ident(tmpfile)operator(,) string<delimiter(')content(w)delimiter(')>operator(\)) operator({) operator(|)ident(f)operator(|) ident(f)operator(.)ident(puts) string<delimiter(')content(#!/usr/bin/env ruby)delimiter(')> operator(})]
insert[insert(+)    ident(assert_equal) symbol(:ruby)operator(,) constant(FileType)operator([)ident(tmpfile)operator(,) predefined_constant(true)operator(])]
insert[insert(+)  keyword(end)]
insert[insert(+)]
insert[insert(+)keyword(end)]

head[head(Property changes on: )plain(lib/coderay/helpers/file_type.rb)]
head[head(___________________________________________________________________)]
head[head(Added: )plain(svn:keywords)]
insert[insert(   +)plain( Id Rev)]

head[head(Index: )plain(lib/coderay/helpers/gzip_simple.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay/helpers/gzip_simple.rb)plain(	(revision 200\))]
head[head(+++ )filename(lib/coderay/helpers/gzip_simple.rb)plain(	(revision 250\))]
change[change(@@)plain( -46,6 +46,7 )change(@@)]
   keyword(end)
 keyword(end)
 
insert[insert(+)]
 comment(# String extensions to use the GZip module.)
 comment(#)
 comment(# The methods gzip and gunzip provide an even more simple)
head[head(Index: )plain(lib/coderay/helpers/word_list.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay/helpers/word_list.rb)plain(	(revision 200\))]
head[head(+++ )filename(lib/coderay/helpers/word_list.rb)plain(	(revision 250\))]
change[change(@@)plain( -1,15 +1,19 )change(@@)]
insert[insert(+)keyword(module) class(CodeRay)]
insert[insert(+)]
 comment(# = WordList)
insert[insert(+)comment(# )]
insert[insert(+)comment(# <b>A Hash subclass designed for mapping word lists to token types.</b>)]
insert[insert(+)comment(# )]
insert[insert(+)comment(# Copyright (c\) 2006 by murphy (Kornelius Kalnbach\) <murphy rubychan de>)]
 comment(#)
delete[delete(-)comment(# Copyright (c\) 2006 by murphy (Kornelius Kalnbach\) <murphy cYcnus de>)]
delete[delete(-)comment(#)]
 comment(# License:: LGPL / ask the author)
delete[delete(-)comment(# Version:: 1.)eyecatcher<comment(0 (2006-Feb-3)>comment(\))]
insert[insert(+)comment(# Version:: 1.)eyecatcher<comment(1 (2006-Oct-19)>comment(\))]
 comment(#)
 comment(# A WordList is a Hash with some additional features.)
 comment(# It is intended to be used for keyword recognition.)
 comment(#)
 comment(# WordList is highly optimized to be used in Scanners,)
delete[delete(-)comment(# typically to decide whether a given ident is a )eyecatcher<comment(keyword)>comment(.)]
insert[insert(+)comment(# typically to decide whether a given ident is a )eyecatcher<comment(special token)>comment(.)]
 comment(#)
 comment(# For case insensitive words use CaseIgnoringWordList.)
 comment(#)
change[change(@@)plain( -47,25 +51,30 )change(@@)]
 comment(#      ...)
 keyword(class) class(WordList) operator(<) constant(Hash)
 
delete[delete(-)  comment(# Create a WordList for the given +words+.)]
delete[delete(-)  comment(#)]
delete[delete(-)  comment(# This WordList responds to [] with +true+, if the word is)]
delete[delete(-)  comment(# in +words+, and with +false+ otherwise.)]
delete[delete(-)  keyword(def) predefined_constant(self)operator(.)method(for) ident(words)]
delete[delete(-)    ident(new)operator(.)ident(add) ident(words)]
delete[delete(-)  keyword(end)]
delete[delete(-)]
   comment(# Creates a new WordList with +default+ as default value.)
delete[delete(-)  keyword(def) method(initialize) ident(default) operator(=) predefined_constant(false)operator(,) operator(&)ident(block)]
delete[delete(-)    keyword(super) ident(default)operator(,) operator(&)ident(block)]
insert[insert(+)  comment(# )]
insert[insert(+)  comment(# You can activate +caching+ to store the results for every [] request.)]
insert[insert(+)  comment(# )]
insert[insert(+)  comment(# With caching, methods like +include?+ or +delete+ may no longer behave)]
insert[insert(+)  comment(# as you expect. Therefore, it is recommended to use the [] method only.)]
insert[insert(+)  keyword(def) method(initialize) ident(default) operator(=) predefined_constant(false)operator(,) ident(caching) operator(=) predefined_constant(false)operator(,) operator(&)ident(block)]
insert[insert(+)    keyword(if) ident(block)]
insert[insert(+)      ident(raise) constant(ArgumentError)operator(,) string<delimiter(')content(Can)char(\\')content(t combine block with caching.)delimiter(')> keyword(if) ident(caching)]
insert[insert(+)      keyword(super)operator(()operator(&)ident(block)operator(\))]
insert[insert(+)    keyword(else)]
insert[insert(+)      keyword(if) ident(caching)]
insert[insert(+)        keyword(super)operator(()operator(\)) keyword(do) operator(|)ident(h)operator(,) ident(k)operator(|)]
insert[insert(+)          ident(h)operator([)ident(k)operator(]) operator(=) ident(h)operator(.)ident(fetch) ident(k)operator(,) ident(default)]
insert[insert(+)        keyword(end)]
insert[insert(+)      keyword(else)]
insert[insert(+)        keyword(super) ident(default)]
insert[insert(+)      keyword(end)]
insert[insert(+)    keyword(end)]
   keyword(end)
 
delete[delete(-)  comment(# Checks if a word is included.)]
delete[delete(-)  keyword(def) method(include?) ident(word)]
delete[delete(-)    ident(has_key?) ident(word)]
delete[delete(-)  keyword(end)]
delete[delete(-)]
   comment(# Add words to the list and associate them with +kind+.)
insert[insert(+)  comment(# )]
insert[insert(+)  comment(# Returns +self+, so you can concat add calls.)]
   keyword(def) method(add) ident(words)operator(,) ident(kind) operator(=) predefined_constant(true)
     ident(words)operator(.)ident(each) keyword(do) operator(|)ident(word)operator(|)
       predefined_constant(self)operator([)ident(word)operator(]) operator(=) ident(kind)
change[change(@@)plain( -78,24 +87,30 )change(@@)]
 
 comment(# A CaseIgnoringWordList is like a WordList, only that)
 comment(# keys are compared case-insensitively.)
insert[insert(+)comment(# )]
insert[insert(+)comment(# Ignoring the text case is realized by sending the +downcase+ message to)]
insert[insert(+)comment(# all keys.)]
insert[insert(+)comment(# )]
insert[insert(+)comment(# Caching usually makes a CaseIgnoringWordList faster, but it has to be)]
insert[insert(+)comment(# activated explicitely.)]
 keyword(class) class(CaseIgnoringWordList) operator(<) constant(WordList)
 
delete[delete(-)  comment(# Creates a new WordList with +default+ as default value.)]
delete[delete(-)  comment(#)]
delete[delete(-)  comment(# Text case is ignored.)]
delete[delete(-)  keyword(def) method(initialize) ident(default) operator(=) predefined_constant(false)operator(,) operator(&)ident(block)]
delete[delete(-)    ident(block) operator(||=) ident(proc) keyword(do) operator(|)ident(h)operator(,) ident(k)operator(|)]
delete[delete(-)      ident(h)operator([)ident(k)operator(]) operator(=) ident(h)operator(.)ident(fetch) ident(k)operator(.)ident(downcase)operator(,) ident(default)]
insert[insert(+)  comment(# Creates a new case-insensitive WordList with +default+ as default value.)]
insert[insert(+)  comment(# )]
insert[insert(+)  comment(# You can activate caching to store the results for every [] request.)]
insert[insert(+)  keyword(def) method(initialize) ident(default) operator(=) predefined_constant(false)operator(,) ident(caching) operator(=) predefined_constant(false)]
insert[insert(+)    keyword(if) ident(caching)]
insert[insert(+)      keyword(super)operator(()ident(default)operator(,) predefined_constant(false)operator(\)) keyword(do) operator(|)ident(h)operator(,) ident(k)operator(|)]
insert[insert(+)        ident(h)operator([)ident(k)operator(]) operator(=) ident(h)operator(.)ident(fetch) ident(k)operator(.)ident(downcase)operator(,) ident(default)]
insert[insert(+)      keyword(end)]
insert[insert(+)    keyword(else)]
insert[insert(+)      keyword(def) predefined_constant(self)operator(.)method([]) ident(key)  comment(# :nodoc:)]
insert[insert(+)        keyword(super)operator(()ident(key)operator(.)ident(downcase)operator(\))]
insert[insert(+)      keyword(end)]
     keyword(end)
delete[delete(-)    keyword(super) ident(default)]
   keyword(end)
 
delete[delete(-)  comment(# Checks if a word is included.)]
delete[delete(-)  keyword(def) method(include?) ident(word)]
delete[delete(-)    ident(has_key?) ident(word)operator(.)ident(downcase)]
delete[delete(-)  keyword(end)]
delete[delete(-)]
delete[delete(-)  comment(# Add words to the list and associate them with +kind+.)]
insert[insert(+)  comment(# Add +words+ to the list and associate them with +kind+.)]
   keyword(def) method(add) ident(words)operator(,) ident(kind) operator(=) predefined_constant(true)
     ident(words)operator(.)ident(each) keyword(do) operator(|)ident(word)operator(|)
       predefined_constant(self)operator([)ident(word)operator(.)ident(downcase)operator(]) operator(=) ident(kind)
change[change(@@)plain( -104,3 +119,5 )change(@@)]
   keyword(end)
 
 keyword(end)
insert[insert(+)]
insert[insert(+)keyword(end)]
comment(\\ No newline at end of file)
head[head(Index: )plain(lib/coderay/styles/cycnus.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay/styles/cycnus.rb)plain(	(revision 200\))]
head[head(+++ )filename(lib/coderay/styles/cycnus.rb)plain(	(revision 250\))]
change[change(@@)plain( -42,12 +42,14 )change(@@)]
     constant(MAIN)
 
     constant(TOKEN_COLORS) operator(=) string<delimiter(<<-'TOKENS')>
insert[insert(+)string<content(.debug { color:white ! important; background:blue ! important; })>]
insert[insert(+)]
string<content( .af { color:#00C })>
string<content( .an { color:#007 })>
string<content( .av { color:#700 })>
string<content( .aw { color:#C00 })>
string<content( .bi { color:#509; font-weight:bold })>
delete[delete(-)string<content(.c  { color:#)>eyecatcher<string<content(888)>>string<content( })>]
insert[insert(+)string<content(.c  { color:#)>eyecatcher<string<content(666;)>>string<content( })>]
string<content( )>
string<content( .ch { color:#04D })>
string<content( .ch .k { color:#04D })>
change[change(@@)plain( -83,7 +85,7 )change(@@)]
 operator(.)ident(la) operator({) key(color)operator(:)comment(#970; font-weight:bold })
 operator(.)ident(lv) operator({) key(color)operator(:)comment(#963 })
 operator(.)ident(oc) operator({) key(color)operator(:)comment(#40E; font-weight:bold })
delete[delete(-)operator(.)ident(o)eyecatcher<ident(n)> operator({) key(color)operator(:)comment(#000; font-weight:bold })]
insert[insert(+)operator(.)ident(o)eyecatcher<ident(f)> operator({) key(color)operator(:)comment(#000; font-weight:bold })]
 operator(.)ident(op) operator({) operator(})
 operator(.)ident(pc) operator({) key(color)operator(:)comment(#038; font-weight:bold })
 operator(.)ident(pd) operator({) key(color)operator(:)comment(#369; font-weight:bold })
head[head(Index: )plain(lib/coderay/styles/murphy.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay/styles/murphy.rb)plain(	(revision 200\))]
head[head(+++ )filename(lib/coderay/styles/murphy.rb)plain(	(revision 250\))]
change[change(@@)plain( -47,7 +47,7 )change(@@)]
 operator(.)ident(av) operator({) key(color)operator(:)comment(#700; })
 operator(.)ident(aw) operator({) key(color)operator(:)comment(#C00; })
 operator(.)ident(bi) operator({) key(color)operator(:)comment(#509; font-weight:bold; })
delete[delete(-)operator(.)ident(c)  operator({) key(color)operator(:)comment(#)eyecatcher<comment(666)>comment(; })]
insert[insert(+)operator(.)ident(c)  operator({) key(color)operator(:)comment(#)eyecatcher<comment(555; background-color: black)>comment(; })]
 
 operator(.)ident(ch) operator({) key(color)operator(:)comment(#88F; })
 operator(.)ident(ch) operator(.)ident(k) operator({) key(color)operator(:)comment(#04D; })
change[change(@@)plain( -77,7 +77,7 )change(@@)]
 operator(.)ident(la) operator({) key(color)operator(:)comment(#970; font-weight:bold; })
 operator(.)ident(lv) operator({) key(color)operator(:)comment(#963; })
 operator(.)ident(oc) operator({) key(color)operator(:)comment(#40E; font-weight:bold; })
delete[delete(-)operator(.)ident(o)eyecatcher<ident(n)> operator({) key(color)operator(:)comment(#000; font-weight:bold; })]
insert[insert(+)operator(.)ident(o)eyecatcher<ident(f)> operator({) key(color)operator(:)comment(#000; font-weight:bold; })]
 operator(.)ident(op) operator({) operator(})
 operator(.)ident(pc) operator({) key(color)operator(:)comment(#08f; font-weight:bold; })
 operator(.)ident(pd) operator({) key(color)operator(:)comment(#369; font-weight:bold; })
head[head(Index: )plain(lib/coderay/tokens.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay/tokens.rb)plain(	(revision 200\))]
head[head(+++ )filename(lib/coderay/tokens.rb)plain(	(revision 250\))]
change[change(@@)plain( -115,7 +115,7 )change(@@)]
     comment(#   tokens.each_text_token { |text, kind| text.replace html_escape(text\) })
     keyword(def) method(each_text_token)
       ident(each) keyword(do) operator(|)ident(text)operator(,) ident(kind)operator(|)
delete[delete(-)        keyword(next) keyword(unless) ident(text)operator(.)eyecatcher<ident(respond_to?) symbol(:to_str)>]
insert[insert(+)        keyword(next) keyword(unless) ident(text)operator(.)eyecatcher<ident(is_a?) operator(::)constant(String)>]
         keyword(yield) ident(text)operator(,) ident(kind)
       keyword(end)
     keyword(end)
change[change(@@)plain( -252,7 +252,7 )change(@@)]
     comment(#)
     comment(# You can configure the level of compression,)
     comment(# but the default value 7 should be what you want)
delete[delete(-)    comment(# in most cases as it is a good compr)eyecatcher<comment(i)>comment(mise between)]
insert[insert(+)    comment(# in most cases as it is a good compr)eyecatcher<comment(o)>comment(mise between)]
     comment(# speed and compression rate.)
     comment(#)
     comment(# See GZip module.)
change[change(@@)plain( -267,9 +267,20 )change(@@)]
     comment(# Should be equal to the input size before)
     comment(# scanning.)
     keyword(def) method(text_size)
delete[delete(-)      ident(map) operator({) operator(|)ident(t)operator(,) ident(k)operator(|) ident(t) operator(})operator(.)ident(join)operator(.)ident(size)]
insert[insert(+)      ident(size) operator(=) integer(0)]
insert[insert(+)      ident(each_text_token) keyword(do) operator(|)ident(t)operator(,) ident(k)operator(|)]
insert[insert(+)        ident(size) operator(+) ident(t)operator(.)ident(size)]
insert[insert(+)      keyword(end)]
insert[insert(+)      ident(size)]
     keyword(end)
 
insert[insert(+)    comment(# The total size of the tokens.)]
insert[insert(+)    comment(# Should be equal to the input size before)]
insert[insert(+)    comment(# scanning.)]
insert[insert(+)    keyword(def) method(text)]
insert[insert(+)      ident(map) operator({) operator(|)ident(t)operator(,) ident(k)operator(|) ident(t) keyword(if) ident(t)operator(.)ident(is_a?) operator(::)constant(String) operator(})operator(.)ident(join)]
insert[insert(+)    keyword(end)]
insert[insert(+)]
     comment(# Include this module to give an object an #undump)
     comment(# method.)
     comment(#)
change[change(@@)plain( -342,7 +353,7 )change(@@)]
     comment(#)
     comment(# Returns self.)
     keyword(def) method(<<) ident(token)
delete[delete(-)      instance_variable(@callback)operator(.)ident(call)eyecatcher< ident(token)>]
insert[insert(+)      instance_variable(@callback)operator(.)ident(call)eyecatcher<operator(()operator(*)ident(token)operator(\))>]
       instance_variable(@size) operator(+=) integer(1)
       predefined_constant(self)
     keyword(end)
change[change(@@)plain( -365,4 +376,8 )change(@@)]
 
   keyword(end)
 
insert[insert(+)  ]
insert[insert(+)  comment(# Token name abbreviations)]
insert[insert(+)  ident(require) string<delimiter(')content(coderay/token_classes)delimiter(')>]
insert[insert(+)]
 keyword(end)
head[head(Index: )plain(lib/coderay/duo.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay/duo.rb)plain(	(revision 200\))]
head[head(+++ )filename(lib/coderay/duo.rb)plain(	(revision 250\))]
change[change(@@)plain( -4,26 +4,84 )change(@@)]
   comment(#)
   comment(# $Id: scanner.rb 123 2006-03-21 14:46:34Z murphy $)
   comment(#)
delete[delete(-)  comment(# TODO: Doc.)]
insert[insert(+)  comment(# A Duo is a convenient way to use CodeRay. You just create a Duo,)]
insert[insert(+)  comment(# giving it a lang (language of the input code\) and a format (desired)]
insert[insert(+)  comment(# output format\), and call Duo#highlight with the code.)]
insert[insert(+)  comment(# )]
insert[insert(+)  comment(# Duo makes it easy to re-use both scanner and encoder for a repetitive)]
insert[insert(+)  comment(# task. It also provides a very easy interface syntax:)]
insert[insert(+)  comment(# )]
insert[insert(+)  comment(#   require 'coderay')]
insert[insert(+)  comment(#   CodeRay::Duo[:python, :div].highlight 'import this')]
insert[insert(+)  comment(# )]
insert[insert(+)  comment(# Until you want to do uncommon things with CodeRay, I recommend to use)]
insert[insert(+)  comment(# this method, since it takes care of everything.)]
   keyword(class) class(Duo)
 
delete[delete(-)    ident(attr_accessor) symbol(:scanner)operator(,) symbol(:encoder)]
delete[delete(-)]
delete[delete(-)    keyword(def) method(initialize) ident(lang)operator(,) ident(format)operator(,) ident(options) operator(=) operator({)operator(})]
delete[delete(-)      instance_variable(@scanner) operator(=) constant(CodeRay)operator(.)ident(scanner) ident(lang)operator(,) constant(CodeRay)operator(.)ident(get_scanner_options)operator(()ident(options)operator(\))]
delete[delete(-)      instance_variable(@encoder) operator(=) constant(CodeRay)operator(.)ident(encoder) ident(format)operator(,) ident(options)]
insert[insert(+)    ident(attr_accessor) symbol(:lang)operator(,) symbol(:format)operator(,) symbol(:options)]
insert[insert(+)    ]
insert[insert(+)    comment(# Create a new Duo, holding a lang and a format to highlight code.)]
insert[insert(+)    comment(# )]
insert[insert(+)    comment(# simple:)]
insert[insert(+)    comment(#   CodeRay::Duo[:ruby, :page].highlight 'bla 42')]
insert[insert(+)    comment(# )]
insert[insert(+)    comment(# streaming:)]
insert[insert(+)    comment(#   CodeRay::Duo[:ruby, :page].highlight 'bar 23', :stream => true)]
insert[insert(+)    comment(# )]
insert[insert(+)    comment(# with options:)]
insert[insert(+)    comment(#   CodeRay::Duo[:ruby, :html, :hint => :debug].highlight '????::??')]
insert[insert(+)    comment(# )]
insert[insert(+)    comment(# alternative syntax without options:)]
insert[insert(+)    comment(#   CodeRay::Duo[:ruby => :statistic].encode 'class << self; end')]
insert[insert(+)    comment(# )]
insert[insert(+)    comment(# alternative syntax with options:)]
insert[insert(+)    comment(#   CodeRay::Duo[{ :ruby => :statistic }, :do => :something].encode 'abc')]
insert[insert(+)    comment(# )]
insert[insert(+)    comment(# The options are forwarded to scanner and encoder)]
insert[insert(+)    comment(# (see CodeRay.get_scanner_options\).)]
insert[insert(+)    keyword(def) method(initialize) ident(lang) operator(=) predefined_constant(nil)operator(,) ident(format) operator(=) predefined_constant(nil)operator(,) ident(options) operator(=) operator({)operator(})]
insert[insert(+)      keyword(if) ident(format) operator(==) predefined_constant(nil) keyword(and) ident(lang)operator(.)ident(is_a?) constant(Hash) keyword(and) ident(lang)operator(.)ident(size) operator(==) integer(1)]
insert[insert(+)        instance_variable(@lang) operator(=) ident(lang)operator(.)ident(keys)operator(.)ident(first)]
insert[insert(+)        instance_variable(@format) operator(=) ident(lang)operator([)instance_variable(@lang)operator(])]
insert[insert(+)      keyword(else)]
insert[insert(+)        instance_variable(@lang) operator(=) ident(lang)]
insert[insert(+)        instance_variable(@format) operator(=) ident(format)]
insert[insert(+)      keyword(end)]
insert[insert(+)      instance_variable(@options) operator(=) ident(options)]
     keyword(end)
 
     keyword(class) operator(<<) class(self)
insert[insert(+)      comment(# To allow calls like Duo[:ruby, :html].highlight.)]
       keyword(alias) method([]) method(new)
     keyword(end)
 
delete[delete(-)    eyecatcher<keyword(def) method(encode) ident(code)>]
delete[delete(-)    eyecatcher<  instance_variable(@scanner)operator(.)ident(string) operator(=) ident(code)>]
delete[delete(-)      instance_variable(@)eyecatcher<instance_variable(encoder)operator(.)ident(encode_tokens)operator(()ident(scanner)operator(.)ident(tokenize)>operator(\))]
insert[insert(+)    eyecatcher<comment(# The scanner of the duo. Only created once.)>]
insert[insert(+)    eyecatcher<keyword(def) method(scanner)>]
insert[insert(+)      instance_variable(@)eyecatcher<instance_variable(scanner) operator(||=) constant(CodeRay)operator(.)ident(scanner) instance_variable(@lang)operator(,) constant(CodeRay)operator(.)ident(get_scanner_options)operator(()instance_variable(@options)>operator(\))]
     keyword(end)
insert[insert(+)    ]
insert[insert(+)    comment(# The encoder of the duo. Only created once.)]
insert[insert(+)    keyword(def) method(encoder)]
insert[insert(+)      instance_variable(@encoder) operator(||=) constant(CodeRay)operator(.)ident(encoder) instance_variable(@format)operator(,) instance_variable(@options)]
insert[insert(+)    keyword(end)]
insert[insert(+)    ]
insert[insert(+)    comment(# Tokenize and highlight the code using +scanner+ and +encoder+.)]
insert[insert(+)    comment(#)]
insert[insert(+)    comment(# If the :stream option is set, the Duo will go into streaming mode,)]
insert[insert(+)    comment(# saving memory for the cost of time.)]
insert[insert(+)    keyword(def) method(encode) ident(code)operator(,) ident(options) operator(=) operator({) symbol(:stream) operator(=)operator(>) predefined_constant(false) operator(})]
insert[insert(+)      ident(stream) operator(=) ident(options)operator(.)ident(delete) symbol(:stream)]
insert[insert(+)      ident(options) operator(=) instance_variable(@options)operator(.)ident(merge) ident(options)]
insert[insert(+)      keyword(if) ident(stream)]
insert[insert(+)        ident(encoder)operator(.)ident(encode_stream)operator(()ident(code)operator(,) instance_variable(@lang)operator(,) ident(options)operator(\))]
insert[insert(+)      keyword(else)]
insert[insert(+)        ident(scanner)operator(.)ident(code) operator(=) ident(code)]
insert[insert(+)        ident(encoder)operator(.)ident(encode_tokens)operator(()ident(scanner)operator(.)ident(tokenize)operator(,) ident(options)operator(\))]
insert[insert(+)      keyword(end)]
insert[insert(+)    keyword(end)]
     keyword(alias) method(highlight) method(encode)
 
   keyword(end)
 
 keyword(end)
insert[insert(+)]
head[head(Index: )plain(lib/coderay/scanner.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay/scanner.rb)plain(	(revision 200\))]
head[head(+++ )filename(lib/coderay/scanner.rb)plain(	(revision 250\))]
change[change(@@)plain( -66,8 +66,18 )change(@@)]
         keyword(end)
 
         keyword(def) method(normify) ident(code)
delete[delete(-)          ident(code) operator(=) ident(code)operator(.)ident(to_s)operator(.)ident(to_unix)]
insert[insert(+)          ident(code) operator(=) ident(code)operator(.)ident(to_s)]
insert[insert(+)          ident(code)operator(.)ident(force_encoding) string<delimiter(')content(binary)delimiter(')> keyword(if) ident(code)operator(.)ident(respond_to?) symbol(:force_encoding)]
insert[insert(+)          ident(code)operator(.)ident(to_unix)]
         keyword(end)
insert[insert(+)        ]
insert[insert(+)        keyword(def) method(file_extension) ident(extension) operator(=) predefined_constant(nil)]
insert[insert(+)          keyword(if) ident(extension)]
insert[insert(+)            instance_variable(@file_extension) operator(=) ident(extension)operator(.)ident(to_s)]
insert[insert(+)          keyword(else)]
insert[insert(+)            instance_variable(@file_extension) operator(||=) ident(plugin_id)operator(.)ident(to_s)]
insert[insert(+)          keyword(end)]
insert[insert(+)        keyword(end)        ]
 
       keyword(end)
 
change[change(@@)plain( -117,9 +127,6 )change(@@)]
         ident(setup)
       keyword(end)
 
delete[delete(-)      comment(# More mnemonic accessor name for the input string.)]
delete[delete(-)      keyword(alias) method(code) method(string)]
delete[delete(-)]
       keyword(def) method(reset)
         keyword(super)
         ident(reset_instance)
change[change(@@)plain( -131,6 +138,10 )change(@@)]
         ident(reset_instance)
       keyword(end)
 
insert[insert(+)      comment(# More mnemonic accessor name for the input string.)]
insert[insert(+)      keyword(alias) method(code) method(string)]
insert[insert(+)      keyword(alias) method(code=) method(string=)]
insert[insert(+)]
       comment(# Scans the code and returns all tokens in a Tokens object.)
       keyword(def) method(tokenize) ident(new_string)operator(=)predefined_constant(nil)operator(,) ident(options) operator(=) operator({)operator(})
         ident(options) operator(=) instance_variable(@options)operator(.)ident(merge)operator(()ident(options)operator(\))
change[change(@@)plain( -148,6 +159,11 )change(@@)]
       keyword(def) method(tokens)
         instance_variable(@cached_tokens) operator(||=) ident(tokenize)
       keyword(end)
insert[insert(+)      ]
insert[insert(+)      comment(# Whether the scanner is in streaming mode.)]
insert[insert(+)      keyword(def) method(streaming?)]
insert[insert(+)        operator(!)operator(!)instance_variable(@options)operator([)symbol(:stream)operator(])]
insert[insert(+)      keyword(end)]
 
       comment(# Traverses the tokens.)
       keyword(def) method(each) operator(&)ident(block)
change[change(@@)plain( -195,7 +211,7 )change(@@)]
         ident(raise) constant(ScanError)operator(,) string<delimiter(<<-EOE)> operator(%) operator([)
string<content( )>
string<content( )>
delete[delete(-)string<content(***ERROR in %s: %s)>]
insert[insert(+)string<content(***ERROR in %s: %s)>eyecatcher<string<content( (after %d tokens\))>>]
string<content( )>
string<content( tokens:)>
string<content( %s)>
change[change(@@)plain( -211,13 +227,14 )change(@@)]
 operator(**)operator(*)constant(ERROR)operator(**)operator(*)
 
         constant(EOE)
delete[delete(-)        constant(File)operator(.)ident(basename)operator(()ident(caller)operator([)integer(0)operator(])operator(\))operator(,)]
delete[delete(-)        ident(msg)operator(,)]
delete[delete(-)        ident(tokens)operator(.)ident(last)operator(()integer(10)operator(\))operator(.)ident(map) operator({) operator(|)ident(t)operator(|) ident(t)operator(.)ident(inspect) operator(})operator(.)ident(join)operator(()string<delimiter(")char(\\n)delimiter(")>operator(\))operator(,)]
delete[delete(-)        ident(line)operator(,) ident(pos)operator(,)]
delete[delete(-)        ident(matched)operator(,) ident(state)operator(,) ident(bol?)operator(,) ident(eos?)operator(,)]
delete[delete(-)        ident(string)operator([)ident(pos)operator(-)ident(ambit)operator(,)ident(ambit)operator(])operator(,)]
delete[delete(-)        ident(string)operator([)ident(pos)operator(,)ident(ambit)operator(])operator(,)]
insert[insert(+)          constant(File)operator(.)ident(basename)operator(()ident(caller)operator([)integer(0)operator(])operator(\))operator(,)]
insert[insert(+)          ident(msg)operator(,)]
insert[insert(+)          ident(tokens)operator(.)ident(size)operator(,)]
insert[insert(+)          ident(tokens)operator(.)ident(last)operator(()integer(10)operator(\))operator(.)ident(map) operator({) operator(|)ident(t)operator(|) ident(t)operator(.)ident(inspect) operator(})operator(.)ident(join)operator(()string<delimiter(")char(\\n)delimiter(")>operator(\))operator(,)]
insert[insert(+)          ident(line)operator(,) ident(pos)operator(,)]
insert[insert(+)          ident(matched)operator(,) ident(state)operator(,) ident(bol?)operator(,) ident(eos?)operator(,)]
insert[insert(+)          ident(string)operator([)ident(pos)operator(-)ident(ambit)operator(,)ident(ambit)operator(])operator(,)]
insert[insert(+)          ident(string)operator([)ident(pos)operator(,)ident(ambit)operator(])operator(,)]
         operator(])
       keyword(end)
 
head[head(Index: )plain(lib/coderay/for_redcloth.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay/for_redcloth.rb)plain(	(revision 0\))]
head[head(+++ )filename(lib/coderay/for_redcloth.rb)plain(	(revision 250\))]
change[change(@@)plain( -0,0 +1,72 )change(@@)]
insert[insert(+)keyword(module) class(CodeRay)  comment(# :nodoc:)]
insert[insert(+)  ]
insert[insert(+)  comment(# A little hack to enable CodeRay highlighting in RedCloth.)]
insert[insert(+)  comment(# )]
insert[insert(+)  comment(# Usage:)]
insert[insert(+)  comment(#  require 'coderay')]
insert[insert(+)  comment(#  require 'coderay/for_redcloth')]
insert[insert(+)  comment(#  RedCloth.new('@[ruby]puts "Hello, World!"@'\).to_html)]
insert[insert(+)  comment(# )]
insert[insert(+)  comment(# Make sure you have RedCloth 4.0.3 activated, for example by calling)]
insert[insert(+)  comment(#  require 'rubygems')]
insert[insert(+)  comment(# before RedCloth is loaded and before calling CodeRay.for_redcloth.)]
insert[insert(+)  keyword(module) class(ForRedCloth)]
insert[insert(+)    ]
insert[insert(+)    keyword(def) predefined_constant(self)operator(.)method(install)]
insert[insert(+)      ident(gem) string<delimiter(')content(RedCloth)delimiter(')>operator(,) string<delimiter(')content(>= 4.0.3)delimiter(')> keyword(rescue) predefined_constant(nil)]
insert[insert(+)      ident(require) string<delimiter(')content(redcloth)delimiter(')>]
insert[insert(+)      ident(raise) string<delimiter(')content(CodeRay.for_redcloth needs RedCloth 4.0.3 or later.)delimiter(')> keyword(unless) constant(RedCloth)operator(::)constant(VERSION)operator(.)ident(to_s) operator(>)operator(=) string<delimiter(')content(4.0.3)delimiter(')>]
insert[insert(+)      constant(RedCloth)operator(::)constant(TextileDoc)operator(.)ident(send) symbol(:include)operator(,) constant(ForRedCloth)operator(::)constant(TextileDoc)]
insert[insert(+)      constant(RedCloth)operator(::)constant(Formatters)operator(::)constant(HTML)operator(.)ident(module_eval) keyword(do)]
insert[insert(+)        keyword(def) method(unescape)operator(()ident(html)operator(\))]
insert[insert(+)          ident(replacements) operator(=) operator({)]
insert[insert(+)            string<delimiter(')content(&amp;)delimiter(')> operator(=)operator(>) string<delimiter(')content(&)delimiter(')>operator(,)]
insert[insert(+)            string<delimiter(')content(&quot;)delimiter(')> operator(=)operator(>) string<delimiter(')content(")delimiter(')>operator(,)]
insert[insert(+)            string<delimiter(')content(&gt;)delimiter(')> operator(=)operator(>) string<delimiter(')content(>)delimiter(')>operator(,)]
insert[insert(+)            string<delimiter(')content(&lt;)delimiter(')> operator(=)operator(>) string<delimiter(')content(<)delimiter(')>operator(,)]
insert[insert(+)          operator(})]
insert[insert(+)          ident(html)operator(.)ident(gsub)operator(()regexp<delimiter(/)content(&(?:amp|quot|[gl]t\);)delimiter(/)>operator(\)) operator({) operator(|)ident(entity)operator(|) ident(replacements)operator([)ident(entity)operator(]) operator(})]
insert[insert(+)        keyword(end)]
insert[insert(+)        ident(undef_method) symbol(:code)operator(,) symbol(:bc_open)operator(,) symbol(:bc_close)operator(,) symbol(:escape_pre)]
insert[insert(+)        keyword(def) method(code)operator(()ident(opts)operator(\))  comment(# :nodoc:)]
insert[insert(+)          ident(opts)operator([)symbol(:block)operator(]) operator(=) predefined_constant(true)]
insert[insert(+)          keyword(if) ident(opts)operator([)symbol(:lang)operator(]) operator(&&) operator(!)ident(filter_coderay)]
insert[insert(+)            ident(require) string<delimiter(')content(coderay)delimiter(')>]
insert[insert(+)            instance_variable(@in_bc) operator(||=) predefined_constant(nil)]
insert[insert(+)            ident(format) operator(=) instance_variable(@in_bc) operator(?) symbol(:div) operator(:) symbol(:span)]
insert[insert(+)            ident(highlighted_code) operator(=) constant(CodeRay)operator(.)ident(encode) ident(opts)operator([)symbol(:text)operator(])operator(,) ident(opts)operator([)symbol(:lang)operator(])operator(,) ident(format)operator(,) symbol(:stream) operator(=)operator(>) predefined_constant(true)]
insert[insert(+)            ident(highlighted_code)operator(.)ident(sub!)operator(()regexp<delimiter(/)char(\\A)content(<(span|div\))delimiter(/)>operator(\)) operator({) operator(|)ident(m)operator(|) ident(m) operator(+) ident(pba)operator(()instance_variable(@in_bc) operator(||) ident(opts)operator(\)) operator(})]
insert[insert(+)            ident(highlighted_code) operator(=) ident(unescape)operator(()ident(highlighted_code)operator(\)) keyword(unless) instance_variable(@in_bc)]
insert[insert(+)            ident(highlighted_code)]
insert[insert(+)          keyword(else)]
insert[insert(+)            string<delimiter(")content(<code)inline<inline_delimiter(#{)ident(pba)operator(()ident(opts)operator(\))inline_delimiter(})>content(>)inline<inline_delimiter(#{)ident(opts)operator([)symbol(:text)operator(])inline_delimiter(})>content(</code>)delimiter(")>]
insert[insert(+)          keyword(end)]
insert[insert(+)        keyword(end)]
insert[insert(+)        keyword(def) method(bc_open)operator(()ident(opts)operator(\))  comment(# :nodoc:)]
insert[insert(+)          ident(opts)operator([)symbol(:block)operator(]) operator(=) predefined_constant(true)]
insert[insert(+)          instance_variable(@in_bc) operator(=) ident(opts)]
insert[insert(+)          ident(opts)operator([)symbol(:lang)operator(]) operator(?) string<delimiter(')delimiter(')> operator(:) string<delimiter(")content(<pre)inline<inline_delimiter(#{)ident(pba)operator(()ident(opts)operator(\))inline_delimiter(})>content(>)delimiter(")>]
insert[insert(+)        keyword(end)]
insert[insert(+)        keyword(def) method(bc_close)operator(()ident(opts)operator(\))  comment(# :nodoc:)]
insert[insert(+)          instance_variable(@in_bc) operator(=) predefined_constant(nil)]
insert[insert(+)          ident(opts)operator([)symbol(:lang)operator(]) operator(?) string<delimiter(')delimiter(')> operator(:) string<delimiter(")content(</pre>)char(\\n)delimiter(")>]
insert[insert(+)        keyword(end)]
insert[insert(+)        keyword(def) method(escape_pre)operator(()ident(text)operator(\))]
insert[insert(+)          keyword(if) instance_variable(@in_bc) operator(||=) predefined_constant(nil)]
insert[insert(+)            ident(text)]
insert[insert(+)          keyword(else)]
insert[insert(+)            ident(html_esc)operator(()ident(text)operator(,) symbol(:html_escape_preformatted)operator(\))]
insert[insert(+)          keyword(end)]
insert[insert(+)        keyword(end)]
insert[insert(+)      keyword(end)]
insert[insert(+)    keyword(end)]
insert[insert(+)]
insert[insert(+)    keyword(module) class(TextileDoc)  comment(# :nodoc:)]
insert[insert(+)      ident(attr_accessor) symbol(:filter_coderay)]
insert[insert(+)    keyword(end)]
insert[insert(+)    ]
insert[insert(+)  keyword(end)]
insert[insert(+)  ]
insert[insert(+)keyword(end)]
insert[insert(+)]
insert[insert(+)constant(CodeRay)operator(::)constant(ForRedCloth)operator(.)ident(install)]
comment(\\ No newline at end of file)
head[head(Index: )plain(lib/coderay/scanners/ruby/patterns.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay/scanners/ruby/patterns.rb)plain(	(revision 200\))]
head[head(+++ )filename(lib/coderay/scanners/ruby/patterns.rb)plain(	(revision 250\))]
change[change(@@)plain( -14,19 +14,14 )change(@@)]
 
     constant(DEF_KEYWORDS) operator(=) string<delimiter(%w[)content( def )delimiter(])>
     constant(UNDEF_KEYWORDS) operator(=) string<delimiter(%w[)content( undef )delimiter(])>
insert[insert(+)    constant(ALIAS_KEYWORDS) operator(=) string<delimiter(%w[)content( alias )delimiter(])>]
     constant(MODULE_KEYWORDS) operator(=) string<delimiter(%w[)content(class module)delimiter(])>
     constant(DEF_NEW_STATE) operator(=) constant(WordList)operator(.)ident(new)operator(()symbol(:initial)operator(\))operator(.)
       ident(add)operator(()constant(DEF_KEYWORDS)operator(,) symbol(:def_expected)operator(\))operator(.)
       ident(add)operator(()constant(UNDEF_KEYWORDS)operator(,) symbol(:undef_expected)operator(\))operator(.)
insert[insert(+)      ident(add)operator(()constant(ALIAS_KEYWORDS)operator(,) symbol(:alias_expected)operator(\))operator(.)]
       ident(add)operator(()constant(MODULE_KEYWORDS)operator(,) symbol(:module_expected)operator(\))
 
delete[delete(-)    constant(IDENTS_ALLOWING_REGEXP) operator(=) string<delimiter(%w[)>]
delete[delete(-)string<content(      and or not while until unless if then elsif when sub sub! gsub gsub!)>]
delete[delete(-)string<content(      scan slice slice! split)>]
delete[delete(-)string<content(    )delimiter(])>]
delete[delete(-)    constant(REGEXP_ALLOWED) operator(=) constant(WordList)operator(.)ident(new)operator(()predefined_constant(false)operator(\))operator(.)]
delete[delete(-)      ident(add)operator(()constant(IDENTS_ALLOWING_REGEXP)operator(,) symbol(:set)operator(\))]
delete[delete(-)]
     constant(PREDEFINED_CONSTANTS) operator(=) string<delimiter(%w[)>
string<content(       nil true false self)>
string<content(       DATA ARGV ARGF __FILE__ __LINE__)>
change[change(@@)plain( -41,19 +36,20 )change(@@)]
     constant(METHOD_NAME) operator(=) regexp<delimiter(/)content( )inline<inline_delimiter(#{)constant(IDENT)inline_delimiter(})>content( [?!]? )delimiter(/)modifier(ox)>
     constant(METHOD_NAME_OPERATOR) operator(=) regexp<delimiter(/)>
regexp<content(       )char(\\*)char(\\*)content(?           # multiplication and power)>
delete[delete(-)regexp<content(      | [-+)>eyecatcher<regexp<content(]@?        # plus, minus)>>]
delete[delete(-)regexp<content(      | [)char(\\/)content(%&|^`)>eyecatcher<regexp<content(~]    # division, modulo or format strings, &and, |or, ^xor, `system`, tilde)>>]
insert[insert(+)regexp<content(      | [-+)>eyecatcher<regexp<content(~]@?       # plus, minus, tilde with and without @)>>]
insert[insert(+)regexp<content(      | [)char(\\/)content(%&|^`)>eyecatcher<regexp<content(]     # division, modulo or format strings, &and, |or, ^xor, `system`)>>]
regexp<content(       | )char(\\[)char(\\])content(=?        # array getter and setter)>
regexp<content(       | << | >>       # append or shift left, shift right)>
regexp<content(       | <=?>? | >=?   # comparison, rocket operator)>
delete[delete(-)regexp<content(      | ===?          # simple equality and case equality)>]
insert[insert(+)regexp<content(      | ===? | =~     # simple equality, case equality, match)>]
insert[insert(+)regexp<content(      | ![~=@]?       # negation with and without @, not-equal and not-match)>]
regexp<content(     )delimiter(/)modifier(ox)>
     constant(METHOD_NAME_EX) operator(=) regexp<delimiter(/)content( )inline<inline_delimiter(#{)constant(IDENT)inline_delimiter(})>content( (?:[?!]|=(?!>\)\)? | )inline<inline_delimiter(#{)constant(METHOD_NAME_OPERATOR)inline_delimiter(})>content( )delimiter(/)modifier(ox)>
     constant(INSTANCE_VARIABLE) operator(=) regexp<delimiter(/)content( @ )inline<inline_delimiter(#{)constant(IDENT)inline_delimiter(})>content( )delimiter(/)modifier(ox)>
     constant(CLASS_VARIABLE) operator(=) regexp<delimiter(/)content( @@ )inline<inline_delimiter(#{)constant(IDENT)inline_delimiter(})>content( )delimiter(/)modifier(ox)>
     constant(OBJECT_VARIABLE) operator(=) regexp<delimiter(/)content( @@? )inline<inline_delimiter(#{)constant(IDENT)inline_delimiter(})>content( )delimiter(/)modifier(ox)>
     constant(GLOBAL_VARIABLE) operator(=) regexp<delimiter(/)content( )char(\\$)content( (?: )inline<inline_delimiter(#{)constant(IDENT)inline_delimiter(})>content( | [1-9])char(\\d)content(* | 0)char(\\w)content(* | [~&+`'=)char(\\/)content(,;_.<>!@$?*":)char(\\\\)content(] | -[a-zA-Z_0-9] \) )delimiter(/)modifier(ox)>
delete[delete(-)    constant(PREFIX_VARIABLE) operator(=) regexp<delimiter(/)content( )inline<inline_delimiter(#{)constant(GLOBAL_VARIABLE)inline_delimiter(})>content( |)inline<>>regexp<inline<inline_delimiter(#{)constant(OBJECT_VARIABLE)inline_delimiter(})>content( )delimiter(/)modifier(ox)>]
insert[insert(+)    constant(PREFIX_VARIABLE) operator(=) regexp<delimiter(/)content( )inline<inline_delimiter(#{)constant(GLOBAL_VARIABLE)inline_delimiter(})>content( |)>eyecatcher<regexp<content( )inline<>>>regexp<inline<inline_delimiter(#{)constant(OBJECT_VARIABLE)inline_delimiter(})>content( )delimiter(/)modifier(ox)>]
     constant(VARIABLE) operator(=) regexp<delimiter(/)content( @?@? )inline<inline_delimiter(#{)constant(IDENT)inline_delimiter(})>content( | )inline<inline_delimiter(#{)constant(GLOBAL_VARIABLE)inline_delimiter(})>content( )delimiter(/)modifier(ox)>
 
     constant(QUOTE_TO_TYPE) operator(=) operator({)
change[change(@@)plain( -73,7 +69,7 )change(@@)]
     constant(EXPONENT) operator(=) regexp<delimiter(/)content( [eE] [+-]? )inline<inline_delimiter(#{)constant(DECIMAL)inline_delimiter(})>content( )delimiter(/)modifier(ox)>
     constant(FLOAT_SUFFIX) operator(=) regexp<delimiter(/)content( )inline<inline_delimiter(#{)constant(EXPONENT)inline_delimiter(})>content( | )char(\\.)content( )inline<inline_delimiter(#{)constant(DECIMAL)inline_delimiter(})>content( )inline<inline_delimiter(#{)constant(EXPONENT)inline_delimiter(})>content(? )delimiter(/)modifier(ox)>
     constant(FLOAT_OR_INT) operator(=) regexp<delimiter(/)content( )inline<inline_delimiter(#{)constant(DECIMAL)inline_delimiter(})>content( (?: )inline<inline_delimiter(#{)constant(FLOAT_SUFFIX)inline_delimiter(})>content( (\) \)? )delimiter(/)modifier(ox)>
delete[delete(-)    constant(NUMERIC) operator(=) regexp<delimiter(/)content( )>eyecatcher<regexp<content([-+]? )>>regexp<content((?: (?=0\) (?: )inline<inline_delimiter(#{)constant(OCTAL)inline_delimiter(})>content( | )inline<inline_delimiter(#{)constant(HEXADECIMAL)inline_delimiter(})>content( | )inline<inline_delimiter(#{)constant(BINARY)inline_delimiter(})>content( \) | )inline<inline_delimiter(#{)constant(FLOAT_OR_INT)inline_delimiter(})>content( \) )delimiter(/)modifier(ox)>]
insert[insert(+)    constant(NUMERIC) operator(=) regexp<delimiter(/)content( )>regexp<content((?: (?=0\) (?: )inline<inline_delimiter(#{)constant(OCTAL)inline_delimiter(})>content( | )inline<inline_delimiter(#{)constant(HEXADECIMAL)inline_delimiter(})>content( | )inline<inline_delimiter(#{)constant(BINARY)inline_delimiter(})>content( \) | )inline<inline_delimiter(#{)constant(FLOAT_OR_INT)inline_delimiter(})>content( \) )delimiter(/)modifier(ox)>]
 
     constant(SYMBOL) operator(=) regexp<delimiter(/)>
regexp<content(       :)>
change[change(@@)plain( -83,6 +79,7 )change(@@)]
       operator(|) operator([)string<delimiter(')content("])>
string<content(       \))>
string<content(     /ox)>
insert[insert(+)string<content(    METHOD_NAME_OR_SYMBOL = / #{METHOD_NAME_EX} | #{SYMBOL} /ox)>]
string<content( )>
string<content(     # TODO investigste )content(\\M)content(, )content(\\c)content( and )content(\\C)content( escape sequences)>
string<content(     # (?: M-)char(\\\\)content(C-|C-)char(\\\\)content(M-|M-)char(\\\\)content(c|c)char(\\\\)content(M-|c|C-|M-\)? (?: )char(\\\\)content( (?: [0-7]{3} | x[0-9A-Fa-f]{2} | . \) \))>
change[change(@@)plain( -111,7 +108,7 )change(@@)]
       operator(()integer(?:)
         operator(() operator([)constant(A)operator(-)constant(Za)operator(-)ident(z_0)operator(-)integer(9)operator(])operator(+) operator(\))  comment(# $2 = delim)
       operator(|)
delete[delete(-)        operator(() operator([)string<delimiter(")content('`)>eyecatcher<string<content(] \)  )>>string<content(        # $3 = quote, type)>]
insert[insert(+)        operator(() operator([)string<delimiter(")content('`)>eyecatcher<string<char(\\/)content(] \))>>string<content(        # $3 = quote, type)>]
string<content(         ( [^)char(\\n)content(]*? \) )char(\\3)content(     # $4 = delim)>
string<content(       \))>
string<content(     /mx)>
change[change(@@)plain( -129,15 +126,14 )change(@@)]
     regexp<delimiter(/)content(mx)>
regexp<content(     )>
regexp<content(     # Checks for a valid value to follow. This enables)>
delete[delete(-)regexp<content(    # )>eyecatcher<regexp<content(fancy_allowed in method call)>>regexp<content(s.)>]
insert[insert(+)regexp<content(    # )>eyecatcher<regexp<content(value_expected in method calls without parenthese)>>regexp<content(s.)>]
regexp<content(     VALUE_FOLLOWS = )delimiter(/)>
delete[delete(-)      eyecatcher<error(\\)ident(s)operator(+)>]
insert[insert(+)      eyecatcher<operator(()integer(?>)operator([) error(\\)ident(t)error(\\)ident(f)error(\\)ident(v)operator(])operator(+)operator(\))>]
       operator(()integer(?:)
         operator([)string<delimiter(%\\)content(/][^)delimiter(\\)>ident(s)operator(=)operator(])
delete[delete(-)      operator(|)]
delete[delete(-)        operator(<<)operator(-)integer(?\\S)]
delete[delete(-)      operator(|)]
delete[delete(-)        comment(#{CHARACTER})]
insert[insert(+)      operator(|) operator(<<)operator(-)integer(?\\S)]
insert[insert(+)      operator(|) operator([)operator(-)operator(+)operator(]) error(\\)ident(d)]
insert[insert(+)      operator(|) comment(#{CHARACTER})]
       operator(\))
     regexp<delimiter(/)content(x)>
regexp<content( )>
head[head(Index: )plain(lib/coderay/scanners/ruby.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay/scanners/ruby.rb)plain(	(revision 200\))]
head[head(+++ )filename(lib/coderay/scanners/ruby.rb)plain(	(revision 250\))]
change[change(@@)plain( -18,6 +18,7 )change(@@)]
     ident(include) constant(Streamable)
 
     ident(register_for) symbol(:ruby)
insert[insert(+)    ident(file_extension) string<delimiter(')content(rb)delimiter(')>]
 
     ident(helper) symbol(:patterns)
 
change[change(@@)plain( -90,15 +91,15 )change(@@)]
             keyword(end)
 
           keyword(when) string<delimiter(')content(#)delimiter(')>
delete[delete(-)            keyword(case) ident(peek)operator(()integer(1)operator(\))eyecatcher<operator([)integer(0)operator(])>]
delete[delete(-)            keyword(when) eyecatcher<integer(?{)>]
insert[insert(+)            keyword(case) ident(peek)operator(()integer(1)operator(\))]
insert[insert(+)            keyword(when) string<>eyecatcher<string<delimiter(')content({)delimiter(')>>]
               ident(inline_block_stack) operator(<<) operator([)ident(state)operator(,) ident(depth)operator(,) ident(heredocs)operator(])
               ident(value_expected) operator(=) predefined_constant(true)
               ident(state) operator(=) symbol(:initial)
               ident(depth) operator(=) integer(1)
               ident(tokens) operator(<<) operator([)symbol(:open)operator(,) symbol(:inline)operator(])
               ident(tokens) operator(<<) operator([)ident(match) operator(+) ident(getch)operator(,) symbol(:inline_delimiter)operator(])
delete[delete(-)            keyword(when) eyecatcher<integer(?$)operator(,) integer(?@)>]
insert[insert(+)            keyword(when) string<>eyecatcher<string<delimiter(')content($)delimiter(')>operator(,) string<delimiter(')content(@)delimiter(')>>]
               ident(tokens) operator(<<) operator([)ident(match)operator(,) symbol(:escape)operator(])
               ident(last_state) operator(=) ident(state)  comment(# scan one token as normal code, then return here)
               ident(state) operator(=) symbol(:initial)
change[change(@@)plain( -121,36 +122,37 )change(@@)]
 comment(# }}})
         keyword(else)
 comment(# {{{)
delete[delete(-)          keyword(if) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content( [ )char(\\t)char(\\f)content(]+ | )char(\\\\)content(? )char(\\n)content( | )char(\\#)content( .* )delimiter(/)modifier(x)>operator(\)) keyword(or)]
delete[delete(-)            operator(() ident(bol?) keyword(and) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)inline<inline_delimiter(#{)ident(patterns)operator(::)constant(RUBYDOC_OR_DATA)inline_delimiter(})>delimiter(/)modifier(o)>operator(\)) operator(\))]
delete[delete(-)            keyword(case) ident(m) operator(=) ident(match)operator([)integer(0)operator(])]
delete[delete(-)            keyword(when) integer(?\\s)operator(,) integer(?\\t)operator(,) integer(?\\f)]
delete[delete(-)              ident(match) operator(<<) ident(scan)operator(()regexp<delimiter(/)char(\\s)content(*)delimiter(/)>operator(\)) keyword(unless) ident(eos?) keyword(or) ident(heredocs)]
delete[delete(-)              ident(kind) operator(=) symbol(:space)]
delete[delete(-)            keyword(when) integer(?\\n)operator(,) integer(?\\\\)]
delete[delete(-)              ident(kind) operator(=) symbol(:space)]
delete[delete(-)              keyword(if) ident(m) operator(==) integer(?\\n)]
delete[delete(-)                ident(value_expected) operator(=) predefined_constant(true)  comment(# FIXME not quite true)]
delete[delete(-)                ident(state) operator(=) symbol(:initial) keyword(if) ident(state) operator(==) symbol(:undef_comma_expected)]
delete[delete(-)              keyword(end)]
delete[delete(-)              keyword(if) ident(heredocs)]
delete[delete(-)                ident(unscan)  comment(# heredoc scanning needs \\n at start)]
delete[delete(-)                ident(state) operator(=) ident(heredocs)operator(.)ident(shift)]
delete[delete(-)                ident(tokens) operator(<<) operator([)symbol(:open)operator(,) ident(state)operator(.)ident(type)operator(])]
delete[delete(-)                ident(heredocs) operator(=) predefined_constant(nil) keyword(if) ident(heredocs)operator(.)ident(empty?)]
delete[delete(-)                keyword(next)]
delete[delete(-)              keyword(else)]
delete[delete(-)                ident(match) operator(<<) ident(scan)operator(()regexp<delimiter(/)char(\\s)content(*)delimiter(/)>operator(\)) keyword(unless) ident(eos?)]
delete[delete(-)              keyword(end)]
delete[delete(-)            keyword(when) integer(?#)operator(,) integer(?=)operator(,) integer(?_)]
delete[delete(-)              ident(kind) operator(=) symbol(:comment)]
delete[delete(-)              ident(value_expected) operator(=) predefined_constant(true)]
insert[insert(+)          keyword(if) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content([ )char(\\t)char(\\f)content(]+)delimiter(/)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:space)]
insert[insert(+)            ident(match) operator(<<) ident(scan)operator(()regexp<delimiter(/)char(\\s)content(*)delimiter(/)>operator(\)) keyword(unless) ident(eos?) operator(||) ident(heredocs)]
insert[insert(+)            ident(value_expected) operator(=) predefined_constant(true) keyword(if) ident(match)operator(.)ident(index)operator(()integer(?\\n)operator(\)) comment(# FIXME not quite true)]
insert[insert(+)            ident(tokens) operator(<<) operator([)ident(match)operator(,) ident(kind)operator(])]
insert[insert(+)            keyword(next)]
insert[insert(+)            ]
insert[insert(+)          keyword(elsif) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)char(\\\\)content(?)char(\\n)delimiter(/)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:space)]
insert[insert(+)            keyword(if) ident(match) operator(==) string<delimiter(")char(\\n)delimiter(")>]
insert[insert(+)              ident(value_expected) operator(=) predefined_constant(true)  comment(# FIXME not quite true)]
insert[insert(+)              ident(state) operator(=) symbol(:initial) keyword(if) ident(state) operator(==) symbol(:undef_comma_expected)]
insert[insert(+)            keyword(end)]
insert[insert(+)            keyword(if) ident(heredocs)]
insert[insert(+)              ident(unscan)  comment(# heredoc scanning needs \\n at start)]
insert[insert(+)              ident(state) operator(=) ident(heredocs)operator(.)ident(shift)]
insert[insert(+)              ident(tokens) operator(<<) operator([)symbol(:open)operator(,) ident(state)operator(.)ident(type)operator(])]
insert[insert(+)              ident(heredocs) operator(=) predefined_constant(nil) keyword(if) ident(heredocs)operator(.)ident(empty?)]
insert[insert(+)              keyword(next)]
             keyword(else)
delete[delete(-)              ident(raise_inspect) string<delimiter(')content(else-case _ reached, because case %p was)>]
delete[delete(-)string<content(                not handled)delimiter(')> operator(%) operator([)ident(matched)operator([)integer(0)operator(])operator(.)ident(chr)operator(])operator(,) ident(tokens)]
insert[insert(+)              ident(match) operator(<<) ident(scan)operator(()regexp<delimiter(/)char(\\s)content(*)delimiter(/)>operator(\)) keyword(unless) ident(eos?)]
             keyword(end)
             ident(tokens) operator(<<) operator([)ident(match)operator(,) ident(kind)operator(])
             keyword(next)
insert[insert(+)          ]
insert[insert(+)          keyword(elsif) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)char(\\#)content(.*)delimiter(/)>operator(\)) keyword(or)]
insert[insert(+)            operator(() ident(bol?) keyword(and) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)inline<inline_delimiter(#{)ident(patterns)operator(::)constant(RUBYDOC_OR_DATA)inline_delimiter(})>delimiter(/)modifier(o)>operator(\)) operator(\))]
insert[insert(+)              ident(kind) operator(=) symbol(:comment)]
insert[insert(+)              ident(value_expected) operator(=) predefined_constant(true)]
insert[insert(+)              ident(tokens) operator(<<) operator([)ident(match)operator(,) ident(kind)operator(])]
insert[insert(+)              keyword(next)]
 
           keyword(elsif) ident(state) operator(==) symbol(:initial)
 
change[change(@@)plain( -167,19 +169,19 )change(@@)]
                 keyword(end)
               keyword(end)
               comment(## experimental!)
delete[delete(-)              ident(value_expected) operator(=) symbol(:set) keyword(if)]
delete[delete(-)                ident(patterns)operator(::)constant(REGEXP_ALLOWED)operator([)ident(match)operator(]) keyword(or) ident(check)operator(()regexp<delimiter(/)inline<inline_delimiter(#{)ident(patterns)operator(::)constant(VALUE_FOLLOWS)inline_delimiter(})>delimiter(/)modifier(o)>operator(\))]
insert[insert(+)              ident(value_expected) operator(=) symbol(:set) keyword(if) ident(check)operator(()regexp<delimiter(/)inline<inline_delimiter(#{)ident(patterns)operator(::)constant(VALUE_FOLLOWS)inline_delimiter(})>delimiter(/)modifier(o)>operator(\))]
             
             keyword(elsif) ident(last_token_dot) keyword(and) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)inline<inline_delimiter(#{)ident(patterns)operator(::)constant(METHOD_NAME_OPERATOR)inline_delimiter(})>delimiter(/)modifier(o)>operator(\))
               ident(kind) operator(=) symbol(:ident)
               ident(value_expected) operator(=) symbol(:set) keyword(if) ident(check)operator(()regexp<delimiter(/)inline<inline_delimiter(#{)ident(patterns)operator(::)constant(VALUE_FOLLOWS)inline_delimiter(})>delimiter(/)modifier(o)>operator(\))
 
             comment(# OPERATORS #)
delete[delete(-)            keyword(elsif) keyword(not) ident(last_token_dot) keyword(and) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content( ==?=? | )char(\\.)char(\\.)content(?)char(\\.)content(? | [)char(\\()char(\\\))char(\\[)char(\\])char(\\{)char(\\})content(] | :: | , )delimiter(/)modifier(x)>operator(\))]
insert[insert(+)            comment(# TODO: match (\), [], {} as one single operator)]
insert[insert(+)            keyword(elsif) keyword(not) ident(last_token_dot) keyword(and) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content( )char(\\.)char(\\.)char(\\.)content(? | (?:)char(\\.)content(|::\)(\) | [,)char(\\()char(\\\))char(\\[)char(\\])char(\\{)char(\\})content(] | ==?=? )delimiter(/)modifier(x)>operator(\))]
               keyword(if) ident(match) operator(!)operator(~) regexp<delimiter(/)content( [.)char(\\\))char(\\])char(\\})content(] )delimiter(/)modifier(x)> keyword(or) ident(match) operator(=)operator(~) regexp<delimiter(/)char(\\.)char(\\.)char(\\.)content(?)delimiter(/)>
                 ident(value_expected) operator(=) symbol(:set)
               keyword(end)
delete[delete(-)              ident(last_token_dot) operator(=) symbol(:set) keyword(if) eyecatcher<ident(match) operator(==) string<delimiter(')content(.)delimiter(')> keyword(or) ident(match) operator(==) string<delimiter(')content(::)delimiter(')>>]
insert[insert(+)              ident(last_token_dot) operator(=) symbol(:set) keyword(if) eyecatcher<predefined_constant(self)operator([)integer(1)operator(])>]
               ident(kind) operator(=) symbol(:operator)
               keyword(unless) ident(inline_block_stack)operator(.)ident(empty?)
                 keyword(case) ident(match)
change[change(@@)plain( -210,8 +212,9 )change(@@)]
               ident(interpreted) operator(=) predefined_constant(true)
               ident(state) operator(=) ident(patterns)operator(::)constant(StringState)operator(.)ident(new) symbol(:regexp)operator(,) ident(interpreted)operator(,) ident(match)
 
delete[delete(-)            keyword(elsif) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)inline<inline_delimiter(#{)ident(patterns)operator(::)constant(NUMERIC)inline_delimiter(})>delimiter(/)modifier(o)>operator(\))]
delete[delete(-)              ident(kind) operator(=) keyword(if) predefined_constant(self)operator([)integer(1)operator(]) keyword(then) symbol(:float) keyword(else) symbol(:integer) keyword(end)]
insert[insert(+)            comment(# elsif match = scan(/[-+]?#{patterns::NUMERIC}/o\))]
insert[insert(+)            keyword(elsif) ident(match) operator(=) ident(value_expected) operator(?) ident(scan)operator(()regexp<delimiter(/)content([-+]?)inline<inline_delimiter(#{)ident(patterns)operator(::)constant(NUMERIC)inline_delimiter(})>delimiter(/)modifier(o)>operator(\)) operator(:) ident(scan)operator(()regexp<delimiter(/)inline<inline_delimiter(#{)ident(patterns)operator(::)constant(NUMERIC)inline_delimiter(})>delimiter(/)modifier(o)>operator(\))]
insert[insert(+)              ident(kind) operator(=) predefined_constant(self)operator([)integer(1)operator(]) operator(?) symbol(:float) operator(:) symbol(:integer)]
 
             keyword(elsif) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)inline<inline_delimiter(#{)ident(patterns)operator(::)constant(SYMBOL)inline_delimiter(})>delimiter(/)modifier(o)>operator(\))
               keyword(case) ident(delim) operator(=) ident(match)operator([)integer(1)operator(])
change[change(@@)plain( -285,6 +288,18 )change(@@)]
               keyword(next)
             keyword(end)
 
insert[insert(+)          keyword(elsif) ident(state) operator(==) symbol(:module_expected)]
insert[insert(+)            keyword(if) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content(<<)delimiter(/)>operator(\))]
insert[insert(+)              ident(kind) operator(=) symbol(:operator)]
insert[insert(+)            keyword(else)]
insert[insert(+)              ident(state) operator(=) symbol(:initial)]
insert[insert(+)              keyword(if) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content( (?:)inline<inline_delimiter(#{)ident(patterns)operator(::)constant(IDENT)inline_delimiter(})>content(::\)* )inline<inline_delimiter(#{)ident(patterns)operator(::)constant(IDENT)inline_delimiter(})>content( )delimiter(/)modifier(ox)>operator(\))]
insert[insert(+)                ident(kind) operator(=) symbol(:class)]
insert[insert(+)              keyword(else)]
insert[insert(+)                keyword(next)]
insert[insert(+)              keyword(end)]
insert[insert(+)            keyword(end)]
insert[insert(+)]
           keyword(elsif) ident(state) operator(==) symbol(:undef_expected)
             ident(state) operator(=) symbol(:undef_comma_expected)
             keyword(if) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)inline<inline_delimiter(#{)ident(patterns)operator(::)constant(METHOD_NAME_EX)inline_delimiter(})>delimiter(/)modifier(o)>operator(\))
change[change(@@)plain( -306,6 +321,15 )change(@@)]
               keyword(next)
             keyword(end)
 
insert[insert(+)          keyword(elsif) ident(state) operator(==) symbol(:alias_expected)]
insert[insert(+)            keyword(if) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content(()inline<inline_delimiter(#{)ident(patterns)operator(::)constant(METHOD_NAME_OR_SYMBOL)inline_delimiter(})>content(\)([ )char(\\t)content(]+\)()inline<inline_delimiter(#{)ident(patterns)operator(::)constant(METHOD_NAME_OR_SYMBOL)inline_delimiter(})>content(\))delimiter(/)modifier(o)>operator(\))]
insert[insert(+)              ident(tokens) operator(<<) operator([)predefined_constant(self)operator([)integer(1)operator(])operator(,) operator(()predefined_constant(self)operator([)integer(1)operator(])operator([)integer(0)operator(]) operator(==) integer(?:) operator(?) symbol(:symbol) operator(:) symbol(:method)operator(\))operator(])]
insert[insert(+)              ident(tokens) operator(<<) operator([)predefined_constant(self)operator([)integer(2)operator(])operator(,) symbol(:space)operator(])]
insert[insert(+)              ident(tokens) operator(<<) operator([)predefined_constant(self)operator([)integer(3)operator(])operator(,) operator(()predefined_constant(self)operator([)integer(3)operator(])operator([)integer(0)operator(]) operator(==) integer(?:) operator(?) symbol(:symbol) operator(:) symbol(:method)operator(\))operator(])]
insert[insert(+)            keyword(end)]
insert[insert(+)            ident(state) operator(=) symbol(:initial)]
insert[insert(+)            keyword(next)]
insert[insert(+)]
           keyword(elsif) ident(state) operator(==) symbol(:undef_comma_expected)
             keyword(if) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content(,)delimiter(/)>operator(\))
               ident(kind) operator(=) symbol(:operator)
change[change(@@)plain( -315,24 +339,14 )change(@@)]
               keyword(next)
             keyword(end)
 
delete[delete(-)          keyword(elsif) ident(state) operator(==) symbol(:module_expected)]
delete[delete(-)            keyword(if) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content(<<)delimiter(/)>operator(\))]
delete[delete(-)              ident(kind) operator(=) symbol(:operator)]
delete[delete(-)            keyword(else)]
delete[delete(-)              ident(state) operator(=) symbol(:initial)]
delete[delete(-)              keyword(if) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content( (?:)inline<inline_delimiter(#{)ident(patterns)operator(::)constant(IDENT)inline_delimiter(})>content(::\)* )inline<inline_delimiter(#{)ident(patterns)operator(::)constant(IDENT)inline_delimiter(})>content( )delimiter(/)modifier(ox)>operator(\))]
delete[delete(-)                ident(kind) operator(=) symbol(:class)]
delete[delete(-)              keyword(else)]
delete[delete(-)                keyword(next)]
delete[delete(-)              keyword(end)]
delete[delete(-)            keyword(end)]
delete[delete(-)]
           keyword(end)
 comment(# }}})
insert[insert(+)          ]
insert[insert(+)          keyword(unless) ident(kind) operator(==) symbol(:error)]
insert[insert(+)            ident(value_expected) operator(=) ident(value_expected) operator(==) symbol(:set)]
insert[insert(+)            ident(last_token_dot) operator(=) ident(last_token_dot) operator(==) symbol(:set)]
insert[insert(+)          keyword(end)]
 
delete[delete(-)          ident(value_expected) operator(=) ident(value_expected) operator(==) symbol(:set)]
delete[delete(-)          ident(last_token_dot) operator(=) ident(last_token_dot) operator(==) symbol(:set)]
delete[delete(-)]
           keyword(if) global_variable($DEBUG) keyword(and) keyword(not) ident(kind)
             ident(raise_inspect) string<delimiter(')content(Error token %p in line %d)delimiter(')> operator(%)
               operator([)operator([)ident(match)operator(,) ident(kind)operator(])operator(,) ident(line)operator(])operator(,) ident(tokens)operator(,) ident(state)
head[head(Index: )plain(lib/coderay/scanners/c.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay/scanners/c.rb)plain(	(revision 200\))]
head[head(+++ )filename(lib/coderay/scanners/c.rb)plain(	(revision 250\))]
change[change(@@)plain( -4,6 +4,8 )change(@@)]
   keyword(class) class(C) operator(<) constant(Scanner)
 
     ident(register_for) symbol(:c)
insert[insert(+)    ]
insert[insert(+)    ident(include) constant(Streamable)]
 
     constant(RESERVED_WORDS) operator(=) operator([)
       string<delimiter(')content(asm)delimiter(')>operator(,) string<delimiter(')content(break)delimiter(')>operator(,) string<delimiter(')content(case)delimiter(')>operator(,) string<delimiter(')content(continue)delimiter(')>operator(,) string<delimiter(')content(default)delimiter(')>operator(,) string<delimiter(')content(do)delimiter(')>operator(,) string<delimiter(')content(else)delimiter(')>operator(,)
change[change(@@)plain( -42,7 +44,7 )change(@@)]
 
         ident(kind) operator(=) predefined_constant(nil)
         ident(match) operator(=) predefined_constant(nil)
delete[delete(-)]
insert[insert(+)eyecatcher<        >]
         keyword(case) ident(state)
 
         keyword(when) symbol(:initial)
head[head(Index: )plain(lib/coderay/scanners/scheme.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay/scanners/scheme.rb)plain(	(revision 0\))]
head[head(+++ )filename(lib/coderay/scanners/scheme.rb)plain(	(revision 250\))]
change[change(@@)plain( -0,0 +1,142 )change(@@)]
insert[insert(+)keyword(module) class(CodeRay)]
insert[insert(+)  keyword(module) class(Scanners)]
insert[insert(+)]
insert[insert(+)    comment(# Scheme scanner for CodeRay (by closure\).)]
insert[insert(+)    comment(# Thanks to murphy for putting CodeRay into public.)]
insert[insert(+)    keyword(class) class(Scheme) operator(<) constant(Scanner)]
insert[insert(+)      ]
insert[insert(+)      ident(register_for) symbol(:scheme)]
insert[insert(+)      ident(file_extension) symbol(:scm)]
insert[insert(+)]
insert[insert(+)      constant(CORE_FORMS) operator(=) string<delimiter(%w[)>]
insert[insert(+)string<content(        lambda let let* letrec syntax-case define-syntax let-syntax)>]
insert[insert(+)string<content(        letrec-syntax begin define quote if or and cond case do delay)>]
insert[insert(+)string<content(        quasiquote set! cons force call-with-current-continuation call/cc)>]
insert[insert(+)string<content(      )delimiter(])>]
insert[insert(+)]
insert[insert(+)      constant(IDENT_KIND) operator(=) constant(CaseIgnoringWordList)operator(.)ident(new)operator(()symbol(:ident)operator(\))operator(.)]
insert[insert(+)        ident(add)operator(()constant(CORE_FORMS)operator(,) symbol(:reserved)operator(\))]
insert[insert(+)      ]
insert[insert(+)      comment(#IDENTIFIER_INITIAL = /[a-z!@\\$%&\\*\\/\\:<=>\\?~_\\^]/i)]
insert[insert(+)      comment(#IDENTIFIER_SUBSEQUENT = /#{IDENTIFIER_INITIAL}|\\d|\\.|\\+|-/)]
insert[insert(+)      comment(#IDENTIFIER = /#{IDENTIFIER_INITIAL}#{IDENTIFIER_SUBSEQUENT}*|\\+|-|\\.{3}/)]
insert[insert(+)      constant(IDENTIFIER) operator(=) regexp<delimiter(/)content([a-zA-Z!@$%&*)char(\\/)content(:<=>?~_^][)char(\\w)content(!@$%&*)char(\\/)content(:<=>?~^.+)char(\\-)content(]*|[+-]|)char(\\.)char(\\.)char(\\.)delimiter(/)>]
insert[insert(+)      constant(DIGIT) operator(=) regexp<delimiter(/)char(\\d)delimiter(/)>]
insert[insert(+)      constant(DIGIT10) operator(=) constant(DIGIT)]
insert[insert(+)      constant(DIGIT16) operator(=) regexp<delimiter(/)content([0-9a-f])delimiter(/)modifier(i)>]
insert[insert(+)      constant(DIGIT8) operator(=) regexp<delimiter(/)content([0-7])delimiter(/)>]
insert[insert(+)      constant(DIGIT2) operator(=) regexp<delimiter(/)content([01])delimiter(/)>]
insert[insert(+)      constant(RADIX16) operator(=) regexp<delimiter(/)char(\\#)content(x)delimiter(/)modifier(i)>]
insert[insert(+)      constant(RADIX8) operator(=) regexp<delimiter(/)char(\\#)content(o)delimiter(/)modifier(i)>]
insert[insert(+)      constant(RADIX2) operator(=) regexp<delimiter(/)char(\\#)content(b)delimiter(/)modifier(i)>]
insert[insert(+)      constant(RADIX10) operator(=) regexp<delimiter(/)char(\\#)content(d)delimiter(/)modifier(i)>]
insert[insert(+)      constant(EXACTNESS) operator(=) regexp<delimiter(/)content(#i|#e)delimiter(/)modifier(i)>]
insert[insert(+)      constant(SIGN) operator(=) regexp<delimiter(/)content([)char(\\+)content(-]?)delimiter(/)>]
insert[insert(+)      constant(EXP_MARK) operator(=) regexp<delimiter(/)content([esfdl])delimiter(/)modifier(i)>]
insert[insert(+)      constant(EXP) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(EXP_MARK)inline_delimiter(})>inline<inline_delimiter(#{)constant(SIGN)inline_delimiter(})>inline<inline_delimiter(#{)constant(DIGIT)inline_delimiter(})>content(+)delimiter(/)>]
insert[insert(+)      constant(SUFFIX) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(EXP)inline_delimiter(})>content(?)delimiter(/)>]
insert[insert(+)      constant(PREFIX10) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(RADIX10)inline_delimiter(})>content(?)inline<inline_delimiter(#{)constant(EXACTNESS)inline_delimiter(})>content(?|)inline<inline_delimiter(#{)constant(EXACTNESS)inline_delimiter(})>content(?)inline<inline_delimiter(#{)constant(RADIX10)inline_delimiter(})>content(?)delimiter(/)>]
insert[insert(+)      constant(PREFIX16) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(RADIX16)inline_delimiter(})>inline<inline_delimiter(#{)constant(EXACTNESS)inline_delimiter(})>content(?|)inline<inline_delimiter(#{)constant(EXACTNESS)inline_delimiter(})>content(?)inline<inline_delimiter(#{)constant(RADIX16)inline_delimiter(})>delimiter(/)>]
insert[insert(+)      constant(PREFIX8) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(RADIX8)inline_delimiter(})>inline<inline_delimiter(#{)constant(EXACTNESS)inline_delimiter(})>content(?|)inline<inline_delimiter(#{)constant(EXACTNESS)inline_delimiter(})>content(?)inline<inline_delimiter(#{)constant(RADIX8)inline_delimiter(})>delimiter(/)>]
insert[insert(+)      constant(PREFIX2) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(RADIX2)inline_delimiter(})>inline<inline_delimiter(#{)constant(EXACTNESS)inline_delimiter(})>content(?|)inline<inline_delimiter(#{)constant(EXACTNESS)inline_delimiter(})>content(?)inline<inline_delimiter(#{)constant(RADIX2)inline_delimiter(})>delimiter(/)>]
insert[insert(+)      constant(UINT10) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(DIGIT10)inline_delimiter(})>content(+#*)delimiter(/)>]
insert[insert(+)      constant(UINT16) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(DIGIT16)inline_delimiter(})>content(+#*)delimiter(/)>]
insert[insert(+)      constant(UINT8) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(DIGIT8)inline_delimiter(})>content(+#*)delimiter(/)>]
insert[insert(+)      constant(UINT2) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(DIGIT2)inline_delimiter(})>content(+#*)delimiter(/)>]
insert[insert(+)      constant(DECIMAL) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(DIGIT10)inline_delimiter(})>content(+#+)char(\\.)content(#*)inline<inline_delimiter(#{)constant(SUFFIX)inline_delimiter(})>content(|)inline<inline_delimiter(#{)constant(DIGIT10)inline_delimiter(})>content(+)char(\\.)inline<inline_delimiter(#{)constant(DIGIT10)inline_delimiter(})>content(*#*)inline<inline_delimiter(#{)constant(SUFFIX)inline_delimiter(})>content(|)char(\\.)inline<inline_delimiter(#{)constant(DIGIT10)inline_delimiter(})>content(+#*)inline<inline_delimiter(#{)constant(SUFFIX)inline_delimiter(})>content(|)inline<inline_delimiter(#{)constant(UINT10)inline_delimiter(})>inline<inline_delimiter(#{)constant(EXP)inline_delimiter(})>delimiter(/)>]
insert[insert(+)      constant(UREAL10) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(UINT10)inline_delimiter(})>char(\\/)inline<inline_delimiter(#{)constant(UINT10)inline_delimiter(})>content(|)inline<inline_delimiter(#{)constant(DECIMAL)inline_delimiter(})>content(|)inline<inline_delimiter(#{)constant(UINT10)inline_delimiter(})>delimiter(/)>]
insert[insert(+)      constant(UREAL16) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(UINT16)inline_delimiter(})>char(\\/)inline<inline_delimiter(#{)constant(UINT16)inline_delimiter(})>content(|)inline<inline_delimiter(#{)constant(UINT16)inline_delimiter(})>delimiter(/)>]
insert[insert(+)      constant(UREAL8) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(UINT8)inline_delimiter(})>char(\\/)inline<inline_delimiter(#{)constant(UINT8)inline_delimiter(})>content(|)inline<inline_delimiter(#{)constant(UINT8)inline_delimiter(})>delimiter(/)>]
insert[insert(+)      constant(UREAL2) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(UINT2)inline_delimiter(})>char(\\/)inline<inline_delimiter(#{)constant(UINT2)inline_delimiter(})>content(|)inline<inline_delimiter(#{)constant(UINT2)inline_delimiter(})>delimiter(/)>]
insert[insert(+)      constant(REAL10) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(SIGN)inline_delimiter(})>inline<inline_delimiter(#{)constant(UREAL10)inline_delimiter(})>delimiter(/)>]
insert[insert(+)      constant(REAL16) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(SIGN)inline_delimiter(})>inline<inline_delimiter(#{)constant(UREAL16)inline_delimiter(})>delimiter(/)>]
insert[insert(+)      constant(REAL8) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(SIGN)inline_delimiter(})>inline<inline_delimiter(#{)constant(UREAL8)inline_delimiter(})>delimiter(/)>]
insert[insert(+)      constant(REAL2) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(SIGN)inline_delimiter(})>inline<inline_delimiter(#{)constant(UREAL2)inline_delimiter(})>delimiter(/)>]
insert[insert(+)      constant(IMAG10) operator(=) regexp<delimiter(/)content(i|)inline<inline_delimiter(#{)constant(UREAL10)inline_delimiter(})>content(i)delimiter(/)>]
insert[insert(+)      constant(IMAG16) operator(=) regexp<delimiter(/)content(i|)inline<inline_delimiter(#{)constant(UREAL16)inline_delimiter(})>content(i)delimiter(/)>]
insert[insert(+)      constant(IMAG8) operator(=) regexp<delimiter(/)content(i|)inline<inline_delimiter(#{)constant(UREAL8)inline_delimiter(})>content(i)delimiter(/)>]
insert[insert(+)      constant(IMAG2) operator(=) regexp<delimiter(/)content(i|)inline<inline_delimiter(#{)constant(UREAL2)inline_delimiter(})>content(i)delimiter(/)>]
insert[insert(+)      constant(COMPLEX10) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(REAL10)inline_delimiter(})>content(@)inline<inline_delimiter(#{)constant(REAL10)inline_delimiter(})>content(|)inline<inline_delimiter(#{)constant(REAL10)inline_delimiter(})>char(\\+)inline<inline_delimiter(#{)constant(IMAG10)inline_delimiter(})>content(|)inline<inline_delimiter(#{)constant(REAL10)inline_delimiter(})>content(-)inline<inline_delimiter(#{)constant(IMAG10)inline_delimiter(})>content(|)char(\\+)inline<inline_delimiter(#{)constant(IMAG10)inline_delimiter(})>content(|-)inline<inline_delimiter(#{)constant(IMAG10)inline_delimiter(})>content(|)inline<inline_delimiter(#{)constant(REAL10)inline_delimiter(})>delimiter(/)>]
insert[insert(+)      constant(COMPLEX16) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(REAL16)inline_delimiter(})>content(@)inline<inline_delimiter(#{)constant(REAL16)inline_delimiter(})>content(|)inline<inline_delimiter(#{)constant(REAL16)inline_delimiter(})>char(\\+)inline<inline_delimiter(#{)constant(IMAG16)inline_delimiter(})>content(|)inline<inline_delimiter(#{)constant(REAL16)inline_delimiter(})>content(-)inline<inline_delimiter(#{)constant(IMAG16)inline_delimiter(})>content(|)char(\\+)inline<inline_delimiter(#{)constant(IMAG16)inline_delimiter(})>content(|-)inline<inline_delimiter(#{)constant(IMAG16)inline_delimiter(})>content(|)inline<inline_delimiter(#{)constant(REAL16)inline_delimiter(})>delimiter(/)>]
insert[insert(+)      constant(COMPLEX8) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(REAL8)inline_delimiter(})>content(@)inline<inline_delimiter(#{)constant(REAL8)inline_delimiter(})>content(|)inline<inline_delimiter(#{)constant(REAL8)inline_delimiter(})>char(\\+)inline<inline_delimiter(#{)constant(IMAG8)inline_delimiter(})>content(|)inline<inline_delimiter(#{)constant(REAL8)inline_delimiter(})>content(-)inline<inline_delimiter(#{)constant(IMAG8)inline_delimiter(})>content(|)char(\\+)inline<inline_delimiter(#{)constant(IMAG8)inline_delimiter(})>content(|-)inline<inline_delimiter(#{)constant(IMAG8)inline_delimiter(})>content(|)inline<inline_delimiter(#{)constant(REAL8)inline_delimiter(})>delimiter(/)>]
insert[insert(+)      constant(COMPLEX2) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(REAL2)inline_delimiter(})>content(@)inline<inline_delimiter(#{)constant(REAL2)inline_delimiter(})>content(|)inline<inline_delimiter(#{)constant(REAL2)inline_delimiter(})>char(\\+)inline<inline_delimiter(#{)constant(IMAG2)inline_delimiter(})>content(|)inline<inline_delimiter(#{)constant(REAL2)inline_delimiter(})>content(-)inline<inline_delimiter(#{)constant(IMAG2)inline_delimiter(})>content(|)char(\\+)inline<inline_delimiter(#{)constant(IMAG2)inline_delimiter(})>content(|-)inline<inline_delimiter(#{)constant(IMAG2)inline_delimiter(})>content(|)inline<inline_delimiter(#{)constant(REAL2)inline_delimiter(})>delimiter(/)>]
insert[insert(+)      constant(NUM10) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(PREFIX10)inline_delimiter(})>content(?)inline<inline_delimiter(#{)constant(COMPLEX10)inline_delimiter(})>delimiter(/)>]
insert[insert(+)      constant(NUM16) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(PREFIX16)inline_delimiter(})>inline<inline_delimiter(#{)constant(COMPLEX16)inline_delimiter(})>delimiter(/)>]
insert[insert(+)      constant(NUM8) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(PREFIX8)inline_delimiter(})>inline<inline_delimiter(#{)constant(COMPLEX8)inline_delimiter(})>delimiter(/)>]
insert[insert(+)      constant(NUM2) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(PREFIX2)inline_delimiter(})>inline<inline_delimiter(#{)constant(COMPLEX2)inline_delimiter(})>delimiter(/)>]
insert[insert(+)      constant(NUM) operator(=) regexp<delimiter(/)inline<inline_delimiter(#{)constant(NUM10)inline_delimiter(})>content(|)inline<inline_delimiter(#{)constant(NUM16)inline_delimiter(})>content(|)inline<inline_delimiter(#{)constant(NUM8)inline_delimiter(})>content(|)inline<inline_delimiter(#{)constant(NUM2)inline_delimiter(})>delimiter(/)>]
insert[insert(+)    ]
insert[insert(+)    ident(private)]
insert[insert(+)      keyword(def) method(scan_tokens) ident(tokens)operator(,)ident(options)]
insert[insert(+)        ]
insert[insert(+)        ident(state) operator(=) symbol(:initial)]
insert[insert(+)        ident(ident_kind) operator(=) constant(IDENT_KIND)]
insert[insert(+)        ]
insert[insert(+)        keyword(until) ident(eos?)]
insert[insert(+)          ident(kind) operator(=) ident(match) operator(=) predefined_constant(nil)]
insert[insert(+)          ]
insert[insert(+)          keyword(case) ident(state)]
insert[insert(+)          keyword(when) symbol(:initial)]
insert[insert(+)            keyword(if) ident(scan)operator(()regexp<delimiter(/)content( )char(\\s)content(+ | )char(\\\\)char(\\n)content( )delimiter(/)modifier(x)>operator(\))]
insert[insert(+)              ident(kind) operator(=) symbol(:space)]
insert[insert(+)            keyword(elsif) ident(scan)operator(()regexp<delimiter(/)content([')char(\\()char(\\[)char(\\\))char(\\])content(]|#)char(\\()delimiter(/)>operator(\))]
insert[insert(+)              ident(kind) operator(=) symbol(:operator_fat)]
insert[insert(+)            keyword(elsif) ident(scan)operator(()regexp<delimiter(/)content(;.*)delimiter(/)>operator(\))]
insert[insert(+)              ident(kind) operator(=) symbol(:comment)]
insert[insert(+)            keyword(elsif) ident(scan)operator(()regexp<delimiter(/)content(#)char(\\\\)content((?:newline|space|.?\))delimiter(/)>operator(\))]
insert[insert(+)              ident(kind) operator(=) symbol(:char)]
insert[insert(+)            keyword(elsif) ident(scan)operator(()regexp<delimiter(/)content(#[ft])delimiter(/)>operator(\))]
insert[insert(+)              ident(kind) operator(=) symbol(:pre_constant)]
insert[insert(+)            keyword(elsif) ident(scan)operator(()regexp<delimiter(/)inline<inline_delimiter(#{)constant(IDENTIFIER)inline_delimiter(})>delimiter(/)modifier(o)>operator(\))]
insert[insert(+)              ident(kind) operator(=) ident(ident_kind)operator([)ident(matched)operator(])]
insert[insert(+)            keyword(elsif) ident(scan)operator(()regexp<delimiter(/)char(\\.)delimiter(/)>operator(\))]
insert[insert(+)              ident(kind) operator(=) symbol(:operator)]
insert[insert(+)            keyword(elsif) ident(scan)operator(()regexp<delimiter(/)content(")delimiter(/)>operator(\))]
insert[insert(+)              ident(tokens) operator(<<) operator([)symbol(:open)operator(,) symbol(:string)operator(])]
insert[insert(+)              ident(state) operator(=) symbol(:string)]
insert[insert(+)              ident(tokens) operator(<<) operator([)string<delimiter(')content(")delimiter(')>operator(,) symbol(:delimiter)operator(])]
insert[insert(+)              keyword(next)]
insert[insert(+)            keyword(elsif) ident(scan)operator(()regexp<delimiter(/)inline<inline_delimiter(#{)constant(NUM)inline_delimiter(})>delimiter(/)modifier(o)>operator(\)) keyword(and) keyword(not) ident(matched)operator(.)ident(empty?)]
insert[insert(+)              ident(kind) operator(=) symbol(:integer)]
insert[insert(+)            keyword(elsif) ident(getch)]
insert[insert(+)              ident(kind) operator(=) symbol(:error)]
insert[insert(+)            keyword(end)]
insert[insert(+)            ]
insert[insert(+)          keyword(when) symbol(:string)]
insert[insert(+)            keyword(if) ident(scan)operator(()regexp<delimiter(/)content([^")char(\\\\)content(]+)delimiter(/)>operator(\)) keyword(or) ident(scan)operator(()regexp<delimiter(/)char(\\\\)content(.?)delimiter(/)>operator(\))]
insert[insert(+)              ident(kind) operator(=) symbol(:content)]
insert[insert(+)            keyword(elsif) ident(scan)operator(()regexp<delimiter(/)content(")delimiter(/)>operator(\))]
insert[insert(+)              ident(tokens) operator(<<) operator([)string<delimiter(')content(")delimiter(')>operator(,) symbol(:delimiter)operator(])]
insert[insert(+)              ident(tokens) operator(<<) operator([)symbol(:close)operator(,) symbol(:string)operator(])]
insert[insert(+)              ident(state) operator(=) symbol(:initial)]
insert[insert(+)              keyword(next)]
insert[insert(+)            keyword(else)]
insert[insert(+)              ident(raise_inspect) string<delimiter(")content(else case )char(\\")content( reached; %p not handled.)delimiter(")> operator(%) ident(peek)operator(()integer(1)operator(\))operator(,)]
insert[insert(+)                ident(tokens)operator(,) ident(state)]
insert[insert(+)            keyword(end)]
insert[insert(+)            ]
insert[insert(+)          keyword(else)]
insert[insert(+)            ident(raise) string<delimiter(")content(else case reached)delimiter(")>]
insert[insert(+)          keyword(end)]
insert[insert(+)          ]
insert[insert(+)          ident(match) operator(||=) ident(matched)]
insert[insert(+)          keyword(if) global_variable($DEBUG) keyword(and) keyword(not) ident(kind)]
insert[insert(+)            ident(raise_inspect) string<delimiter(')content(Error token %p in line %d)delimiter(')> operator(%)]
insert[insert(+)            operator([)operator([)ident(match)operator(,) ident(kind)operator(])operator(,) ident(line)operator(])operator(,) ident(tokens)]
insert[insert(+)          keyword(end)]
insert[insert(+)          ident(raise_inspect) string<delimiter(')content(Empty token)delimiter(')>operator(,) ident(tokens)operator(,) ident(state) keyword(unless) ident(match)]
insert[insert(+)          ]
insert[insert(+)          ident(tokens) operator(<<) operator([)ident(match)operator(,) ident(kind)operator(])]
insert[insert(+)          ]
insert[insert(+)        keyword(end)  comment(# until eos)]
insert[insert(+)        ]
insert[insert(+)        keyword(if) ident(state) operator(==) symbol(:string)]
insert[insert(+)          ident(tokens) operator(<<) operator([)symbol(:close)operator(,) symbol(:string)operator(])]
insert[insert(+)        keyword(end)]
insert[insert(+)        ]
insert[insert(+)        ident(tokens)]
insert[insert(+)        ]
insert[insert(+)      keyword(end) comment(#scan_tokens)]
insert[insert(+)    keyword(end) comment(#class)]
insert[insert(+)  keyword(end) comment(#module scanners)]
insert[insert(+)keyword(end) comment(#module coderay)]
comment(\\ No newline at end of file)
head[head(Index: )plain(lib/coderay/scanners/delphi.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay/scanners/delphi.rb)plain(	(revision 200\))]
head[head(+++ )filename(lib/coderay/scanners/delphi.rb)plain(	(revision 250\))]
change[change(@@)plain( -29,13 +29,18 )change(@@)]
       string<delimiter(')content(virtual)delimiter(')>operator(,) string<delimiter(')content(write)delimiter(')>operator(,) string<delimiter(')content(writeonly)delimiter(')>
     operator(])
 
delete[delete(-)    constant(IDENT_KIND) operator(=) constant(CaseIgnoringWordList)operator(.)ident(new)operator(()symbol(:ident)operator(\))operator(.)]
insert[insert(+)    constant(IDENT_KIND) operator(=) constant(CaseIgnoringWordList)operator(.)ident(new)operator(()symbol(:ident)eyecatcher<operator(,) ident(caching)operator(=)predefined_constant(true)>operator(\))operator(.)]
       ident(add)operator(()constant(RESERVED_WORDS)operator(,) symbol(:reserved)operator(\))operator(.)
       ident(add)operator(()constant(DIRECTIVES)operator(,) symbol(:directive)operator(\))
insert[insert(+)    ]
insert[insert(+)    constant(NAME_FOLLOWS) operator(=) constant(CaseIgnoringWordList)operator(.)ident(new)operator(()predefined_constant(false)operator(,) ident(caching)operator(=)predefined_constant(true)operator(\))operator(.)]
insert[insert(+)      ident(add)operator(()string<delimiter(%w()content(procedure function .)delimiter(\))>operator(\))]
 
insert[insert(+)  ident(private)]
     keyword(def) method(scan_tokens) ident(tokens)operator(,) ident(options)
 
       ident(state) operator(=) symbol(:initial)
insert[insert(+)      ident(last_token) operator(=) string<delimiter(')delimiter(')>]
 
       keyword(until) ident(eos?)
 
change[change(@@)plain( -45,19 +50,29 )change(@@)]
         keyword(if) ident(state) operator(==) symbol(:initial)
           
           keyword(if) ident(scan)operator(()regexp<delimiter(/)content( )char(\\s)content(+ )delimiter(/)modifier(x)>operator(\))
delete[delete(-)            ident(kind) operator(=) symbol(:space)]
insert[insert(+)            ident(tokens) operator(<<) operator([)ident(matched)operator(,) symbol(:space)operator(])]
insert[insert(+)            keyword(next)]
             
           keyword(elsif) ident(scan)operator(()regexp<delimiter(%r!)content( )char(\\{)content( )char(\\$)content( [^}]* )char(\\})content(? | )char(\\()char(\\*)content( )char(\\$)content( (?: .*? )char(\\*)char(\\\))content( | .* \) )delimiter(!)modifier(mx)>operator(\))
delete[delete(-)            ident(kind) operator(=) symbol(:preprocessor)]
insert[insert(+)            ident(tokens) operator(<<) operator([)ident(matched)operator(,) symbol(:preprocessor)operator(])]
insert[insert(+)            keyword(next)]
             
           keyword(elsif) ident(scan)operator(()regexp<delimiter(%r!)content( // [^)char(\\n)content(]* | )char(\\{)content( [^}]* )char(\\})content(? | )char(\\()char(\\*)content( (?: .*? )char(\\*)char(\\\))content( | .* \) )delimiter(!)modifier(mx)>operator(\))
delete[delete(-)            ident(kind) operator(=) symbol(:comment)]
insert[insert(+)            ident(tokens) operator(<<) operator([)ident(matched)operator(,) symbol(:comment)operator(])]
insert[insert(+)            keyword(next)]
             
delete[delete(-)          keyword(elsif) eyecatcher<ident(scan)operator(()regexp<delimiter(/)content( [-+*)char(\\/)content(=<>:;,.@)char(\\^)content(|)char(\\()char(\\\))char(\\[)char(\\])content(]+)>>regexp<content( )delimiter(/)modifier(x)>operator(\))]
insert[insert(+)          keyword(elsif) eyecatcher<ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content( <[>=]? | >=? | :=? | [-+=*)char(\\/)content(;,@)char(\\^)content(|)char(\\()char(\\\))char(\\[)char(\\])content(] | )char(\\.)char(\\.)>>regexp<content( )delimiter(/)modifier(x)>operator(\))]
             ident(kind) operator(=) symbol(:operator)
insert[insert(+)          ]
insert[insert(+)          keyword(elsif) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)char(\\.)delimiter(/)>operator(\))]
insert[insert(+)            ident(kind) operator(=) symbol(:operator)]
insert[insert(+)            keyword(if) ident(last_token) operator(==) string<delimiter(')content(end)delimiter(')>]
insert[insert(+)              ident(tokens) operator(<<) operator([)ident(match)operator(,) ident(kind)operator(])]
insert[insert(+)              keyword(next)]
insert[insert(+)            keyword(end)]
             
           keyword(elsif) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content( [A-Za-z_][A-Za-z_0-9]* )delimiter(/)modifier(x)>operator(\))
delete[delete(-)            ident(kind) operator(=) constant(IDENT_KIND)operator([)ident(match)operator(])]
insert[insert(+)            ident(kind) operator(=) eyecatcher<constant(NAME_FOLLOWS)operator([)ident(last_token)operator(]) operator(?) symbol(:ident) operator(:) >constant(IDENT_KIND)operator([)ident(match)operator(])]
             
           keyword(elsif) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)content( ' ( [^)char(\\n)content(']|'' \) (?:'|$\) )delimiter(/)modifier(x)>operator(\))
             ident(tokens) operator(<<) operator([)symbol(:open)operator(,) symbol(:char)operator(])
change[change(@@)plain( -101,6 +116,7 )change(@@)]
             ident(state) operator(=) symbol(:initial)
             keyword(next)
           keyword(elsif) ident(scan)operator(()regexp<delimiter(/)char(\\n)delimiter(/)>operator(\))
insert[insert(+)            ident(tokens) operator(<<) operator([)symbol(:close)operator(,) symbol(:string)operator(])]
             ident(kind) operator(=) symbol(:error)
             ident(state) operator(=) symbol(:initial)
           keyword(else)
change[change(@@)plain( -119,6 +135,7 )change(@@)]
         keyword(end)
         ident(raise_inspect) string<delimiter(')content(Empty token)delimiter(')>operator(,) ident(tokens) keyword(unless) ident(match)
 
insert[insert(+)        ident(last_token) operator(=) ident(match)]
         ident(tokens) operator(<<) operator([)ident(match)operator(,) ident(kind)operator(])
         
       keyword(end)
head[head(Index: )plain(lib/coderay/scanners/debug.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay/scanners/debug.rb)plain(	(revision 0\))]
head[head(+++ )filename(lib/coderay/scanners/debug.rb)plain(	(revision 250\))]
change[change(@@)plain( -0,0 +1,60 )change(@@)]
insert[insert(+)keyword(module) class(CodeRay)]
insert[insert(+)keyword(module) class(Scanners)]
insert[insert(+)]
insert[insert(+)  comment(# = Debug Scanner)]
insert[insert(+)  keyword(class) class(Debug) operator(<) constant(Scanner)]
insert[insert(+)]
insert[insert(+)    ident(include) constant(Streamable)]
insert[insert(+)    ident(register_for) symbol(:debug)]
insert[insert(+)]
insert[insert(+)  ident(protected)]
insert[insert(+)    keyword(def) method(scan_tokens) ident(tokens)operator(,) ident(options)]
insert[insert(+)]
insert[insert(+)      ident(opened_tokens) operator(=) operator([)operator(])]
insert[insert(+)]
insert[insert(+)      keyword(until) ident(eos?)]
insert[insert(+)]
insert[insert(+)        ident(kind) operator(=) predefined_constant(nil)]
insert[insert(+)        ident(match) operator(=) predefined_constant(nil)]
insert[insert(+)]
insert[insert(+)          keyword(if) ident(scan)operator(()regexp<delimiter(/)char(\\s)content(+)delimiter(/)>operator(\))]
insert[insert(+)            ident(tokens) operator(<<) operator([)ident(matched)operator(,) symbol(:space)operator(])]
insert[insert(+)            keyword(next)]
insert[insert(+)            ]
insert[insert(+)          keyword(elsif) ident(scan)operator(()regexp<delimiter(/)content( ()char(\\w)content(+\) )char(\\()content( ( [^)char(\\\))char(\\\\)content(]* ( )char(\\\\)content(. [^)char(\\\))char(\\\\)content(]* \)* \) )char(\\\))content( )delimiter(/)modifier(x)>operator(\))]
insert[insert(+)            ident(kind) operator(=) predefined_constant(self)operator([)integer(1)operator(])operator(.)ident(to_sym)]
insert[insert(+)            ident(match) operator(=) predefined_constant(self)operator([)integer(2)operator(])operator(.)ident(gsub)operator(()regexp<delimiter(/)char(\\\\)content((.\))delimiter(/)>operator(,) string<delimiter(')content(\\1)delimiter(')>operator(\))]
insert[insert(+)            ]
insert[insert(+)          keyword(elsif) ident(scan)operator(()regexp<delimiter(/)content( ()char(\\w)content(+\) < )delimiter(/)modifier(x)>operator(\))]
insert[insert(+)            ident(kind) operator(=) predefined_constant(self)operator([)integer(1)operator(])operator(.)ident(to_sym)]
insert[insert(+)            ident(opened_tokens) operator(<<) ident(kind)]
insert[insert(+)            ident(match) operator(=) symbol(:open)]
insert[insert(+)            ]
insert[insert(+)          keyword(elsif) ident(scan)operator(()regexp<delimiter(/)content( > )delimiter(/)modifier(x)>operator(\))]
insert[insert(+)            ident(kind) operator(=) ident(opened_tokens)operator(.)ident(pop)]
insert[insert(+)            ident(match) operator(=) symbol(:close)]
insert[insert(+)            ]
insert[insert(+)          keyword(else)]
insert[insert(+)            ident(kind) operator(=) symbol(:error)]
insert[insert(+)            ident(getch)]
insert[insert(+)]
insert[insert(+)          keyword(end)]
insert[insert(+)                  ]
insert[insert(+)        ident(match) operator(||=) ident(matched)]
insert[insert(+)        keyword(if) global_variable($DEBUG) keyword(and) keyword(not) ident(kind)]
insert[insert(+)          ident(raise_inspect) string<delimiter(')content(Error token %p in line %d)delimiter(')> operator(%)]
insert[insert(+)            operator([)operator([)ident(match)operator(,) ident(kind)operator(])operator(,) ident(line)operator(])operator(,) ident(tokens)]
insert[insert(+)        keyword(end)]
insert[insert(+)        ident(raise_inspect) string<delimiter(')content(Empty token)delimiter(')>operator(,) ident(tokens) keyword(unless) ident(match)]
insert[insert(+)]
insert[insert(+)        ident(tokens) operator(<<) operator([)ident(match)operator(,) ident(kind)operator(])]
insert[insert(+)        ]
insert[insert(+)      keyword(end)]
insert[insert(+)      ]
insert[insert(+)      ident(tokens)]
insert[insert(+)    keyword(end)]
insert[insert(+)]
insert[insert(+)  keyword(end)]
insert[insert(+)]
insert[insert(+)keyword(end)]
insert[insert(+)keyword(end)]
head[head(Index: )plain(lib/coderay/scanners/rhtml.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay/scanners/rhtml.rb)plain(	(revision 200\))]
head[head(+++ )filename(lib/coderay/scanners/rhtml.rb)plain(	(revision 250\))]
change[change(@@)plain( -51,10 +51,10 )change(@@)]
           ident(start_tag) operator(=) ident(match)operator([)regexp<delimiter(/)char(\\A)content(<%[-=]?)delimiter(/)>operator(])
           ident(end_tag) operator(=) ident(match)operator([)regexp<delimiter(/)content(-?%?>?)char(\\z)delimiter(/)>operator(])
           ident(tokens) operator(<<) operator([)symbol(:open)operator(,) symbol(:inline)operator(])
delete[delete(-)          ident(tokens) operator(<<) operator([)ident(start_tag)operator(,) symbol(:)symbol(delimiter)operator(])]
insert[insert(+)          ident(tokens) operator(<<) operator([)ident(start_tag)operator(,) symbol(:)eyecatcher<symbol(inline_)>symbol(delimiter)operator(])]
           ident(code) operator(=) ident(match)operator([)ident(start_tag)operator(.)ident(size) operator(..) integer(-1) operator(-) ident(end_tag)operator(.)ident(size)operator(])
           instance_variable(@ruby_scanner)operator(.)ident(tokenize) ident(code)
delete[delete(-)          ident(tokens) operator(<<) operator([)ident(end_tag)operator(,) symbol(:)symbol(delimiter)operator(]) keyword(unless) ident(end_tag)operator(.)ident(empty?)]
insert[insert(+)          ident(tokens) operator(<<) operator([)ident(end_tag)operator(,) symbol(:)eyecatcher<symbol(inline_)>symbol(delimiter)operator(]) keyword(unless) ident(end_tag)operator(.)ident(empty?)]
           ident(tokens) operator(<<) operator([)symbol(:close)operator(,) symbol(:inline)operator(])
 
         keyword(else)
head[head(Index: )plain(lib/coderay/scanners/nitro_xhtml.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay/scanners/nitro_xhtml.rb)plain(	(revision 200\))]
head[head(+++ )filename(lib/coderay/scanners/nitro_xhtml.rb)plain(	(revision 250\))]
change[change(@@)plain( -95,20 +95,20 )change(@@)]
           ident(delimiter) operator(=) constant(CLOSING_PAREN)operator([)ident(start_tag)operator([)integer(1)operator(,)integer(1)operator(])operator(])
           ident(end_tag) operator(=) ident(match)operator([)integer(-1)operator(,)integer(1)operator(]) operator(==) ident(delimiter) operator(?) ident(delimiter) operator(:) string<delimiter(')delimiter(')>
           ident(tokens) operator(<<) operator([)symbol(:open)operator(,) symbol(:inline)operator(])
delete[delete(-)          ident(tokens) operator(<<) operator([)ident(start_tag)operator(,) symbol(:)symbol(delimiter)operator(])]
insert[insert(+)          ident(tokens) operator(<<) operator([)ident(start_tag)operator(,) symbol(:)eyecatcher<symbol(inline_)>symbol(delimiter)operator(])]
           ident(code) operator(=) ident(match)operator([)ident(start_tag)operator(.)ident(size) operator(..) integer(-1) operator(-) ident(end_tag)operator(.)ident(size)operator(])
           instance_variable(@ruby_scanner)operator(.)ident(tokenize) ident(code)
delete[delete(-)          ident(tokens) operator(<<) operator([)ident(end_tag)operator(,) symbol(:)symbol(delimiter)operator(]) keyword(unless) ident(end_tag)operator(.)ident(empty?)]
insert[insert(+)          ident(tokens) operator(<<) operator([)ident(end_tag)operator(,) symbol(:)eyecatcher<symbol(inline_)>symbol(delimiter)operator(]) keyword(unless) ident(end_tag)operator(.)ident(empty?)]
           ident(tokens) operator(<<) operator([)symbol(:close)operator(,) symbol(:inline)operator(])
 
         keyword(elsif) ident(match) operator(=) ident(scan)operator(()regexp<delimiter(/)inline<inline_delimiter(#{)constant(NITRO_RUBY_BLOCK)inline_delimiter(})>delimiter(/)modifier(o)>operator(\))
           ident(start_tag) operator(=) string<delimiter(')content(<?r)delimiter(')>
           ident(end_tag) operator(=) ident(match)operator([)integer(-2)operator(,)integer(2)operator(]) operator(==) string<delimiter(')content(?>)delimiter(')> operator(?) string<delimiter(')content(?>)delimiter(')> operator(:) string<delimiter(')delimiter(')>
           ident(tokens) operator(<<) operator([)symbol(:open)operator(,) symbol(:inline)operator(])
delete[delete(-)          ident(tokens) operator(<<) operator([)ident(start_tag)operator(,) symbol(:)symbol(delimiter)operator(])]
insert[insert(+)          ident(tokens) operator(<<) operator([)ident(start_tag)operator(,) symbol(:)eyecatcher<symbol(inline_)>symbol(delimiter)operator(])]
           ident(code) operator(=) ident(match)operator([)ident(start_tag)operator(.)ident(size) operator(..) operator(-)operator(()ident(end_tag)operator(.)ident(size)operator(\))operator(-)integer(1)operator(])
           instance_variable(@ruby_scanner)operator(.)ident(tokenize) ident(code)
delete[delete(-)          ident(tokens) operator(<<) operator([)ident(end_tag)operator(,) symbol(:)symbol(delimiter)operator(]) keyword(unless) ident(end_tag)operator(.)ident(empty?)]
insert[insert(+)          ident(tokens) operator(<<) operator([)ident(end_tag)operator(,) symbol(:)eyecatcher<symbol(inline_)>symbol(delimiter)operator(]) keyword(unless) ident(end_tag)operator(.)ident(empty?)]
           ident(tokens) operator(<<) operator([)symbol(:close)operator(,) symbol(:inline)operator(])
 
         keyword(elsif) ident(entity) operator(=) ident(scan)operator(()regexp<delimiter(/)inline<inline_delimiter(#{)constant(NITRO_ENTITY)inline_delimiter(})>delimiter(/)modifier(o)>operator(\))
head[head(Index: )plain(lib/coderay/scanners/plaintext.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay/scanners/plaintext.rb)plain(	(revision 200\))]
head[head(+++ )filename(lib/coderay/scanners/plaintext.rb)plain(	(revision 250\))]
change[change(@@)plain( -4,6 +4,8 )change(@@)]
   keyword(class) class(Plaintext) operator(<) constant(Scanner)
 
     ident(register_for) symbol(:plaintext)operator(,) symbol(:plain)
insert[insert(+)    ]
insert[insert(+)    ident(include) constant(Streamable)]
 
     keyword(def) method(scan_tokens) ident(tokens)operator(,) ident(options)
       ident(text) operator(=) operator(()ident(scan_until)operator(()regexp<delimiter(/)char(\\z)delimiter(/)>operator(\)) operator(||) string<delimiter(')delimiter(')>operator(\))
head[head(Index: )plain(lib/coderay.rb)]
head[head(===================================================================)]
head[head(--- )filename(lib/coderay.rb)plain(	(revision 200\))]
head[head(+++ )filename(lib/coderay.rb)plain(	(revision 250\))]
change[change(@@)plain( -24,8 +24,8 )change(@@)]
 comment(#)
 comment(# == Usage)
 comment(#)
delete[delete(-)comment(# Remember you need RubyGems to use CodeRay)eyecatcher<comment(. Run Ruby with -rubygems option)>]
delete[delete(-)comment(# )comment(if required.)]
insert[insert(+)comment(# Remember you need RubyGems to use CodeRay)eyecatcher<comment(, unless you have it in your load path. Run Ruby with)>]
insert[insert(+)comment(# )eyecatcher<comment(-rubygems option )>comment(if required.)]
 comment(#)
 comment(# === Highlight Ruby code in a string as html)
 comment(# )
change[change(@@)plain( -44,19 +44,15 )change(@@)]
 comment(# )
 comment(# You can include this div in your page. The used CSS styles can be printed with)
 comment(# )
delete[delete(-)comment(#   % )eyecatcher<comment(ruby -rcoderay -e "print CodeRay::Encoders[:html]::CSS")>]
insert[insert(+)comment(#   % )eyecatcher<comment(coderay_stylesheet)>]
 comment(# )
 comment(# === Highlight without typing too much)
delete[delete(-)comment(#)]
insert[insert(+)comment(#)eyecatcher<comment( )>]
 comment(# If you are one of the hasty (or lazy, or extremely curious\) people, just run this file:)
delete[delete(-)comment(#)]
delete[delete(-)comment(#   % ruby -rubygems coderay.rb)]
 comment(# )
delete[delete(-)comment(# )eyecatcher<comment(If the output was to fast for you, try)>]
insert[insert(+)comment(# )eyecatcher<comment(  % ruby -rubygems /path/to/coderay/coderay.rb > example.html)>]
 comment(# )
delete[delete(-)comment(#   % ruby -rubygems coderay.rb > example.html)]
delete[delete(-)comment(#)]
delete[delete(-)comment(# and look at the file it created.)]
insert[insert(+)comment(# and look at the file it created in your browser.)]
 comment(# )
 comment(# = CodeRay Module)
 comment(#)
change[change(@@)plain( -111,7 +107,7 )change(@@)]
 comment(#)
 comment(# CodeRay.scan_stream:: Scan in stream mode.)
 comment(#)
delete[delete(-)comment(# )eyecatcher<comment( )>comment(== All-in-One Encoding)]
insert[insert(+)comment(# )comment(== All-in-One Encoding)]
 comment(#)
 comment(# CodeRay.encode:: Highlight a string with a given input and output format.)
 comment(#)
change[change(@@)plain( -121,11 +117,16 )change(@@)]
 comment(# for this Encoder must only be done once.)
 comment(#)
 comment(# CodeRay.encoder:: Create an Encoder instance with format and options.)
insert[insert(+)comment(# CodeRay.scanner:: Create an Scanner instance for lang, with '' as default code.)]
 comment(#)
delete[delete(-)comment(# There is no CodeRay.scanner method because Scanners are bound to an input string)]
delete[delete(-)comment(# on creation; you can't re-use them with another string.)]
insert[insert(+)comment(# To make use of CodeRay.scanner, use CodeRay::Scanner::code=.)]
 comment(#)
delete[delete(-)comment(#  The scanning methods provide more flexibility; we recommend to use these.)]
insert[insert(+)comment(# The scanning methods provide more flexibility; we recommend to use these.)]
insert[insert(+)comment(# )]
insert[insert(+)comment(# == Reusing Scanners and Encoders)]
insert[insert(+)comment(# )]
insert[insert(+)comment(# If you want to re-use scanners and encoders (because that is faster\), see)]
insert[insert(+)comment(# CodeRay::Duo for the most convenient (and recommended\) interface.)]
 keyword(module) class(CodeRay)
 
   comment(# Version: Major.Minor.Teeny[.Revision])
change[change(@@)plain( -133,7 +134,7 )change(@@)]
   comment(# Minor: odd for beta, even for stable)
   comment(# Teeny: development state)
   comment(# Revision: Subversion Revision number (generated on rake\))
delete[delete(-)  constant(VERSION) operator(=) string<delimiter(')content(0.7.)>eyecatcher<string<content(4)>>string<delimiter(')>]
insert[insert(+)  constant(VERSION) operator(=) string<delimiter(')content(0.7.)>eyecatcher<string<content(9)>>string<delimiter(')>]
 
   ident(require) string<delimiter(')content(coderay/tokens)delimiter(')>
   ident(require) string<delimiter(')content(coderay/scanner)delimiter(')>
change[change(@@)plain( -170,7 +171,7 )change(@@)]
     keyword(def) method(scan_file) ident(filename)operator(,) ident(lang) operator(=) symbol(:auto)operator(,) ident(options) operator(=) operator({)operator(})operator(,) operator(&)ident(block)
       ident(file) operator(=) constant(IO)operator(.)ident(read) ident(filename)
       keyword(if) ident(lang) operator(==) symbol(:auto)
delete[delete(-)        ident(require) string<delimiter(')content(coderay/helpers/file)>string<content(type)delimiter(')>]
insert[insert(+)        ident(require) string<delimiter(')content(coderay/helpers/file)>eyecatcher<string<content(_)>>string<content(type)delimiter(')>]
         ident(lang) operator(=) constant(FileType)operator(.)ident(fetch) ident(filename)operator(,) symbol(:plaintext)operator(,) predefined_constant(true)
       keyword(end)
       ident(scan) ident(file)operator(,) ident(lang)operator(,) ident(options) operator(=) operator({)operator(})operator(,) operator(&)ident(block)
change[change(@@)plain( -314,6 +315,7 )change(@@)]
 comment(# Run a test script.)
 keyword(if) global_variable($0) operator(==) predefined_constant(__FILE__)
   global_variable($stderr)operator(.)ident(print) string<delimiter(')content(Press key to print demo.)delimiter(')>operator(;) ident(gets)
delete[delete(-)  ident(code) operator(=) constant(File)operator(.)ident(read)operator(()global_variable($0)operator(\))operator([)regexp<delimiter(/)content(module CodeRay.*)delimiter(/)modifier(m)>operator(])]
insert[insert(+)  comment(# Just use this file as an example of Ruby code.)]
insert[insert(+)  ident(code) operator(=) constant(File)operator(.)ident(read)operator(()predefined_constant(__FILE__)operator(\))operator([)regexp<delimiter(/)content(module CodeRay.*)delimiter(/)modifier(m)>operator(])]
   ident(print) constant(CodeRay)operator(.)ident(scan)operator(()ident(code)operator(,) symbol(:ruby)operator(\))operator(.)ident(html)
 keyword(end)

head[head(Property changes on: )plain(lib)]
head[head(___________________________________________________________________)]
head[head(Added: )plain(svn:externals)]
insert[insert(   +)plain( term http://term-ansicolor.rubyforge.org/svn/trunk/lib/term/)]


